\chapter{Especificação formal de DoRiS em TLA+}
\label{ap:dorisSpec}

Um exemplo de arquivo de configuração é apresentado na figura \ref{fig:configFile}. Este
arquivo é utilizado pelo verificador de modelo e permite de definir os parâmetros da
verificação sem alterar a especificação.

Em seguida figura o módulo completo da especificação de \doris.

Neste módulo, as barras horizontais são puramente estéticas. Elas são utilizadas
para separar as ações principais e outros segmentos de códigos.  Também para facilitar
a leitura, escolheu-se de colocar cada ação numa página. Os textos escritos
em fontes menores sob fundos cinzas são comentários.

Observar também que as funções ou ações precedidas de ``A\_'' ou ``B\_'' não são
utilizadas nesta especificação. Elas apenas estão colocadas para ilustrar as mudanças
de cenário de verificação possíveis.

Na primeira linha de código, o módulo carrega quatro outros módulos de TLA+,
usando a palavra chave \textsc{EXTENDS}. Esta palavra permite utilizar 
as funções definidas nos módulos citados. 

\clearpage
\begin{figure}[h!]
\raisebox{-1.3mm}{\rule{\textwidth}{.1pt}}
\raisebox{3mm}{\rule{\textwidth}{.1pt}}
\par\setstretch{1.2}

\tlatex
\setboolean{shading}{true}
\begin{lcom}{0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
This is a \ensuremath{TLC} configuration file for testing \ensuremath{DoRiS
}%
\end{cpar}%
\end{lcom}%
\par\vspace{8.0pt}%
\begin{lcom}{0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
 This statement tells \ensuremath{TLC} that it is to take formula
 \ensuremath{Spec} as
 the specification it is checking.
\end{cpar}%
\end{lcom}%
\@x{ SPECIFICATION\@s{4.91} Spec}%
\par\vspace{8.0pt}%
\begin{lcom}{0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
This statement defines the type invariants of formula \ensuremath{Spec
}%
\end{cpar}%
\end{lcom}%
\@x{ INVARIANTS\@s{4.91} TypeInvariance}%
\par\vspace{8.0pt}%
\begin{lcom}{0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
This statement tells \ensuremath{TLC} to check that the specification implies
 the listed properties. In TLA+, a specification is also a property.
\end{cpar}%
\end{lcom}%
\@x{ PROPERTIES}%
\@x{\@s{29.51} EmptyMedium}%
\@x{\@s{29.51} CollisionAvoidance}%
\@x{\@s{29.51} HardRingCorrectness}%
\@x{\@s{29.51} ReservationSafety}%
\@x{\@s{29.51} SoftRingFairness}%
\@x{\@s{29.51} Omission}%
\@x{\@s{29.51} Failure}%
\@x{}%
\@y{\@s{0}%
 This 3 properties are false and are used to generate counter-examples
}%
\@xx{}%
\@x{\@s{34.44}}%
\@y{\@s{0}%
 \ensuremath{NoCollisionAvoidance
}}%
\@xx{}%
\@x{\@s{34.44}}%
\@y{\@s{0}%
 \ensuremath{NoReservationSafety
}}%
\@xx{}%
\@x{\@s{34.44}}%
\@y{\@s{0}%
 \ensuremath{NoOmission
}}%
\@xx{}%
\par\vspace{8.0pt}%
\begin{lcom}{0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
This statement defines the constants of the \ensuremath{Spec
}%
\end{cpar}%
\end{lcom}%
\@x{ {\CONSTANTS}}%
\@x{\@s{29.51} nTask \.{=} 11}%
\@x{\@s{29.51} nProc\@s{1.18} \.{=} 7}%
\@x{\@s{29.51} deltaChip \.{=} 300}%
\@x{\@s{29.51} delta \.{=} 6}%
\@x{\@s{29.51} pi \.{=} 111}%
\@x{\@s{29.51} maxTxTime \.{=} 122}%
\par%

\setstretch{0.74}%
\raisebox{-2mm}{\rule{\textwidth}{.1pt}}
\raisebox{1mm}{\rule{\textwidth}{.1pt}}\par
%\raisebox{0mm}{\parbox{\textwidth}}%
\caption{Arquivo de configuração da especificação de \doris} 
\label{fig:configFile}
\end{figure}


\newpage
\setstretch{0.9}

\tlatex
\setboolean{shading}{true}
\@x{}\moduleLeftDash\@xx{ {\MODULE} DoRiS}\moduleRightDash\@xx{}%
\@x{ {\EXTENDS} Naturals ,\, Reals ,\, TLC ,\, Sequences}%
\par\vspace{8.0pt}%
\@x{ {\VARIABLES} Shared ,\,\@s{112.99}}%
\@y{\@s{0}%
 Distributed vision shared by tasks and processes
}%
\@xx{}%
\@x{\@s{61.70} TaskState ,\,\@s{97.59}}%
\@y{\@s{0}%
 Tasks local state
}%
\@xx{}%
\@x{\@s{61.70} ProcState ,\,\@s{98.18}}%
\@y{\@s{0}%
 Processes local state
}%
\@xx{}%
\@x{\@s{61.70} History\@s{116.53}}%
\@y{\@s{0}%
 An observer variable
}%
\@xx{}%
\par\vspace{8.0pt}%
\@x{ {\CONSTANTS} nTask ,\,\@s{112.40}}%
\@y{\@s{0}%
 Number of hard tasks
}%
\@xx{}%
\@x{\@s{65.70} nProc ,\,\@s{113.59}}%
\@y{\@s{0}%
 Number of soft processes
}%
\@xx{}%
\@x{\@s{65.70} deltaChip ,\,\@s{94.95}}%
\@y{\@s{0}%
 Duration length of \ensuremath{DoRiS} Period,
}%
\@xx{}%
\@x{\@s{65.70} delta ,\,\@s{118.79}}%
\@y{\@s{0}%
 Duration length of hard message slot
}%
\@xx{}%
\@x{\@s{65.70} pi ,\,\@s{133.19}}%
\@y{\@s{0}%
 Slot message processing time
}%
\@xx{}%
\@x{\@s{65.70} maxTxTime\@s{88.56}}%
\@y{\@s{0}%
 Maximum soft message sizes
}%
\@xx{}%
\par\vspace{8.0pt}%
\@x{}\midbar\@xx{}%
\begin{lcom}{0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
Miscellaneous definitions
\end{cpar}%
\end{lcom}%
 \@x{ min ( Set )\@s{4.91} \.{\defeq} {\CHOOSE} m \.{\in} Set \.{:} \A\, y
 \.{\in} Set \.{:} m \.{\leq} y}%
\par\vspace{8.0pt}%
\@x{ Task \.{\defeq} 1 \.{\dotdot} nTask\@s{108.23}}%
\@y{\@s{0}%
 Tasks indices
}%
\@xx{}%
\@x{ Proc\@s{1.18} \.{\defeq} 1 \.{\dotdot} nProc\@s{109.42}}%
\@y{\@s{0}%
 Processes indices
}%
\@xx{}%
\par\vspace{8.0pt}%
 \@x{ Ti\@s{0.07} \.{\defeq} [ i\@s{0.51} \.{\in} Task \.{\mapsto}
 {\langle}\@w{T} ,\, i {\rangle} ]\@s{33.88}}%
\@y{\@s{0}%
 Tasks tuple
}%
\@xx{}%
 \@x{ Pj \.{\defeq} [ j \.{\in} Proc\@s{1.18} \.{\mapsto} {\langle}\@w{P} ,\,
 j {\rangle} ]\@s{33.91}}%
\@y{\@s{0}%
 Processes tuple
}%
\@xx{}%
\par\vspace{8.0pt}%
 \@x{ TaskSet \.{\defeq} \{ Ti [ i ]\@s{0.59} \.{:} i\@s{16.40} \.{\in} Task
 \}\@s{9.83}}%
\@y{\@s{0}%
 Tasks identifiers set
}%
\@xx{}%
 \@x{ ProcSet\@s{0.58} \.{\defeq} \{ Pj [ j ] \.{:} j\@s{15.88} \.{\in} Proc
 \}\@s{11.02}}%
\@y{\@s{0}%
 Processes identifiers set
}%
\@xx{}%
\par\vspace{8.0pt}%
 \@x{ procId ( P ) \.{\defeq} {\CHOOSE} j \.{\in} Proc\@s{1.18} \.{:}
 P\@s{0.81} \.{=} Pj [ j ]}%
 \@x{ taskId ( T )\@s{0.23} \.{\defeq} {\CHOOSE} i\@s{0.51} \.{\in} Task \.{:}
 T \.{=} Ti [ i ]}%
\par\vspace{8.0pt}%
 \@x{ vars \.{\defeq} {\langle} Shared ,\, ProcState ,\, TaskState ,\, History
 {\rangle}}%
\@x{}\midbar\@xx{}%
\begin{lcom}{0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
Two alternative soft message list fabric.
\end{cpar}%
\end{lcom}%
\par\vspace{8.0pt}%
 \@x{ list ( j ) \.{\defeq} {\CASE} j \.{\in} \{ 1 \} \.{\rightarrow} [ i
 \.{\in} 1 \.{\dotdot} 4 \.{\mapsto} [ txTime \.{\mapsto} maxTxTime ] ]}%
 \@x{\@s{53.37} {\Box}\@s{9.83} j\@s{12.36} \.{\in} \{ 2 \} \.{\rightarrow}
 {\langle} {\rangle}}%
 \@x{\@s{53.37} {\Box}\@s{9.83} j\@s{12.36} \.{\in} \{ 7 ,\, 14 \}
 \.{\rightarrow} [ i \.{\in} 1 \.{\dotdot} 2 \.{\mapsto} [ txTime \.{\mapsto}
 maxTxTime ] ]}%
 \@x{\@s{53.37} {\Box}\@s{9.83} {\OTHER} \.{\rightarrow} 1 \.{\colongt} [
 txTime \.{\mapsto} maxTxTime ]}%
\par\vspace{8.0pt}%
 \@x{ A\_list ( j )\@s{0.77} \.{\defeq} 1 \.{\colongt} [ txTime \.{\mapsto}
 maxTxTime ]}%
\@xx{}%
\@x{}\midbar\@xx{}%


\newpage
\@x{}\contLeftDash\@xx{ ( Continue ) }\contRightDash\@xx{}%
 
\@x{ B\_list ( j ) \.{\defeq} {\IF} j \.{=} 1}%
 \@x{\@s{50.60} \.{\THEN} 1 \.{\colongt} [ txTime \.{\mapsto} maxTxTime ]
 \.{\,@@\,} 2 \.{\colongt} [ txTime \.{\mapsto} maxTxTime ] \.{\,@@\,}}%
\@x{\@s{88.17} 3 \.{\colongt} [ txTime \.{\mapsto} maxTxTime ]}%
\@y{%
 \ensuremath{\.{\,@@\,} 4 \.{\colongt}} [ \ensuremath{txTime \.{\mapsto} 50} ]
}%
\@xx{}%
 \@x{\@s{50.60} \.{\ELSE} {\IF} j \.{=} 2 \.{\THEN} {\langle} {\rangle}
 \.{\ELSE} 1 \.{\colongt} [ txTime \.{\mapsto} maxTxTime ]}%
\@x{\@s{214.24}}%
\@y{\@s{0}%
 \ensuremath{\.{\,@@\,} 2 \.{\colongt}} [ \ensuremath{txTime \.{\mapsto}
 maxTxTime} ]
}%
\@xx{}%
\@x{}\midbar\@xx{}%
\begin{lcom}{0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
Initializations of the variables.
\end{cpar}%
\end{lcom}%
\par\vspace{8.0pt}%
\@x{ Init \.{\defeq}}%
 \@x{\@s{24.68} \.{\land} Shared \.{=} [ chipTimer \.{\mapsto} 0 ,\, chipCount
 \.{\mapsto} 1 ,\, macTimer \.{\mapsto} 0 ,\, medium \.{\mapsto} \{ \} ]}%
 \@x{\@s{24.68} \.{\land} TaskState \.{=} [ i\@s{0.51} \.{\in} Task
 \.{\mapsto} [ msg \.{\mapsto} {\langle} {\rangle} ,\, execTimer \.{\mapsto}
 Infinity ,\,}%
 \@x{\@s{175.52} res\@s{5.31} \.{\mapsto} [ j \.{\in} Task \.{\mapsto} \.{-} 1
 ] ,\, cons \.{\mapsto} nTask \.{-} i \.{+} 1 ] ]}%
 \@x{\@s{24.68} \.{\land} ProcState\@s{0.58} \.{=} [ j \.{\in} Proc\@s{1.18}
 \.{\mapsto} [ token \.{\mapsto} 1 ,\, list \.{\mapsto} list ( j ) ,\, count
 \.{\mapsto} 0 ] ]}%
 \@x{\@s{24.68} \.{\land} History \.{=} [ elem \.{\mapsto} 0 ,\, rese
 \.{\mapsto} 0 ]}%
\@x{}\midbar\@xx{}%
\begin{lcom}{0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
The elementary and reservation slot action.\@s{18.0}   \newline 
 \ensuremath{reservation(i)} is an arbitrary reservation function
 that states that tasks wants to reserve as much slots as possible.
 ``pi'' is the time the message will need to be processed by others tasks.
\end{cpar}%
\end{lcom}%
\par\vspace{8.0pt}%
\@x{ reservation ( i ) \.{\defeq}}%
\@x{\@s{29.51} {\IF} TaskState [ i ] . cons \.{=} nTask}%
 \@x{\@s{29.51} \.{\THEN} \{ j \.{\in} Task \.{:} TaskState [ i ] . res [ j ]
 \.{=} \.{-} 1 \}}%
 \@x{\@s{29.51} \.{\ELSE} \{ ( ( ( i \.{-} 1 ) \.{+} ( nTask \.{-} 1 )
 )\@s{4.91} \.{\%}\@s{4.91} nTask ) \.{+} 1 \}}%
\par\vspace{8.0pt}%
\@x{ SendElem ( T ) \.{\defeq}}%
\@x{\@s{29.51} \.{\land} Shared . medium \.{=} \{ \}}%
\@x{\@s{29.51} \.{\land} Shared . chipTimer \.{=} 0}%
\@x{\@s{29.51} \.{\land} \.{\LET} i \.{\defeq} taskId ( T )}%
\@x{\@s{42.85} \.{\IN} \.{\land} Shared . chipCount \.{=} i}%
\@x{\@s{67.33} \.{\land} \.{\LET} resSet \.{\defeq} reservation ( i )}%
\@x{\@s{80.66} \.{\IN} \.{\land} Shared \.{'} \.{=} [ Shared {\EXCEPT}}%
\@x{\@s{138.15} ! . macTimer \.{=} delta ,\,}%
 \@x{\@s{138.15} ! . medium \.{=} \{ [ id \.{\mapsto} i ,\, type
 \.{\mapsto}\@w{hard} ,\, res \.{\mapsto} resSet ] \} ]}%
\@x{\@s{105.14} \.{\land} TaskState \.{'} \.{=} [ TaskState {\EXCEPT}}%
 \@x{\@s{138.15} ! [ i ] . res \.{=} [ j \.{\in} Task \.{\mapsto} {\IF} j
 \.{\in} resSet \.{\THEN} i \.{\ELSE} @ [ j ] ] ,\,}%
\@x{\@s{138.15} ! [ i ] . cons \.{=} 1 ]}%
 \@x{\@s{67.33} \.{\land} History \.{'} \.{=} [ History {\EXCEPT} ! . elem
 \.{=} @ \.{+} 1 ]}%
\@x{\@s{67.33} \.{\land} {\UNCHANGED} ProcState}%
\@xx{}%
\@x{}\midbar\@xx{}%



\newpage
\@x{}\contLeftDash\@xx{ ( Continue ) }\contRightDash\@xx{}%

\@x{ SendRese ( T ) \.{\defeq}}%
\@x{\@s{29.51} \.{\land} Shared . medium \.{=} \{ \}}%
\@x{\@s{29.51} \.{\land} Shared . chipTimer \.{=} delta}%
\@x{\@s{29.51} \.{\land} \.{\LET} i \.{\defeq} taskId ( T )}%
 \@x{\@s{42.85} \.{\IN} \.{\land} TaskState [ i ] . res [ Shared . chipCount ]
 \.{=} i}%
\@x{\@s{67.33} \.{\land} Shared \.{'} \.{=} [ Shared {\EXCEPT}}%
\@x{\@s{100.34} ! . macTimer \.{=} delta ,\,}%
 \@x{\@s{100.34} ! . medium \.{=} \{ [ id \.{\mapsto} i ,\, type
 \.{\mapsto}\@w{hard} ,\, res \.{\mapsto} \{ \.{-} 1 \} ] \} ]}%
 \@x{\@s{67.33} \.{\land} TaskState \.{'} \.{=} [ j \.{\in} Task \.{\mapsto} [
 TaskState [ j ] {\EXCEPT}}%
\@x{\@s{100.34} ! . res [ Shared . chipCount ] \.{=} \.{-} 1 ] ]}%
 \@x{\@s{67.33} \.{\land} History \.{'} \.{=} [ History {\EXCEPT} ! . rese
 \.{=} @ \.{+} 1 ]}%
\@x{\@s{67.33} \.{\land} {\UNCHANGED} ProcState}%
\@x{}\midbar\@xx{}%
\begin{lcom}{0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
The soft window action.
 \ensuremath{lenTX} is the message transmission time. The \ensuremath{Failed}
 set has to be define according
 to which processes failure scenario is chosen.
\end{cpar}%
\end{lcom}%
\par\vspace{8.0pt}%
 \@x{ Failed \.{\defeq} {\CASE} Shared . chipCount \.{=} 2 \.{\rightarrow} \{
 3 \}}%
 \@x{\@s{73.55} {\Box}\@s{4.91} Shared . chipCount \.{\in} \{ 3 ,\, 4 \}
 \.{\rightarrow} \{ 3 ,\, 5 \}}%
 \@x{\@s{73.55} {\Box}\@s{4.91} Shared . chipCount \.{=} 5 \.{\rightarrow} \{
 3 ,\, 5 \}}%
\@x{\@s{73.55} {\Box}\@s{4.91} {\OTHER} \.{\rightarrow} \{ \}}%
\par\vspace{8.0pt}%
%\@x{ lenMsg ( i ) \.{\defeq}}%
% \@x{\@s{19.67} {\IF} ProcState [ i ] . list \.{\neq} {\langle} {\rangle}
% \.{\THEN} Head ( ProcState [ i ] . list ) . txTime \.{\ELSE} delta}%
\@x{ lenMsg ( i ) \.{\defeq}
 {\IF} ProcState [ i ] . list \.{\neq} {\langle} {\rangle}
 \.{\THEN} Head ( ProcState [ i ] . list ) . txTime \.{\ELSE} delta}%
\par\vspace{8.0pt}%
\@x{ SendSoft ( P ) \.{\defeq}}%
\@x{\@s{29.51} \.{\land} 2 \.{*} delta \.{\leq} Shared . chipTimer}%
\@x{\@s{29.51} \.{\land} Shared . chipTimer \.{\leq} deltaChip}%
\@x{\@s{29.51} \.{\land} Shared . medium \.{=} \{ \}}%
\@x{\@s{29.51} \.{\land} \.{\LET} i \.{\defeq} procId ( P )}%
\@x{\@s{67.33} lenTX \.{\defeq} lenMsg ( i )}%
\@x{\@s{67.33} d \.{\defeq} Shared . chipTimer \.{+} lenTX}%
\@x{\@s{67.33} NoMsg \.{\defeq} i \.{\in} Failed \.{\lor} d \.{>} deltaChip}%
\@x{\@s{42.85} \.{\IN} \.{\land} i \.{=} ProcState [ i ] . token}%
\@x{\@s{67.33} \.{\land} Shared \.{'} \.{=} [ Shared {\EXCEPT}}%
 \@x{\@s{100.34} ! . macTimer \.{=} {\IF} NoMsg \.{\THEN} Infinity \.{\ELSE}
 lenTX ,\,}%
 \@x{\@s{100.34} ! . medium \.{=} {\IF} NoMsg \.{\THEN} @ \.{\ELSE} \{ [ id
 \.{\mapsto} i ,\, type \.{\mapsto}\@w{soft} ] \} ]}%
\@x{\@s{67.33} \.{\land} ProcState \.{'} \.{=} [ ProcState {\EXCEPT}}%
 \@x{\@s{100.34} ! [ i ] . token \.{=} {\IF} NoMsg \.{\THEN} @ \.{\ELSE} (
 @\@s{4.91} \.{\%}\@s{4.91} nProc ) \.{+} 1 ,\,}%
 \@x{\@s{100.34} ! [ i ] . list \.{=} {\IF} d \.{>} deltaChip \.{\lor} @ \.{=}
 {\langle} {\rangle} \.{\THEN} @ \.{\ELSE} Tail ( @ ) ,\,}%
 \@x{\@s{100.34} ! [ i ] . count \.{=} {\IF} NoMsg \.{\THEN} @ \.{\ELSE} @
 \.{+} 1 ]}%
 \@x{\@s{67.33} \.{\land} {\UNCHANGED} {\langle} TaskState ,\, History
 {\rangle}}%
\@xx{}%
\@x{}\midbar\@xx{}%

\newpage
\@x{}\contLeftDash\@xx{ ( Continue ) }\contRightDash\@xx{}%

\begin{lcom}{0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
The hard and soft messages receiving actions.
 We may introduce omission failures in the hard message reception action.
 \ensuremath{noMsgReceptionSet} defines the set of nodes that shall not
 receive a message. When an
 omission failure happens, the ``Reserv'' and ``Consistency'' sequence are
 not updated.
\end{cpar}%
\end{lcom}%
\par\vspace{8.0pt}%
 \@x{ NoRecvSet ( m ) \.{\defeq} {\IF} Shared . chipCount \.{\in} \{ 2 ,\, 4
 \} \.{\THEN} \{ m . id ,\, 3 \} \.{\ELSE} \{ m . id \}}%
\par\vspace{8.0pt}%
\@x{ A\_NoRecvSet ( m ) \.{\defeq} \{ m . id \}}%
\par\vspace{8.0pt}%
\@x{ RecvHard ( m ) \.{\defeq}}%
\@x{\@s{29.51} \.{\land} m . type \.{=}\@w{hard}}%
\@x{\@s{29.51} \.{\land} Shared . macTimer \.{=} 0}%
 \@x{\@s{29.51} \.{\land} Shared \.{'} \.{=} [ Shared {\EXCEPT} ! . medium
 \.{=} \{ \} ]}%
\@x{\@s{29.51} \.{\land} TaskState \.{'} \.{=}}%
 \@x{\@s{67.45} [ i \.{\in} NoRecvSet ( m ) \.{\mapsto} TaskState [ i ] ]
 \.{\,@@\,}}%
 \@x{\@s{67.45} [ i \.{\in} Task \.{\,\backslash\,} NoRecvSet ( m )
 \.{\mapsto} [ TaskState [ i ] {\EXCEPT}}%
\@x{\@s{96.24} ! . msg \.{=} Append ( @ ,\, m ) ,\,}%
 \@x{\@s{96.24} ! . execTimer \.{=} {\IF} Len ( TaskState [ i ] . msg ) \.{=}
 0 \.{\THEN} pi \.{\ELSE} @ ,\,}%
 \@x{\@s{96.24} ! . cons \.{=} {\IF} m . res \.{\neq} \{ \.{-} 1 \} \.{\THEN}
 @ \.{+} 1 \.{\ELSE} @ ,\,}%
\@x{\@s{96.24} ! . res \.{=} {\IF} m . res\@s{2.26} \.{=} \{ \.{-} 1 \}}%
 \@x{\@s{134.11} \.{\THEN} [ j \.{\in} Task \.{\mapsto} {\IF} j \.{=} m . id
 \.{\THEN} \.{-} 1 \.{\ELSE} @ [ j ] ]}%
 \@x{\@s{134.11} \.{\ELSE} [ j \.{\in} Task \.{\mapsto} {\IF} j \.{\in} m .
 res \.{\THEN} m . id \.{\ELSE} @ [ j ] ] ] ]}%
 \@x{\@s{29.51} \.{\land} {\UNCHANGED} {\langle} ProcState ,\, History
 {\rangle}}%
\par\vspace{8.0pt}%
\@x{ RecvSoft ( m ) \.{\defeq}}%
\@x{\@s{29.51} \.{\land} m . type \.{=}\@w{soft}}%
\@x{\@s{29.51} \.{\land} Shared . macTimer \.{=} 0}%
 \@x{\@s{29.51} \.{\land} Shared \.{'} \.{=} [ Shared {\EXCEPT} ! . medium
 \.{=} \{ \} ]}%
 \@x{\@s{29.51} \.{\land} ProcState \.{'} \.{=} [ j \.{\in} \{ m . id \}
 \.{\mapsto} ProcState [ j ] ] \.{\,@@\,}}%
 \@x{\@s{111.27} [ j \.{\in} Proc \.{\,\backslash\,} \{ m . id \} \.{\mapsto}
 [ ProcState [ j ] {\EXCEPT}}%
 \@x{\@s{247.67} ! . token\@s{0.54} \.{=} ( @\@s{4.91} \.{\%}\@s{4.91} nProc )
 \.{+} 1 ,\,}%
\@x{\@s{247.67} ! . count \.{=} @ \.{+} 1 ] ]}%
 \@x{\@s{29.51} \.{\land} {\UNCHANGED} {\langle} TaskState ,\, History
 {\rangle}}%
\@x{}\midbar\@xx{}%
\begin{lcom}{0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
 \ensuremath{NextTick} and \ensuremath{NextChip} are the only actions that
 update timers according to passage
 of time.
 \ensuremath{NextTick} search the best next time increment and updates all
 timers
 \ensuremath{NextChip} reset the \ensuremath{ChipTimer} and increment
 \ensuremath{ChipCount} modulo the number of task.
 It sets the arbitrary soft sequence of message of each process during every
 cycle.
 Alltogether, this 2 actions allow the time circularity of the model.
 The count counter allows to check if a soft message has been sent in the
 previous
 chip. If it is not the case, all processes increment the token value by 1 at
 the end of the chip.
\end{cpar}%
\end{lcom}%


\newpage
\@x{}\contLeftDash\@xx{ ( Continue ) }\contRightDash\@xx{}%

\@x{ NextTick \.{\defeq}}%
 \@x{\@s{29.51} \.{\LET} noRese \.{\defeq} \.{\land} Shared . medium \.{=} \{
 \}}%
\@x{\@s{113.53} \.{\land} Shared . chipTimer \.{=} delta}%
 \@x{\@s{113.53} \.{\land} \A\, i \.{\in} Task \.{:} TaskState [ i ] . res [
 Shared . chipCount ] \.{\neq} i}%
 \@x{\@s{53.99} tmp \.{\defeq} min ( \{ TaskState [ i ] . execTimer \.{:} i
 \.{\in} Task \} \.{\cup}}%
\@x{\@s{121.97} \{ deltaChip \.{-} Shared . chipTimer \} )}%
 \@x{\@s{53.99} d \.{\defeq} {\IF} noRese \.{\THEN} min ( \{ delta ,\, tmp \}
 ) \.{\ELSE} min ( \{ Shared . macTimer ,\, tmp \} )}%
\@x{\@s{29.51} \.{\IN} \.{\land} d \.{>} 0}%
\@x{\@s{53.99} \.{\land} Shared \.{'} \.{=} [ Shared {\EXCEPT}}%
\@x{\@s{87.01} ! . chipTimer \.{=} @ \.{+} d ,\,}%
\@x{\@s{87.01} ! . macTimer \.{=} {\IF} noRese}%
\@x{\@s{163.58} \.{\THEN} @}%
 \@x{\@s{163.58} \.{\ELSE} {\IF} @ \.{=} Infinity \.{\THEN} Infinity\@s{4.91}
 \.{\ELSE} @ \.{-} d ]}%
 \@x{\@s{53.99} \.{\land} TaskState \.{'} \.{=} [ i \.{\in} Task \.{\mapsto} [
 TaskState [ i ] {\EXCEPT}}%
 \@x{\@s{87.01} ! . msg \.{=} {\IF} TaskState [ i ] . execTimer \.{-} d \.{=}
 0\@s{4.91} \.{\THEN} Tail ( @ ) \.{\ELSE} @ ,\,}%
\@x{\@s{87.01} ! . execTimer \.{=} {\IF} @ \.{-} d \.{=} 0}%
 \@x{\@s{163.58} \.{\THEN} {\IF} Len ( TaskState [ i ] . msg ) \.{>} 1
 \.{\THEN} pi \.{\ELSE} Infinity}%
 \@x{\@s{163.58} \.{\ELSE} {\IF} @ \.{=} Infinity \.{\THEN} @ \.{\ELSE} @
 \.{-} d ] ]}%
 \@x{\@s{53.99} \.{\land} {\UNCHANGED} {\langle} ProcState ,\, History
 {\rangle}}%
\par\vspace{8.0pt}%
\@x{ NextChip \.{\defeq}}%
\@x{\@s{29.51} \.{\land}\@s{5.30} Shared . medium \.{=} \{ \}}%
\@x{\@s{29.51} \.{\land}\@s{5.30} Shared . chipTimer \.{=} deltaChip}%
 \@x{\@s{29.51} \.{\land}\@s{5.30} \.{\LET} Overflow \.{\defeq} \E\, j \.{\in}
 Proc \.{:} Len ( ProcState [ j ] . list ) \.{>} 14}%
\@x{\@s{72.63} NextCycle \.{\defeq} Shared . chipCount \.{'} \.{=} 1}%
 \@x{\@s{48.15} \.{\IN}\@s{4.91} \.{\land} Shared \.{'} \.{=} [ Shared
 {\EXCEPT}}%
\@x{\@s{110.57} ! . macTimer \.{=} 0 ,\,}%
 \@x{\@s{110.57} ! . chipCount\@s{0.90} \.{=} ( @\@s{4.91} \.{\%}\@s{4.91}
 nTask ) \.{+} 1 ,\,}%
 \@x{\@s{110.57} ! . chipTimer \.{=} {\IF} Overflow \.{\THEN} \.{-} 1
 \.{\ELSE} 0 ]}%
 \@x{\@s{77.55} \.{\land} ProcState \.{'} \.{=} [ j \.{\in} Proc \.{\mapsto} [
 ProcState [ j ] {\EXCEPT}}%
 \@x{\@s{110.57} ! . token\@s{0.54} \.{=} {\IF} ProcState [ j ] . count \.{=}
 0 \.{\THEN}\@s{4.91} ( @\@s{4.91} \.{\%}\@s{4.91} nProc ) \.{+} 1 \.{\ELSE}
 @ ,\,}%
\@x{\@s{110.57} ! . count \.{=} 0 ,\,}%
 \@x{\@s{110.57} ! . list \.{=} {\IF} NextCycle \.{\THEN} @ \.{\circ} list ( j
 ) \.{\ELSE} @ ] ]}%
\@x{\@s{77.55} \.{\land} {\IF} NextCycle}%
 \@x{\@s{90.89} \.{\THEN} History \.{'} \.{=} [ elem \.{\mapsto} 0 ,\, rese
 \.{\mapsto} 0 ]}%
\@x{\@s{90.89} \.{\ELSE} {\UNCHANGED} History}%
\@x{\@s{29.51} \.{\land}\@s{5.30} {\UNCHANGED} TaskState}%
\@xx{}%
\@x{}\midbar\@xx{}%



\newpage
\@x{}\contLeftDash\@xx{ ( Continue ) }\contRightDash\@xx{}%

\begin{lcom}{0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
 Next defines the set of possible actions that doesn\mbox{'}t alterate the
 timers.
 \ensuremath{Init} is the initial state, \ensuremath{Next} is the disjunct of
 steps choices,
 and \ensuremath{Tick} describes the passage of time.
\end{cpar}%
\end{lcom}%
\par\vspace{8.0pt}%
\@x{ Tick\@s{5.39} \.{\defeq} NextTick \.{\lor} NextChip}%
\par\vspace{8.0pt}%
 \@x{ Next\@s{4.92} \.{\defeq}\@s{4.91} \.{\lor} \E\, T \.{\in} TaskSet \.{:}
 SendElem ( T ) \.{\lor} SendRese ( T )}%
 \@x{\@s{56.87} \.{\lor} \E\, P\@s{0.81} \.{\in} ProcSet\@s{0.58} \.{:}
 SendSoft ( P )}%
 \@x{\@s{56.87} \.{\lor} \E\, msg \.{\in} Shared . medium \.{:} RecvHard ( msg
 ) \.{\lor} RecvSoft ( msg )}%
\par\vspace{8.0pt}%
\@x{ Liveness \.{\defeq}\@s{4.91} {\Box} {\Diamond} Tick}%
\par\vspace{8.0pt}%
 \@x{ Spec\@s{4.91} \.{\defeq}\@s{4.91} Init \.{\land} {\Box} [ Next\@s{4.91}
 \.{\lor} Tick ]_{ vars} \.{\land} Liveness}%

\@x{}\midbar\@xx{}%
\begin{lcom}{0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
 The following temporal properties are checked when specified in the
 \ensuremath{DoRiS.cfg
} configuration file.
\end{cpar}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
``\ensuremath{TypeInvariance}'' checks the variables type invariance.
\end{cpar}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
 ``\ensuremath{CollisionAvoidance}'' checks that the token can be hold by only
 one task or process
 at once.
 ``\ensuremath{HardRingCorrectness}'' makes use of the ``History'' variable
 to check that all
 mandatory elementary message are sent in a \ensuremath{DoRiS} cycle.
 ``\ensuremath{ReservationSafety}'' guaranty that if a task holds the token
 in a reservation slot,
 then all other tasks are aware of its reservation.
\end{cpar}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
 ``\ensuremath{SoftRingFairness}'' guaranty that each process will eventually
 receive the token.
\end{cpar}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
``Omission'' states that some task omission failure takes place.
\end{cpar}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
``Failure'' states that some process failure takes place.
\end{cpar}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
 ``\ensuremath{NoReservationSafety}'', ``\ensuremath{NoCollisionAvoidance}''
 and ``\ensuremath{NoOmission}'' are contradiction
 of the respective properties, used to generate handfull conter-examples.
\end{cpar}%
\end{lcom}%
\par\vspace{8.0pt}%
 \@x{ HardMsg \.{\defeq} Seq ( [ id \.{:} Task ,\, type \.{:} \{\@w{hard} \}
 ,\, res \.{:} {\SUBSET} ( \{ \.{-} 1 \} \.{\cup} Task ) ] )}%
\par\vspace{8.0pt}%
 \@x{ MediumMsg \.{\defeq} \{ m \.{:} m \.{\in} [ id \.{:} Proc ,\,
 type\@s{1.18} \.{:} \{\@w{soft} \} ] \.{\cup}}%
 \@x{\@s{137.80} [ id \.{:} Task ,\, type \.{:} \{\@w{hard} \} ,\, res \.{:}
 {\SUBSET} ( \{ \.{-} 1 \} \.{\cup} Task ) ] \}}%
\par\vspace{8.0pt}%
\@x{ TypeInvariance \.{\defeq}}%
\@x{\@s{29.51} \.{\land} Shared . chipCount\@s{0.90} \.{\in} Task}%
\@x{\@s{29.51} \.{\land} Shared . chipTimer \.{\in} 0 \.{\dotdot} deltaChip}%
 \@x{\@s{29.51} \.{\land} Shared . macTimer \.{\in} 0 \.{\dotdot} maxTxTime
 \.{\cup} \{ Infinity \}}%
 \@x{\@s{29.51} \.{\land} \A\, m \.{\in} Shared . medium \.{:} m \.{\in}
 MediumMsg}%
 \@x{\@s{29.51} \.{\land} ProcState \.{\in} [ Proc \.{\rightarrow} [ token
 \.{:} Proc ,\, count \.{:} 0 \.{\dotdot} 50 ,\,}%
 \@x{\@s{67.45} list \.{:} \{ {\langle} {\rangle} \} \.{\cup} Seq ( [ txTime
 \.{:} \{ maxTxTime \} ] ) ] ]}%
 \@x{\@s{29.51} \.{\land} TaskState\@s{11.14} \.{\in} [ Task \.{\rightarrow} [
 msg \.{:} \{ {\langle} {\rangle} \} \.{\cup} HardMsg ,\, res \.{:} [ Task
 \.{\rightarrow} \{ \.{-} 1 \} \.{\cup} Task\@s{4.91} ] ,\,}%
 \@x{\@s{170.38} execTimer \.{:} 0 \.{\dotdot} pi \.{\cup} \{ Infinity \} ,\,
 cons \.{:} Task ] ]}%
\@xx{}%
\@x{}\midbar\@xx{}%

\newpage
\@x{}\contLeftDash\@xx{ ( Continue ) }\contRightDash\@xx{}%

\@x{ Send ( Q ) \.{\defeq} \.{\lor} \.{\land} Q \.{\in} TaskSet}%
 \@x{\@s{80.92} \.{\land} ( {\ENABLED} SendElem ( Q ) \.{\lor} {\ENABLED}
 SendRese ( Q ) )}%
\@x{\@s{67.59} \.{\lor} \.{\land} Q \.{\in} ProcSet}%
\@x{\@s{80.92} \.{\land} {\ENABLED} SendSoft ( Q )}%
\par\vspace{8.0pt}%
 \@x{ CollisionAvoidance \.{\defeq} \A\, P ,\, Q \.{\in} TaskSet \.{\cup}
 ProcSet \.{:}}%
 \@x{\@s{146.32} {\Box} ( {\ENABLED} ( Send ( P ) \.{\land} Send ( Q ) )
 \.{\implies} ( P \.{=} Q ) )}%
\par\vspace{8.0pt}%
 \@x{ NoCollisionAvoidance \.{\defeq} \E\, P ,\, Q \.{\in} TaskSet \.{\cup}
 ProcSet \.{:}}%
 \@x{\@s{153.78} {\Diamond} ( ( P \.{\neq} Q ) \.{\land} {\ENABLED} ( Send ( P
 ) \.{\land} Send ( Q ) ) )}%
\par\vspace{8.0pt}%
\@x{ HardRingCorrectness \.{\defeq}}%
 \@x{\@s{29.51} \.{\land} \A\, T \.{\in} TaskSet \.{:} \.{\land} {\Box} ( Len
 ( TaskState [ taskId ( T ) ] . msg ) \.{\leq} 3 )}%
\@x{\@s{128.00} \.{\land} {\Box} {\Diamond} {\ENABLED} SendElem ( T )}%
 \@x{\@s{29.51} \.{\land} {\Box} ( {\ENABLED} NextChip \.{\implies} History .
 elem \.{=} Shared . chipCount )}%
\par\vspace{8.0pt}%
\@x{ ReservationSafety \.{\defeq}}%
 \@x{\@s{29.51} {\Box}\@s{4.91} \A\, chip ,\, j \.{\in} Task \.{:} \.{\land}
 {\ENABLED} SendRese ( Ti [ j ] )}%
\@x{\@s{137.11} \.{\land} Shared . chipCount \.{=} chip}%
\@x{\@s{43.40} \.{\implies} \.{\land} TaskState [ j ] . res [ chip ] \.{=} j}%
 \@x{\@s{62.07} \.{\land} \A\, i \.{\in} Task \.{\,\backslash\,} \{ j \} \.{:}
 TaskState [ i ] . res [ chip ] \.{\in} \{ j ,\, \.{-} 1 \}}%
\par\vspace{8.0pt}%
\@x{ SoftRingFairness \.{\defeq}}%
 \@x{\@s{29.51} \.{\land} \A\, i \.{\in} Proc \.{:} {\Box} {\Diamond} ( i
 \.{=} ProcState [ i ] . token )}%
 \@x{\@s{29.51} \.{\land} {\Box} {\Diamond} ( \A\, i \.{\in} Proc
 \.{\,\backslash\,} Failed \.{:} Len ( ProcState [ i ] . list ) \.{=} 0 )}%
\par\vspace{8.0pt}%
\@x{ NoReservationSafety \.{\defeq}}%
 \@x{\@s{29.51} {\Box} {\Diamond}\@s{4.91} \E\, chip \.{\in} Task \.{:} \E\, j
 \.{\in} Task \.{:}}%
\@x{\@s{61.57} \.{\land} TaskState [ j ] . res [ chip ] \.{\neq} \.{-} 1}%
\@x{\@s{61.57} \.{\land} {\ENABLED} SendRese ( Ti [ j ] )}%
\@x{\@s{61.57} \.{\land} Shared . chipCount \.{=} chip}%
 \@x{\@s{61.57} \.{\land} \E\, i \.{\in} Task \.{\,\backslash\,} \{ j \} \.{:}
 {\neg} TaskState [ i ] . res [ chip ] \.{\in} \{ j ,\, \.{-} 1 \}}%
\par\vspace{8.0pt}%
\@x{ Omission \.{\defeq} \E\, T \.{\in} TaskSet \.{:}}%
 \@x{\@s{48.89} {\Diamond} ( {\ENABLED} SendElem ( T )\@s{4.91} \.{\land}
 TaskState [ taskId ( T ) ] . cons \.{<} nTask )}%
\par\vspace{8.0pt}%
\@x{ NoOmission \.{\defeq} \A\, T \.{\in} TaskSet \.{:}}%
 \@x{\@s{44.28} {\Box} ( {\ENABLED} SendElem ( T )\@s{4.91} \.{\implies}
 TaskState [ taskId ( T ) ] . cons \.{=} nTask )}%
\par\vspace{8.0pt}%
 \@x{ Failure \.{\defeq} {\Box} {\Diamond} ( \E\, P \.{\in} ProcSet \.{:}
 procId ( P ) \.{\in} Failed )}%
\par\vspace{8.0pt}%
\@x{}\bottombar\@xx{}%


\begin{comment}

\newpage
\@x{}\contLeftDash\@xx{ ( Continue ) }\contRightDash\@xx{}%

\end{comment}
