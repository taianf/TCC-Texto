\chapter{Especificação e verificação formal em TLA+} % (10 pag)
\label{cap:specVerif}



\section{abstract}

This paper describes \doris, a new shared-Ethernet real-time protocol and its TLA+
formal specification and verification.  \doris{} is fault tolerant and capable of
dealing with hard, soft and best-effort real-time traffics so that predictability is
guaranteed for hard real-time tasks while non-hard real-time ones can benefit from
the allocation of higher network bandwidth.  The specification provides a precise
protocol description and the verification ensures the reliability of its design.

% The protocol is formally specified in TLA+ using a level of abstraction which
% allows for the representation of temporal properties and fault scenarios, both
% common aspects of distributed communication. The state explosion problem is dealt
% with by a suitable discrete time representation and correstness is successfully
% several temporal properties are successfully verified by the TLC model-checker.



\section{Introduction}

% New automation and control systems are characterized by their increasing
% requirements for flexibility and service integration in addition to their usual
% requirements such as fault tolerance and predictability.  Processing in such
% modern real-time distributed systems (RTS) is carried out by hard, soft, periodic
% and aperiodic tasks sharing common resources. Some of these tasks may depend on
% high processing and communication speeds (e.g.  multimedia tasks) while others
% (e.g. control tasks) need to comply with strict timing specifications.

% Lying at the core of new automation and control systems, communication networks
% are of paramount importance as far as Quality-of-Service (QoS) and timing
% correctness are concerned.  Usually, high predictability and fault tolerance are
% achieved by field-bus technologies.  However, such networks are not suitable to
% provide integration and flexibility in hybrid systems. Their low bandwidth, for
% instance, make it difficult to transmit multimedia-like data.

\subsection{Motivation}

Ethernet is known as a promising alternative to tradi\-tional field-bus for
supporting modern real-time sys\-tems~\cite{Decotignie05}.  However, the 802.3
network standard is not deterministic because temporal latencies of message
transmissions depend either on probabilistic bus access for Shared-Ethernet or on
queuing policies for Switch-Ethernet.  In order to make Ethernet suitable for
real-time sys\-tems application domain, new rules need to be added to the standard
to avoid message loss.

% ok
The development of such rules requires careful design decisions.  We claim here that
formal specification and verification are helpful methods, which are recommended to
achieve confidence in the protocol conception process.  Indeed, formally specifying
a system and check\-ing its correctness in a mech\-anized manner provides an
accurate knowledge of its behaviors and can help one to detect errors or
misconceptions at the early stages of software development
\cite{Auslander96,Clarke99}.  Such an approach, not yet common in the network
research community, has already been successfully used in several application
domains \cite{Barboza06, Johnson04, Hanssen06}.
% ko

In this work, a set of rules that makes up a new real-time Ethernet protocol, called
\doris, is described and verified using formal specification and model-checking.


\subsection{Related Work}
\label{sec:relatedWork}

Several approaches have been proposed to make Ethernet deterministic by controlling
bus access \cite{Decotignie05}.  Here we focus on those most related to \doris{}
which uses the standard Ethernet hardware and where hosts share a common bus in a
half-duplex mode.

A common approach to real-time shared-Ethernet protocols is the TDMA scheme where
nodes send messages only in predefined slots.  However, TDMA lacks flexibility as
even if a station has nothing to transmit its time slot is wasted.  Other protocols,
such as FTT \cite{Pedreiras02}, use a master-slave model to control bus access.
Here a special node plays the role of an arbiter (the master) polling other nodes
(the slaves).  Slaves are allowed to transmit their messages only if they get
permission to do so. This model can handle hard and soft traffics but exhibits a
single point of failure which can be dealt with by master replication. Moreover,
there is an asymmetric load distribution on the net, which may imply problems of
scalability and performance.

Token-based protocols, usually more flexible than TDMA, use a token to give
permission to a node to transmit messages. The nodes are organized in a logical ring
and the token rotates on the ring. Only the token holder node has the right to
transmit on the bus. RETHER \cite{Venkatrami94} and RTnet \cite{Hanssen06} are
examples of explicit-token protocols. Although they deal with different traffic
patterns, extra overhead is introduced in case of token loss.

Implicit-token protocols based on Timed Packet Release mechanism (TPR) offer another
alternative \cite{Pritty95, Carreiro03}.  A token is implicitly passed on to the
next node regardless of whether the previous node on the ring transmits its message
or not.  The absence of message means that a node is giving up its turn to use the
bus.  Such an approach, however, has not yet been used in the context of systems
composed of soft and hard components.  Another way to avoid collisions is
switch-based solutions \cite{Kopetz05}.  However, the use of switches introduces
routing, forwarding and buffering delays. Furthermore, broadcast communication
implementation is not as easy as in shared-Ethernet and requires special care to
manage traffic congestion in the switch buffers \cite{Wang02, LoBello01}.


% In a precedent work, we used UPPALL \cite{Barboza06} to specify and verify the
% protocol 802.11. Although this tool was found to be appropriate for such a
% proposal, we chose here to use the Temporal Logic of Actions and its associated
% language TLA+ \cite{Lamport02a}, which have powerful expressiveness and allows for
% a hierarchical specification of system functionalities.  To check the protocol
% correctness, the model-checker TLC~\cite{Yu99} was used.

% In the last three decades, many formal languages and verification tools were
% developed based on temporal logic \cite{Larsen97,Henzinger91}.  For example,
% Esterel \cite{Berry92} is a synchronous language well-suited to specify hardware
% systems and to express complex properties of synchronous systems like circuits or
% large scale operating systems. However, it is mainly devoted to programming
% control-dominated software or hardware reactive systems.

% The Specification and Description Language (SDL) and the Estelle standard have
% recently been extended to allow for the specification of RTS ~\cite{Fischer96,
%   Sinnott04}.  Nevertheless, neither SDL nor Estelle are devoted to model-checking
% but to formal description and code generation in the preliminary stages of the
% implementation process.  Many other available tools are based on timed automata,
% as Kronos \cite{Daws96} and HyTech \cite{Alur96}.  Promela is now dotted of a
% real-time extension that provides semantics for the specification and the
% verification of real-time temporal properties \cite{Tripakis96}.  Another popular
% toolset is UPPALL \cite{Larsen97}, which was recently used to specify and check an
% Ethernet-based real-time protocol, RTnet \cite{Hanssen06}.

% The Temporal Logic of Actions and its associated language TLA+ \cite{Lamport02a}
% together with the TLC model-checker \cite{Yu99} is another suitable alternative
% for specifying RTS \cite{Abadi94,Lamport05}. The TLA+ syntax is based on usual
% mathematics and was specially designed to express temporal properties of
% concurrent and distributed systems properties ~\cite{Johnson04}.  Our choice of
% TLA+ to specify and verify \doris{} was motivated by three main reasons. First,
% TLA+ provides a modular structure %%%
% which allows for an incremental process of specification refinements, according to
% the abstraction level required. Second, a TLA+ specification has a structure
% similar to a program code. Thus, it offers a solid basis to develop the \doris{}
% software implementation.  Third, the TLC model-checker provides an automatic
% verification of the specification and its properties.

% Indeed, formally specifying a system and checking its correctness through a
% mechanized way provides an accurate knowledge of the system behaviors and the
% possibility to detect errors or misconceptions at an early stage of the software
% development.

\subsection{Contributions}

% We propose a new Ethernet-based communication protocol, called \doris{} (an
% Ethernet Double Ring Service protocol).  whose main principles have been recently
% discussed \cite{Regnier06}.  \doris{} is a shared-Ethernet-based protocol
% conceived to fulfill the requirements of modern real-time systems, where reliable
% and predictable communication is provided for hard tasks, and high bandwidth
% network is available to soft or best effort tasks. By mixing TDMA and
% implicit-token approaches, predictability is achieved without compromising
% flexibility.

We propose a new shared-Ethernet-based communication protocol, called \doris{} (an
Ethernet Double Ring Service protocol), designed to fulfill the requirements of
modern real-time systems where reliable and predictable communication is provided
for hard tasks, and high bandwidth network is available for soft or best effort
tasks. By mixing TDMA and implicit-token approaches, predictability is achieved
without compromising flexibility.

We have used Temporal Logic of Actions and its associated language TLA+
\cite{Lamport02a} as a tool to support the protocol design. This has enabled us to
carry out both the conception and the specification of \doris{} interactively and
progressively as an integrated software engineering process.  Using feedback
information obtained by running the TLC model-checker~\cite{Yu99}, we checked the
feasibility of specific mechanisms or rules, modifying them whenever necessary.  At
the end of the specification and verification process, we obtained a reliable formal
description of the \doris{} protocol and of its temporal properties. This
specification is currently being used as a basis for its implementation.  To the
best of our knowledge, this approach has not yet been used in designing real-time
communication protocols.

After outlining \doris{} in section \ref{sec:dorisProt}, section \ref{sec:dorisSpec}
gives our modeling assumptions and some initial concepts on TLA+, before addressing
the description of the specification itself.  Finally, a discussion of the verified
properties appears in section \ref{sec:verif}.  Concluding remarks are given in
section \ref{sec:conclusion}.

% ------------------------------------------------------------------------- \newpage
\section{The \doriss protocol}
\label{sec:dorisProt}

\doris{} is a collision-free protocol built on top of half-duplex Ethernet
hardware. The protocol works as a logical layer, extending the CSMA/CD MAC
layer~\cite{CSMA/CD01}. It is designed to support hybrid systems where industrial
sensors, actuators and controllers share the communication network with other soft
applications.  In such a hybrid configuration, the processing speed and the
communication characteristics of the two types of application may differ
considerably \cite{Carreiro03}.  % Regnier06}.
Thus, we assume that a number of industrial appliances (micro-controllers, sensors
etc), called hereafter {\em slow} nodes, have low processing times when compared to
{\em fast} nodes such as workstations.


\subsection{The model and terminology}
\label{sec:model}
% \subsubsection{Node model}

The set of nodes (slow or fast) connected through the same shared-Ethernet bus make
up a \doris{} segment.  Although many \doris{} segments can be inter-connected by
switches or routers, we will restrict our specification and verification to an
isolated \doris{} segment.

% In such a segment, each node executes a \doris{} server, which is responsible for
% carrying out some protocol processing requirements (processing incoming messages,
% for example).

In each node there may be hard, soft or best-effort tasks.  For the sake of
notation, we shall simply the former tasks while soft or best-effort tasks are
called processes.  We define $nTask$ and $nProc$ as the numbers of tasks and
processes respectively, and $Task$ and $Proc$, as the sets of their unique
identifiers.
% associated with the unique server hosted in each node.
These sets define the two logical rings of a \doris{} segment, where a single token
rotates.
%
% We assume that there is a number of industrial appliances (micro-controllers,
% sensors etc) sharing the segment. These appliances, called hereafter {\em slow}
% nodes, have low processing times when compared to {\em fast} nodes such as
% workstations.  Received messages are processed by the tasks within a maximum
% processing time, denoted $\pi$, which is associated to worst-case processing time
% of slow nodes.
%
% The processing time for message transmission is assumed to be included in the task
% computation time and so is ignored during the protocol description.
%
% \subsubsection{Communication model}
%
Messages from slow nodes are short, usually periodic, and have hard real-time
constraints.  Such messages, called \emph{hard messages}, are assumed to have a
constant length of 64B. They are processed upon reception by the tasks within a
maximum processing time, denoted $\pi$, which is associated to worst-case processing
time of slow nodes.  Hard messages are transmitted through the network within a
maximum transmission time $\delta \ll \pi$.  If only slow nodes are present in the
\doris{} segment, the bus may be under-utilized.  However, if there are fast nodes
connected to the bus, \doris{} allows them to use this spare bandwidth. Assuming
that nodes are equipped with buffers, receiving and processing hard messages are
independent actions that can be executed simultaneously. This also implies that more
than one message can be sent in a row.
% The protocol uses the publish-subscribe communication model according to which
% whenever a task or process has a message to send, it transmits such a message
% using the Ethernet broadcast standard address (48 address bits set to 1).  Each
% task/process receives and processes some part or the totality of every
% message. Based on the source address, they then decide whether they are interested
% in the message. In practical applications, tasks may not have to process all
% messages or may drop unused ones. However,
For the sake of model simplification, we consider here that received hard real-time
messages are fully processed. % by all tasks.

% When various applications are located at the same node, the local \doris{} server
% uniquely identifies their messages using the type field of the Ethernet frame and
% delivers them to the destination task or process.

% \subsubsection{Synchronism model}

We assume a synchronous distributed system. This means that actions taken by nodes
can be synchronized with each other. This assumption is based on the time division
scheme of \doris{}, which, as will be seen, has regular and predictable points of
synchronism which take place within a small time window.
% In other words, we assume that
This implies that node clocks are synchronized.
%
% Besides local clocks, each node of a \doris{} segment has access to the state of
% the MAC ???.
%
% This assumption is in line with the usual carrier-sense capability of the Ethernet
% standard. Indeed, the MAC state is available at some Ethernet cards \cite{3C90xB}.
% In short, when a message is transmitted, the state of the MAC layer changes from
% \emph{idle} to \emph{busy}.  The MAC then remains busy during the message
% transmission time, which is proportional to the length of the message and
% inversely proportional to the MAC transmission rate. When the transmission of a
% message finishes, an End-Of-Frame interrupt is generated at every Ethernet card,
% signaling the change of the MAC layer state.
%
% \subsubsection{Failure model}
%

We also assume that nodes may crash and transmitted messages may be lost.  However,
fast nodes must notice the receiving message interruption signal, even if the
message content is lost. As will be seen, this requirement is necessary to control
the token.
% ~\footnote{A simple test...}
This restriction does not apply to slow nodes.  Since these nodes have lower
computational capabilities, this assumption is in line with the practical
application needs.
% A node crashes at time $t$, when it remains silent from $t$ onwards.  As for
% message omission, it may occur because a node fails to send a message or because
% the receiver missed it due to late processing, say. We and we consider that the
% communication network does not create nor arbitrarily alter message contents.

% If some part of the message is altered, by electromagnetic interference for
% example, it is assumed that a checksum test is performed by the receiver, allowing
% it to transform this fault in an omission by simply discarding the erroneous
% message.


% A central assumption of the \doris{} protocol is that non-crashed nodes cannot
% erroneously detect the MAC state whenever it tries to. Thus, even if it fails to
% receive or process some message, a node is aware of the bus activity. Note that
% detecting the MAC state does not require receiving messages.

% -------------------------------------------------------------------------

\subsection{The Medium Access Control Scheme}
\label{sec:MAC}

\begin{figure}[tb]
  \centering
  % \resizebox{8 cm}{!}{}
  \input{fig/dorisStruct.pstex_t}
  \caption{The \doris{} Time Division Scheme}
  \label{fig:dorisStruct}
\end{figure}

The communication on a \doris{} segment is timely divided into a series of
communication (\emph{C-Rd}) and membership rounds (\emph{M-Rd}), as illustrated in
Figure \ref{fig:dorisStruct}. During \emph{M-Rd}, % are for executing
the membership control algorithm is responsible for keeping a common membership view
before the communication round begins.  Since the focus of the specification is on
the communication rounds, the membership round will not be further described and we
consider hereafter fixed values of $nTask$ and $nProc$.

Using TDMA, each \emph{C-Rd} is defined as an arbitrary but fixed
% but previously defined
number of periodic cycles, which in turn are subdivided into exactly $nTask$ chips
(see Figure \ref{fig:dorisStruct}). Each of these chips is subdivided into two
windows, hard and soft, denoted \HW and \SW, respectively, which are associated with
hard and non-hard real-time traffics. Tasks send messages in \HW and processes use
\SW to transmit theirs. The size of \HW and \SW is denoted \DHW and \DSW and the
chip size is defined by $\DDC = \DHW + \DSW$. To allow for some flexibility and
message scheduling policy, each hard real-time window \HW is further divided into
two slots, the elementary (\ES) and the reservation (\RS) slots. Messages sent in
these two slots are hard messages, called elementary and reservation messages
respectively.  Once per cycle each tasks send an elementary message in \ES while \RS
is used to implement a reservation mechanism.  In order to tolerate crash failure
and provide reliability for the whole system, elementary messages are mandatory.

The reservation mechanism works as follows. Each elementary message sent by a task
$i$ carries a list of slots the task is interested in for transmitting additional
messages.  This list contains the identifiers of such reservation slots in the next
$nTask$ chips. Task $i$ is only allowed to reserve a slot if two conditions hold:
such a slot has not been reserved by an other task and task $i$ is in a
\emph{consistent} state. This is the case % A task is said to be consistent
if task $i$ has received the previous $nTask$ elementary messages.  Consequently,
the dynamic slot allocation scheme is tolerant to message omissions.  This
reservation mechanism is an innovation of \doris{} and allows the application to
implement some scheduling policy.
Indeed, a task has the right to use an elementary slot per cycle and may use up to
$nTask-1$ other slots. However, discussion of this is beyond the scope of this
paper.

The medium access control of \doris{} is regulated by a virtual token, which rotates
in the \emph{hard} and \emph{soft} rings (section \ref{sec:model}).  The token is
said to be \emph{virtual} because no explicit message is used to allow a station to
transmit. Instead, the right to transmit is passed on through both rings using
timing or logical conditions based on observed communication activities.  A pure
TDMA scheme is used to isolate the two rings of \doris{}.
% and in each ring. state and timing conditions rule the token passing scheme.  In
% the \emph{hard} ring, the reservation mechanism allows for communication
% flexibility.
As for the soft ring scheme, the token rotates during \SW whenever an interruption
is issued by the Ethernet card.
% message is transmitted.  or when the bus remains idle for a given amount of time.
% If a process has nothing to transmit, it may remain silent.
When a process has nothing to transmit, it sends a minimum size packet to pass the
token on the ring.

% We define the time packet release delay parameter ($tprDelay$) as the maximum
% amount of time that a task can hold the token without transmitting a
% message. After any $tprDelay$ time units that the bus remains silent, the virtual
% token moves to the next process in the soft ring.  This bus arbitration scheme,
% which relies on the carrier sense mechanism provided by Ethernet, is very
% efficient since the value of $tprDelay$ is usually much shorter than the time to
% transmit an explicit token \cite{Pritty95,Carreiro03}.  It is important to
% emphasize that the medium access is controlled by timing rules so that only one
% message can be transmitted at once.

%%% 
% Depending on the characteristics of the nodes and on the Ethernet-bus speed,
% \doris{} can be configured so that bandwidth allocation can be optimized. This
% involves the calibration of both \DHW and \DSW and the suitable instantiation of
% tasks. This issues are not going to be addressed in this paper since the focus
% here is on the specification of the general protocol behavior and its
% verification.
%%% 
% -------------------------------------------------------------------------
% \section{Specifying \emph{DoRiS} }
% \label{sec:specifying}


% ------------------------------------------------------------------------

% ----------------------------------------------------------------------
\section{The specification }
\label{sec:dorisSpec}

Before enhancing on a detailed top-down description of the \doris{} specification,
we first give the set of assumptions made to specify the protocol (section
\ref{sec:SpecConsiderations}) and introduce some concept on TLA+ (section
\ref{sec:basicTLA}). Then the formulas that make up the \doris{} specification are
described.

\subsection{Modeling assumptions}
\label{sec:SpecConsiderations}

Important system characteristics must be included in the specification so that one
can verify interesting properties.  However, care must be taken not to specify too
many details due to model checking state explosion problems. The assumptions made in
this section are to circumvent these problems without compromising the protocol
description and its verification.

% First, as our main goal here is to provide a formal description of the \doris{}
% protocol and to verify its correctness, we will assume that each node hosts only
% one task or process.  Doing this avoids the need of specifying the \doris{}
% servers.

% The assumptions stated here are to avoid specifying unnecessary system details.

First, we represent time as an integer variable.  Although discrete time
representation can compromise the model accuracy of asynchronous systems in
general~\cite{Clarke99}, it is acceptable for synchronous message-passing protocols
\cite{Lamport05}. Second, we also consider that whenever a specified action gets
enabled, it either happens without delay or is immediately disabled. This implies
that timers are specified with null jitter.  Finally, since we assume a synchronous
model and to avoid the specification of clock synchronization details, we consider
that all nodes share a common global clock. Note that in practice, as elementary
messages are mandatory, all nodes can synchronize their local clocks with high
precision and accuracy even in the presence of message omissions.
 
It is important to note that the considerations on null jitter and on synchronous
system make it possible to define global timers in the specification, which
considerably reduces state explosion %related
problems.

\subsection{Concepts on TLA+}
\label{sec:basicTLA}
% The Temporal Logic of Actions (TLA) and its associated formal language (TLA+)
% combine the Temporal Logic of TLA~\cite{Lamport02a} with the expressiveness of
% predicate logic and Zermelo-Fraenkel set theory. Equipped with its associated
% model-checker, TLC~\cite{Yu99}, one can specify and verify both hardware and
% distributed protocols. In this section, we present some basic syntax of TLA+.
% Other information on TLA+ will be given along with the description of the \doris{}
% specification.  Readers interested in a comprehensive description of TLA+ can
% refer to Lamport's publication ~\cite{ Lamport02a}.

In a TLA+ specification, a computation of a system is represented as a sequence of
states. A \textbf{state} of the system is an assignment of values to variables and a
sequence of states is called a \textbf{behavior} which describes a history. A pair
of consecutive states, $i$ and $f$ say, is named a \textbf{step}, denoted $i
\rightarrow f$.  The prime ($'$) operator is used to distinguish the values of
variables on a step.  Considering a given step $S:i \rightarrow f$ and assuming a
variable $v$ on S, the unprimed occurrence ($v$) refers to its value in $i$ while
the primed occurrence ($v'$) refers to its value in $f$.

A state predicate is a boolean expression where only unprimed variables occur. A
transition function on a step is an expression where primed and unprimed variables
occur. For example, if step $S$ is such that $v = 0$ in $i$ and $v = 1$ in $f$, the
transition function $[ v' - v ]$ equals $1$ on $S$.  Finally, an \textbf{action} is
defined as a boolean-valued transition function on steps. In the above example, the
action defined by $[ v' = v + 1 ]$ is true of step $S$.  Note that for a given step
$S$, the next-state relation from state $i$ to state $f$, usually called state
transition function in Finite State Machine formalism, is defined by the set of
actions defined %%true
on $S$. As an action can be made up of several other actions, this set is also an
action.

TLA+ temporal formulas are boolean assertions about behaviors.
% assert about behaviors.
A behavior satisfies a formula $\mathcal{F}$ if $\mathcal{F}$ is a true assertion of
this behavior.  The temporal logic operator $\Box$ is used to define the transition
relationship between states.  The semantic of $\Box$ is defined as follows: for some
behavior $\Sigma$ and some action $A$, the temporal formula $Spec = \Box [ A
]_{vars}$ is true - or simply ``$\Sigma$ satisfies $Spec$'' - if and only if for any
step $S:i \rightarrow f$ of $\Sigma$ that changes the tuple $vars$ of all flexible
variables, $A$ is true on $S$.


% This is equivalent to asserting that In order to illustrate the structure of a
% typical TLA+ specification, let us consider the formula \emph{Spec}, which can be
% considered as the \emph{main} formula of the \doris{} specification, defined by
%

\subsection{The main formula \emph{Spec}}

% Before to step into the detailed description of each action, l
The \doris{} \emph{main} formula is defined by

\iniTLA
\begin{notla}
  Spec == Init /\ [] [ Next \/ Tick ]_vars /\ Liveness
\end{notla}
\begin{tlatex}
  \@x{\@s{8.2} Spec\@s{4.1} \.{\defeq}\@s{4.1} Init \.{\land} {\Box} [ Next\@s{4.1}
    \.{\lor} Tick ]_{ vars} \.{\land} Liveness}%
\end{tlatex}
% \vspace{0.3cm}
\finTLA

This formula describes the behaviors of the sys\-tem through the definition of the
set of initial states, called \emph{Init}, the next-state relation, here based on
the disjunct of the two actions, \emph{Next} or \emph{Tick}, and a liveness
constraint.
% Hence, \emph{Next} and \emph{Tick} are the set of actions that may be true on some
% step of the behavior.
A behavior $\Sigma$ satisfies \emph{Spec} iff the first state of $\Sigma$ satisfies
\emph{Init} and every step of $\Sigma$ satisfies either \emph{Next} or \emph{Tick}
and the \emph{Liveness} condition.  Note that as a consequence of the timed
structure of \doris{} (section \ref{sec:MAC}), most actions of \doris{} are ruled by
exclusive enabling conditions. Hence, the ``$\lor$'' operator is exclusive in most
of its occurrences.

% As seen before, the formula $Spec$ is composed of the \emph{Init} predicate, the
% next-state relation $[ Next \lor Tick ]$, and the \emph{Liveness} constraint.

% -------------------------------- Action -------------------------------
\act{Init} The $Init$ predicate defines %is responsible for defining
the initial protocol states by assigning values to all variables used in the
specification.
% For the sake of space and
Since the $Init$ is a long formula that does not describe functionalities of the
protocol, it will be omitted here.

% The complete specification %for interested readers
% is available~\footnote{http://www.lasid.ufba.br/public/reltec/DoRiS.zip}.
% \cite{DoRiS07}.

% -------------------------------- Action -------------------------------
\act{Next} This action describes %includes
% the actions of the specification devoted to the description of
the protocol functionalities that %actions
leaves time unchanged.
% The \emph{Next} action may be a next-state relation for some step.

\iniTLA
\begin{notla}
  Next == \/ \E i \in Task : ElemSlot(i) \/ ReseSlot(i) \/ HardRecv(i) \/ SoftRecv
  \/ \E j \in Proc : SoftWind(j)
\end{notla}
\begin{tlatex}
  \@x{ Next \.{\defeq} \.{\lor} \E\, i \.{\in} Task \.{:} ElemSlot ( i ) \.{\lor}
    ReseSlot ( i ) \.{\lor} HardRecv ( i )}%
  \@x{\@s{33.6} \.{\lor} SoftRecv \.{\lor} \E\, j \.{\in} Proc \.{:} SoftWind ( j
    )}%
\end{tlatex}
\finTLA

The first line of this formula describes the hard ring service. It states that a
given task may take one of the three following steps: the $ElemSlot(i)$ action,
which describes the transmission of an elementary message; the $ReseSlot(i)$ action,
which describes the transmission of a reservation message; and the $HardRecv(i)$
action, which is responsible for the reception of hard messages.

The soft ring service is specified in the second line of the formula by means of
both the $SoftWind(j)$ action, which describes the steps a given process $j$ can
take, and the $SoftRecv$ action, which is responsible for the reception of soft
messages.
%
%%%%
% The soft ring service is specified in the second line of the formula and has a
% similar meaning as for the steps a given process $j$ can take: either the
% $SoftWind(j)$ action, which describes the soft window scheme, or the $SoftRecv$
% action, which describes the reception of a soft message can be enabled.
%
%%%
If no state satisfies the enabling conditions of these five actions, the only
remaining possibility is the $Tick$ action, unless deadlock has been reached.

% These five actions will be detailed in sections \ref{sec:hardRing} and
% \ref{sec:softRing}.

% -------------------------------- Action -------------------------------
\act{Tick} This action, defined as $Tick \defeq NextTick \lor NextChip$, represents
the flow of time.  To allow for the verification of some finite model, despite the
unbounded nature of time, we use a circular time representation by defining the
$Tick$ action as a disjunction of two actions: $NextTick$, which increments the
timers by discrete steps, and $NextChip$, which implements the time circularity by
resetting the global count-up timer \emph{ChipTimer} upon every start of a chip. As
this timer assumes values ranging from $0$ to \DDC, it allows for the representation
of time when combined with the counter $ChipCount$ of the current chip.

% Details of this circular time representation will be given in section
% \ref{sec:TickAction}.

% -------------------------------- Action -------------------------------
\act{Liveness} This constraint, defined as $Liveness \defeq \Box \Diamond Tick$,
ensures that a behavior that satisfies $Spec$ lasts forever (where $\Diamond F
\defeq \neg \Box \neg F$). It implies that a behavior satisfying $Spec$ contains an
infinite number of $Tick$ steps. As $Tick$ is the action used to represent time
progression, $Liveness$ is satisfied by unbounded time behaviors.  In addition, due
to the circular time representation, behaviors that satisfy $Spec$ are periodic,
allowing for the model-checking of some finite models. %%%

\begin{comment}
  \iniTLA
  \begin{notla}
    Liveness == []<> Tick
  \end{notla}
  \begin{tlatex}
    \@x{ Liveness \.{\defeq} {\Box} {\Diamond} Tick}%
  \end{tlatex}
  \finTLA
\end{comment}
  
\subsection{The Hard Ring}
\label{sec:hardRing}

As said before, the hard real-time ring is specified in terms of three main actions,
$ElemSlot$, $ReseSlot$, and $HardRecv$.

% -------------------------------- Action -------------------------------
\act{ElemSlot} This action describes the rules used to send elementary messages. It
is composed of another action, $sendHardMsg$, and the state function
$reservation$. The former describes the sending of a message and the latter deals
with the definition of reservation lists.

\iniTLA
\begin{tla}
  ElemSlot(i) == /\ BusyMAC = 0 /\ ChipTimer = 0 /\ i = ChipCount /\ LET resSet ==
  reservation(i) IN /\ Reserv' = [ Reserv EXCEPT ![i] = [j \in Task |-> IF j \in
  resSet THEN i ELSE @[j] ] ] /\ sendHardMsg(i, resSet, pi) /\ Consistency' = [
  Consistency EXCEPT ![i] = 1 ] /\ BusyMAC' = delta /\ UNCHANGED << ChipCount,
  Token, SoftMsg, ChipTimer, MsgList >>
\end{tla}
\begin{tlatex}
  \@x{ ElemSlot ( i ) \.{\defeq}}%
  \@x{\@s{8.2} \.{\land} BusyMAC \.{=} 0\@s{4.1} \.{\land} ChipTimer \.{=} 0\@s{4.1}
    \.{\land} i \.{=} ChipCount}%
  \@x{\@s{8.2} \.{\land} \.{\LET} resSet \.{\defeq} reservation ( i )}%
  \@x{\@s{19.31} \.{\IN} \.{\land} Reserv \.{'} \.{=} [ Reserv {\EXCEPT} ! [ i ]
    \.{=} [ j \.{\in} Task \.{\mapsto}}%
  \@x{\@s{92.55} {\IF} j \.{\in} resSet\@s{4.1} \.{\THEN} i\@s{4.1} \.{\ELSE} @ [ j
    ] ] ]}%
  \@x{\@s{30.0} \.{\land} sendHardMsg ( i ,\, resSet ,\, pi )}%
  \@x{\@s{8.2} \.{\land} Consistency \.{'} \.{=} [ Consistency {\EXCEPT} ! [ i ]
    \.{=} 1 ]}%
  \@x{\@s{8.2} \.{\land} BusyMAC \.{'} \.{=} delta}%
  \@x{\@s{8.2} \.{\land} {\UNCHANGED} {\langle} ChipCount ,\, Token ,\,}%
  \@x{\@s{80.88} SoftMsg ,\, ChipTimer ,\, MsgList {\rangle}}%
\end{tlatex}
\finTLA

The token rotation scheme uses a counter modulo $nTask$, here defined by the global
variable $ChipCount$, which holds the value of the on-going chip. This counter is
periodically incremented by action $NextChip$ whenever $ChipTimer$ times out at the
end of each chip (as will be seen in section \ref{sec:TickAction}).  $BusyMAC$ is a
count-down timer which represents the message transmission time. It equals $0$ when
the MAC state is idle.  Otherwise, it equals the remaining time to complete an
on-going message transmission. These variables are used to define the three enabling
predicates (first line of the formula) which state that task $i$ is allowed to send
a message: (i) when the previous transmission has finished ($BusyMAC = 0$); (ii) the
chip is starting ($ChipTimer = 0$) and; (iii) task $i$ has the token ($i =
ChipCount$).  These conditions ensure that task $i$ only sends one elementary
message per \doris{} cycle.

Note that in TLA+, indentation is significant in order to eliminate parenthesis.
Hence, the operators $\land$ and $\lor$ are used to construct meaningful
indented-list.  The $LET \ldots IN$ is another useful syntax construction used to
define local variables.  The $\textsc{unchanged}$ operator lists all the variables
(some will appear in the upcoming sections) whose values are not updated by the
action. Due to space limitations, we may represent this list by ``$\ldots$''.

As can be seen, the action $ElemSlot$ changes the values of $Reserv$, $Consistency$
and $BusyMAC$ (primed variables). The latter assumes the value of $\delta$, the time
it takes to transmit a hard message. %%%
$Consistency$ is a tuple of counters that keeps track of the elementary messages
received per task.  Whenever an elementary message is received by task $i$,
$Consistency[i]$ is incremented by $1$ and when task $i$ sends its elementary
message, $Consistency[i]$ is reset to $1$. Thus, if $Consistency[i] = nTask$, no
omission %%%
failure has occurred since the time $i$ sent its previous elementary message.  Note
that the TLA+ expression $[ Consistency \; \textsc{except} \; ![i] = 1 ]$ means that
the record $Consistency$ remains unchanged except for the entry $i$ which is set to
$1$.

% Here, , the reservation list of task $i$, is defined by the state function
% $reservation$.
The \emph{reservation} function is used to generate $resSet$, the reservation list
of task $i$, which indicates the slots task $i$ will be interested in transmitting
additional messages.  Its definition depends on the needs of tasks for
extra-bandwidth. For simplicity, we assumed here that all tasks try to reserve the
maximum number of reservation slots. Referring back to section \ref{sec:MAC}, a task
can do so if it is in a consistent state (has received all previous $nTask$
elementary messages) and the slots are still not reserved. If task $i$ is
inconsistent, it is still allowed to carry out the reservation of \RS of chip $i$ in
the next cycle as no other task could have reserved such a slot before.  The
reservation function is not shown here since it is related to the application layer.

\begin{comment}
  \iniTLA
  \begin{notla}
    reservation(i) == IF Consistency[i] = nTask THEN { j \in Task: Reserv[i][j] = -1
    } ELSE { ( ( (i - 1) + (nTask - 1) ) % nTask ) + 1}
    \end{notla}
    \begin{tlatex}
      \@x{ reservation ( i ) \.{\defeq}}%
      \@x{\@s{8.2} {\IF} Consistency [ i ] \.{=} nTask}%
      \@x{\@s{8.2} \.{\THEN} \{ j \.{\in} Task \.{:} Reserv [ i ] [ j ] \.{=} \.{-}
        1 \}}%
      \@x{\@s{8.2} \.{\ELSE} \{ ( ( ( i \.{-} 1 ) \.{+} ( nTask \.{-} 1 ) ) \.{\%}
        nTask ) \.{+} 1 \}}%
    \end{tlatex}
    \finTLA
  \end{comment}

  %%% ERRO paul
 The tuple $Reserv[i]$ stores the reservation vision of task $i$. In action
  $ElemSlot$, $Reserv[i][j]$ is set to $-1$ if no reservation is sent by $i$ for
  slot $j$, otherwise its value is set to $i$.  Here, the definition of $Reserv'$
  makes use of the exception clause to state that $Reserv$ is only updated regarding
  entry $i$, which takes the value of $resSet$ provided by the function
  $reservation$.  In an exception clause, the $@$ symbol stands for the original
  value of the variable, which here is $Reserv[i][j]$. The symbol $\mapsto$ is used
  to assign values to the entries of a record. Here, all entries $j \in Task$ of
  $Reserv'[i]$ are defined.

  % -------------------------------- Action -------------------------------
  The sending of an elementary message by task $i$ during \ES $\,$ is represented by
  the action $sendHardMsg(i, resSet, pi)$, which takes the task identifier as
  arguments, the defined reservation list and the constant value $pi = \pi$ (the
  processing time needed by a task to receive a message).

  \iniTLA
  \begin{notla}
    sendHardMsg(i, resSet, pi) == HardMsg' = [j \in Task |-> IF j # i THEN Append(
    HardMsg[j], [src |-> i, res |-> resSet, procTime |-> delay] ) ELSE HardMsg[j] ]
  \end{notla}
  \begin{tlatex}
    \@x{ sendHardMsg ( i ,\, resSet ,\, pi ) \.{\defeq}\@s{4.1} HardMsg \.{'} \.{=}
      [ j \.{\in} Task \.{\mapsto}}%
    \@x{\@s{8.2} {\IF} j \.{\neq} i\@s{4.1} \.{\THEN} Append ( HardMsg [ j ] ,\,}%
    \@x{\@s{27.41} [ src \.{\mapsto} i ,\, res \.{\mapsto} resSet ,\, procTime
      \.{\mapsto} delay ] )}%
    \@x{\@s{8.2} \.{\ELSE} HardMsg [ j ] ]}%
  \end{tlatex}
  \finTLA

  \emph{HardMsg} is an $nTask$-tuple representing a buffer where sent hard messages
  are stored. These messages stay in the buffer until they are completely
  received. Hence, $HardMsg[j]$ contains the messages to be received by task $j$.
  When task $i$ sends a hard message, all entries of the $HardMsg$ variable are
  updated except the entry $i$.  $HardMsg$ has some fields: $src$, the message
  sender identifier; \emph{res}, used to implement the reservation mechanism; and
  \emph{procTime}, which is a count-down timer used to represent the time needed by
  the slowest task to process the message.

  % \newpage -------------------------------- Action ------------------------------
  \act{ReseSlot} This action describes the sending of a reservation message.

  \iniTLA
  \begin{tla}
    ReseSlot(i) == /\ ( SendRese(i) \/ NoRese(i) ) /\ BusyMAC' = delta /\ UNCHANGED
    ...
  \end{tla}
  \begin{tlatex}
    \@x{ ReseSlot ( i ) \.{\defeq}}%
    \@x{\@s{8.2} \.{\land} ( SendRese ( i ) \.{\lor} NoRese ( i ) )}%
    \@x{\@s{8.2} \.{\land} BusyMAC \.{'} \.{=} delta}%
    \@x{\@s{8.2} \.{\land} {\UNCHANGED} \.{\dots}}%
  \end{tlatex}
  \finTLA

  A task may or may not send a reservation message as specified by the actions
  $SendRese(i)$ and $NoRese(i)$, respectively.  In both cases, $BusyMAC$ is set to
  $\delta$ to represent the reservation slot time.  When some task has a reservation
  for this chip slot, $SendRese$ is true. Otherwise, $NoRese$ holds.

  \iniTLA
  \begin{tla}
    SendRese(i) == /\ BusyMAC = 0 /\ ChipTimer = delta /\ Reserv[i][ChipCount] = i
    /\ Reserv' = [ j \in Task |-> [ Reserv[j] EXCEPT ![ChipCount] =-1 ] ] /\
    sendHardMsg(i, {-1}, pi)
  \end{tla}
  \begin{tlatex}
    \@x{ SendRese ( i ) \.{\defeq}}%
    \@x{\@s{8.2} \.{\land} BusyMAC \.{=} 0\@s{4.1} \.{\land} ChipTimer \.{=} delta}%
    \@x{\@s{8.2} \.{\land} Reserv [ i ] [ ChipCount ] \.{=} i}%
    \@x{\@s{8.2} \.{\land} Reserv \.{'} \.{=} [ j \.{\in} Task \.{\mapsto}}%
    \@x{\@s{31.61} [ Reserv [ j ] {\EXCEPT} ! [ ChipCount ] \.{=} \.{-} 1 ] ]}%
    \@x{\@s{8.2} \.{\land} sendHardMsg ( i ,\, \{ \.{-} 1 \} ,\, pi )}%
  \end{tlatex}
  \vspace{0.1cm}
  \begin{tla}
    NoRese(i) == /\ BusyMAC = 0 /\ ChipTimer = delta /\ \A j \in Task :
    Reserv[j][ChipCount] # j /\ UNCHANGED << HardMsg, Reserv >>
  \end{tla}
  \begin{tlatex}
    \@x{ NoRese ( i ) \.{\defeq}}%
    \@x{\@s{8.2} \.{\land} BusyMAC \.{=} 0\@s{4.1} \.{\land} ChipTimer \.{=} delta}%
    \@x{\@s{8.2} \.{\land} \A\, j \.{\in} Task \.{:} Reserv [ j ] [ ChipCount ]
      \.{\neq} j}%
    \@x{\@s{8.2} \.{\land} {\UNCHANGED} {\langle} HardMsg ,\, Reserv {\rangle}}%
  \end{tlatex}
  \finTLA

  The two first predicates in the first line of both $SendRese$ and $NoRese$ ensure
  that \RS has begun.
  % Also, both predicates are common to the $SendRese$ and $NoRese$ actions, they
  % had to appear explicitly in both formula to allow for the verification of
  % properties of the protocol, as will be seen in section \ref{sec:verif}.  Note
  % that by the specification below the message is sent only when $ChipTimer =
  % delta$ ($=\delta$), i.e. at the beginning of \RS,
  In action $SendRese$, a task $i$ can send a message in a given slot only if it has
  reserved such slot ($Reserv[i][ChipCount] = i$).  Once used, the sender
  reservation list is updated by setting the corresponding entry to -1. Since a
  reservation message cannot be used to make other reservations, such a message
  carries a flag value as reservation list, here defined by $ResMsg$, distinguishing
  itself from an elementary message.  The $NoRese$ action only accounts for the
  consumption of the reservation slot when no task has any reservation. Therefore,
  no message is sent and the variables $HardMsg$ and $Reserv$ remain unchanged.

  % Then, the MAC state is updated accordingly and $TprTimer$ is reset.  This reset
  % operation signals both the end of the current hard window and the beginning of
  % the next \SW by enabling the virtual token rotation in the soft ring. The
  % meaning of $TprTimer$ will be explained in the next section.  Finally, i

  % -------------------------------- Action -------------------------------
  \act{HardRecv} This action describes the reception of a hard message.

  \iniTLA
  \begin{tla}
    HardRecv(i) == /\ Len(HardMsg[i]) > 0 /\ Head(HardMsg[i]).procTime = 0 /\ IF
    omissionFailure(i, ChipCount) THEN UNCHANGED << Consistency, Reserv >> ELSE
    updateReserv(i) /\ HardMsg' = [ HardMsg EXCEPT ![i] = Tail(HardMsg[i]) ] /\
    UNCHANGED ...
  \end{tla}
  \begin{tlatex}
    \@x{ HardRecv ( i ) \.{\defeq}}%
    \@x{\@s{8.2} \.{\land} Len ( HardMsg [ i ] ) \.{>} 0}%
    \@x{\@s{8.2} \.{\land} Head ( HardMsg [ i ] ) . procTime \.{=} 0}%
    \@x{\@s{8.2} \.{\land} {\IF} omissionFailure ( i ,\, ChipCount )}%
    \@x{\@s{19.31} \.{\THEN} {\UNCHANGED} {\langle} Consistency ,\, Reserv
      {\rangle}}%
    \@x{\@s{19.31} \.{\ELSE} updateReserv ( i )}%
    \@x{\@s{8.2} \.{\land} HardMsg \.{'} \.{=} [ HardMsg {\EXCEPT} ! [ i ] \.{=}
      Tail ( HardMsg [ i ] ) ]}%
    \@x{\@s{8.2} \.{\land} {\UNCHANGED} \.{\dots}}%
  \end{tlatex}
  \finTLA

%%% ERRO paul. Not exactly. But reception should not happen after processing !!!

  When there is some pending hard message in the buffer ($Len(HardMsg[i]) > 0$) and
  task $i$ has finished processing a previous message ($Head(HardMsg[i]).procTime =
  0$), then the $HardMsg[i]$ variable is updated accordingly.  Recall that
  $procTime$ is initially set to the time needed by slow nodes to process a
  message. When it reaches zero, the node is ready to process another message.

  Also not shown here, the $omissionFailure$ state function was used to verify some
  simple fault scenarios.  When it is true, a reception omission has occurred and
  the variables $Consistency$ and $Reserv$ remain unchanged.
  % The simple fault scenario shown here as an example specifies that an omission
  % failure happens at task 3 in every chip number 2.
  As $Consistency$ is a counter incremented whenever an elementary message is
  received, the reception omission of a hard message implies that $Consistency$ is
  not incremented and task $i$ turns to be inconsistent. Its reservation capacity is
  then limited as described in the $ElemSlot$ action.
  % Although the omission failure scenario used here is simple, more elaborated
  % scenarios were taken into account when checking the protocol.
%
%
  % In this section we prefer to keep this rather simple formulation.  Other fault
  % scenarios ???  -------------------------------- Action
  % -------------------------------
  Otherwise, when $omissionFailure$ is false, the action \emph{updateReserv} updates
  the reservation list upon receiving a message.

  % \newpage
  \iniTLA
  \begin{tla}
    updateReserv(i) == LET msg == Head(HardMsg[i]) IN IF msg.res = ResMsg THEN /\
    Reserv' = [ Reserv EXCEPT ![i][msg.src] = -1 ] /\ UNCHANGED << Consistency >>
    ELSE /\ Consistency' = [ Consistency EXCEPT ![i] = @ + 1 ] /\ Reserv' = [ Reserv
    EXCEPT ![i] = [j \in Task |-> IF j \in msg.res THEN msg.src ELSE @[j] ] ]
  \end{tla}
  \begin{tlatex}
    \@x{ updateReserv ( i ) \.{\defeq}}%
    \@x{\@s{8.2} \.{\LET} msg \.{\defeq} Head ( HardMsg [ i ] )}%
    \@x{\@s{8.2} \.{\IN} {\IF} msg . res \.{=} ResMsg\@s{4.1} \.{\THEN}}%
    \@x{\@s{28.32} \.{\land} Reserv \.{'} \.{=} [ Reserv {\EXCEPT} ! [ i ] [ msg
      . src ] \.{=} \.{-} 1 ]}%
    \@x{\@s{28.32} \.{\land} {\UNCHANGED} {\langle} Consistency {\rangle}}%
    \@x{\@s{20.12} \.{\ELSE}}%
    \@x{\@s{28.32} \.{\land} Consistency \.{'} \.{=} [ Consistency {\EXCEPT} ! [ i ]
      \.{=} @ \.{+} 1 ]}%
    \@x{\@s{28.32} \.{\land} Reserv \.{'} \.{=} [ Reserv {\EXCEPT} ! [ i ] \.{=} [ j
      \.{\in} Task \.{\mapsto}}%
    \@x{\@s{59.94} {\IF} j \.{\in} msg . res\@s{4.1} \.{\THEN} msg . src\@s{4.1}
      \.{\ELSE} @ [ j ] ] ]}%
  \end{tlatex}
  \finTLA

  A message received by task $i$ can either be an elementary or a reservation
  message. In the latter case ($msg.res = ResMsg$), the reservation list regarding
  the message sender is reset to -1, accounting for the use of the \RS by the sender
  ($msg.src$). Note that the $Consistency$ variable does not change since
  consistency is related to the reception of elementary messages only.  Conversely,
  when receiving an elementary message, $Consistency$ is incremented and the
  reservation list is updated according to the list carried by the received message.

  \subsection{The Soft Ring}
  \label{sec:softRing}

  In the soft ring, the token rotation is based on the observation of the past
  communication.  Whenever $BusyMAC$ times out in \SW, an interruption is issued by
  the Ethernet card. Thus, as a soft message has been transmitted by the previous
  process in the soft ring, the token is incremented.

  % Since a process that holds the token can remain silent, the other processes have
  % to keep track of the token by monitoring the previous
  % communication % as seen in section \ref{sec:MAC}.

  % $TprTimer$ a count-down timer of maximum duration $tprDelay$. The two main
  % actions, $SoftWind$ and $SoftRecv$ make use of that timer to implement the soft
  % ring procedure.

  % -------------------------------- Action -------------------------------
  \act{SoftWind} This action specifies the soft ring.
  % determines which process has the token and whether it has some message to send

  \iniTLA
  \begin{tla}
    SoftWind(i) == /\ BusyMAC = 0 /\ i = Token[i] /\ \A j \in Proc: SoftMsg[j] #
    "sent" /\ delta + delta \leq ChipTimer /\ ChipTimer \leq deltaChip /\ \/
    failure(i) \/ LET lenTX == lenMsg(i) d == ChipTimer + lenTX IN \/ /\ d \leq
    deltaChip /\ sendSoftMsg(i, lenTX) \/ /\ d > deltaChip /\ BusyMAC' = Infinity /\
    UNCHANGED << MsgList, SoftMsg, Token >> /\ UNCHANGED ...
  \end{tla}
  \begin{tlatex}
    \@x{ SoftWind ( i ) \.{\defeq}}%
    \@x{\@s{8.2} \.{\land} BusyMAC \.{=} 0\@s{4.1} \.{\land} i \.{=} Token [ i ]}%
    \@x{\@s{8.2} \.{\land} \A\, j \.{\in} Proc \.{:} SoftMsg [ j ]
      \.{\neq}\@w{sent}}%
    \@x{\@s{8.2} \.{\land} delta \.{+} delta \.{\leq} ChipTimer\@s{4.1} \.{\land}
      ChipTimer \.{\leq} deltaChip}%
    \@x{\@s{8.2} \.{\land} \.{\lor} failure ( i )}%
    \@x{\@s{17.81} \.{\lor} \.{\LET} lenTX \.{\defeq} lenMsg ( i )}%
    \@x{\@s{44.06} d \.{\defeq} ChipTimer \.{+} lenTX}%
    \@x{\@s{28.92} \.{\IN} \.{\lor} \.{\land} d \.{\leq} deltaChip}%
    \@x{\@s{48.96} \.{\land} sendSoftMsg ( i ,\, lenTX )}%
    \@x{\@s{39.85} \.{\lor} \.{\land} d \.{>} deltaChip}%
    \@x{\@s{48.96} \.{\land} BusyMAC \.{'} \.{=} Infinity}%
    \@x{\@s{48.96} \.{\land} {\UNCHANGED} {\langle} MsgList ,\, SoftMsg ,\, Token
      {\rangle}}%
    \@x{\@s{8.2} \.{\land} {\UNCHANGED} \.{\dots}}%
  \end{tlatex}
  \finTLA

  The $SoftMsg$ variable is a record that stores the status of a process in respect
  to the observed communication. For process $j$, $SoftMsg[i]$ can assume three
  values: ``sent'' if a message is awaiting to be received; ``received'' when a
  message is received and ``undef'' when \SW is finished. The $SoftWind$ action gets
  enabled when the five predicates specified in the beginning of the formula hold.
  Following the order they appear: (i) $BusyMAC$ has elapsed; (ii) process $i$ holds
  the token; (iii) there is no pending soft message; (iv) a \SW has begun and (v) it
  has not finished yet.

  % The constant $safeDelay$ is just greater than the time value needed for
  % transmitting a message with minimum size. Ensuring a time interval of
  % $safeDelay$ in a chip is used to provide communication fairness in the soft
  % ring, carried out by the $sendMsgOfProc$ action.  Whenever enabled, the
  % \emph{SoftWind} action executes the $sendMsgOfProc(i)$ action to send a message.
  % and deactivates the $TprTimer$ by setting it to infinity as the token stops
  % circulating while the MAC is busy.  Using the same style for the title let the
  % reader think that this action is similar to the two other actions SoftWind and
  % SoftRecv.  Although it is not the case, I am not sure it is a problem or not !
  %% -------------------------------- Action -------------------------------
  % \act{sendMsgOfProc} A message to be sent can be an application message or a STOP
  % message. This latter type has the minimum packet size and has a special meaning
  % as will be clearer shortly.

  Whenever enabled, the \emph{SoftWind} action defines the $lenTX$ local
  constant. If process $i$ has a message to send, $lenTX$ is set to the length of
  that message. Otherwise, $lenTX$ is set to the minimum size packet. Thereafter,
  the local variable $d$ is defined to be the current $ChipTimer$ plus $lenTX$. Two
  scenarios may then occur depending on whether there is enough time to transmit
  such a message in the current chip. If it is the case, %enough time,
  three actions take place: $BusyMAC$ is set accordingly; the message is sent by the
  action $sendSoftMsg$ (omitted here) which updates $BusyMAC$, increments $Token$
  and set $SoftMsg[i]$ to the ``sent'' value; and the sent message is removed from
  the message list of process $i$.  Otherwise, when the message transmission time is
  larger than the available time in the chip, no message is sent and the token
  remains with process $i$ until the next \SW. This is achieved by deactivating
  $BusyMAC$ by setting it to infinity.

  The $failure$ state function was used to specify the crash failure of some
  process. This allowed us to verify that no deadlock occurs in such a case. In this
  case, as will be see in the following section, the process token is incremented
  each time a whole \SW remains empty.


%
  % The STOP message signals to all other processes that process $i$ has a pending
  % message that could not be sent in the finishing chip. Thus, the token must
  % remain with process $i$ in the next chip. Doing so prevents starvation scenarios
  % where a process would be recurrently unable to transmit its message.  In order
  % to ensure that process $i$ has enough time to transmit the STOP message, the
  % $safeDelay$ constant is used.

  % -------------------------------- Action -------------------------------
  % \act{SoftRecv} This action describes the reception of the two types of soft
  % message.

  % \iniTLA
  % \begin{tla}
  %   SoftRecv(j) == /\ BusyMAC = 0 /\ SoftMsg[j] = "sent" /\ SoftMsg' = [ SoftMsg
  %   EXCEPT ![j] = "received" ] /\ Token' = [ Token EXCEPT ![j] = (@ % nProc) + 1 ]
  %   /\ UNCHANGED...
  % \end{tla}
  % \begin{tlatex}
  %   \@x{ SoftRecv ( j ) \.{\defeq}}%
  %   \@x{\@s{8.2} \.{\land} BusyMAC \.{=} 0\@s{4.1} \.{\land} SoftMsg [ j ]
  %     \.{=}\@w{sent}}%
  %   \@x{\@s{8.2} \.{\land} SoftMsg \.{'} \.{=} [ SoftMsg {\EXCEPT} ! [ j ]
  %     \.{=}\@w{received} ]}%
  %   \@x{\@s{8.2} \.{\land} Token \.{'} \.{=} [ Token {\EXCEPT} ! [ j ] \.{=} ( @
  %     \.{\%} nProc ) \.{+} 1 ]}%
  %   \@x{\@s{8.2} \.{\land} {\UNCHANGED} \.{\dots}}%
  % \end{tlatex}
  % \finTLA

  The $SoftRecv$ action, similar to the $HardRecv$, is omitted here.  Upon reception
  of a soft message, process $i$ increments $Token[i]$ and set the value of
  $SoftMsg[i]$ to ``received''.

  % Otherwise, it is a STOP message and so the token remain unchanged and $TprTimer$
  % is set to the remaining time interval to complete the chip in order to allow for
  % the passage of time.
%%%
  % The \doris{} protocol deals with omission failures using two specific features:
  % a reset mechanism of the token and a flag which indicates whether a process has
  % correctly processed all the messages it has detected on the MAC since the last
  % token reset. The reset of the token is done each time a process receives
  % correctly a message by setting the token value to the message sender id
  % piggy-backed in the message. When no soft message is transmitted in a chip, all
  % processes reset the token to 1. This functionalities of \doris{} were specified
  % and checked. They can be found in the complete specification \cite{DoRiS07},
  % but, for the sake of space, they were not included in the present description.

  \subsection{Time representation} %%%
  \label{sec:TickAction}

  The \emph{Tick} action deals with the protocol progress and is composed of the
  \emph{NextTick} and the \emph{NextChip} actions.

  % -------------------------------- Action -------------------------------
  \act{NextTick} This action regulates the passage of time.

  \iniTLA
  \begin{tla}
    NextTick == /\ LET d == minTimerValue IN d > 0 /\ updateTimers(d) /\ UNCHANGED
    ...
  \end{tla}
  \begin{tlatex}
    \@x{ NextTick \.{\defeq}\@s{4.1} \.{\land} \.{\LET} d \.{\defeq} minTimerValue}%
    \@x{\@s{78.69} \.{\IN}\@s{4.1} d \.{>} 0\@s{4.1} \.{\land}\@s{4.1} updateTimers
      ( d )}%
    \@x{\@s{67.58} \.{\land} {\UNCHANGED} \.{\dots}}%
  \end{tlatex}
  \finTLA

  As mentioned in section \ref{sec:SpecConsiderations}, time is specified as an
  integer entity.
%
  % A simple approach to advancing time would be incrementing it so that time units
  % could be represented, as nanoseconds say. However, this would be very
  % inefficient. Since between one time unit and another there may be no protocol
  % operations, it is likely that such naive specification of time generate too many
  % states during model-checking.  The approach used in our specification avoids
  % this problem by appropriately setting the increment of time, which is carried
  % out by the $NextTick$ action.
%
  However, in order to avoid the generation of too many states during
  model-checking, the time increment is chosen to be the minimum value (provided by
  the state function $minTimerValue$) of the timers $BusyMAC$, $ChipTimer$ and the
  piggy-backed timers of $HardMsg$.  The flow of time is represented by decrementing
  the value of all timers, operation that is carried out by the $updateTimer$
  action.  Both $minTimerValue$ and $updateTimer$ are simple formulas omitted here.
  Since all the other actions are timed by at least one of these timers, this
  strategy is safe and efficient.  Indeed, some model-checking experiments we
  carried out showed that this strategy can speed up the model-checking process by a
  factor of the order of 10. This is because the time passes by quanta, stepping
  from an enabled action to the next, without exploring unnecessary states.

  % -------------------------------- Action -------------------------------
  \act{NextChip} This action is responsible for setting the values of several
  variables in order to start a new chip.

  \iniTLA
  \begin{tla}
    NextChip == /\ \A j \in Proc: SoftMsg[j] # "sent" /\ ChipTimer = deltaChip /\ IF
    \A j \in Proc: SoftMsg[j] = "undef" THEN /\ Token' = [ j \in Proc |-> Token[j] +
    1 ] /\ UNCHANGED SoftMsg ELSE /\ SoftMsg' = [ j \in Proc |-> "undef"] /\
    UNCHANGED Token /\ ChipTimer' = 0 /\ ChipCount' = (ChipCount % nTask) + 1
    /\ BusyMAC' = 0 /\ IF ChipCount' = 1 THEN defineSoft(MsgList') ELSE UNCHANGED
    MsgList /\ UNCHANGED ...
  \end{tla}
  \begin{tlatex}
    \@x{ NextChip \.{\defeq}}%
    \@x{\@s{8.2} \.{\land} \A\, j \.{\in} Proc \.{:} SoftMsg [ j ]
      \.{\neq}\@w{sent}}%
    \@x{\@s{8.2} \.{\land} ChipTimer \.{=} deltaChip}%
    \@x{\@s{8.2} \.{\land} {\IF} \A\, j \.{\in} Proc \.{:} SoftMsg [ j ]
      \.{=}\@w{undef}}%
    \@x{\@s{19.31} \.{\THEN} \.{\land} Token \.{'} \.{=} [ j \.{\in} Proc
      \.{\mapsto} Token [ j ] \.{+} 1 ]}%
    \@x{\@s{41.8} \.{\land} {\UNCHANGED} SoftMsg}%
    \@x{\@s{19.31} \.{\ELSE} \.{\land} SoftMsg \.{'} \.{=} [ j \.{\in} Proc
      \.{\mapsto}\@w{undef} ]}%
    \@x{\@s{41.8} \.{\land} {\UNCHANGED} Token}%
    \@x{\@s{8.2} \.{\land} ChipTimer \.{'} \.{=} 0}%
    \@x{\@s{8.2} \.{\land} ChipCount \.{'}\@s{0.76} \.{=} ( ChipCount \.{\%} nTask )
      \.{+} 1}%
    \@x{\@s{8.2} \.{\land} BusyMAC \.{'} \.{=} 0}%
    \@x{\@s{8.2} \.{\land} {\IF} ChipCount \.{'} \.{=} 1\@s{4.1} \.{\THEN}
      defineSoft ( MsgList \.{'} )}%
    \@x{\@s{91.72} \.{\ELSE} {\UNCHANGED} MsgList}%
    \@x{\@s{8.2} \.{\land} {\UNCHANGED} \.{\dots}}%
  \end{tlatex}
  \finTLA

  Whenever a chip finishes, $ChipTimer$, $ChipCount$ and $BusyMAC$ have to be
  updated to indicate the start of a new chip. This is carried out by this action,
  which is enabled when there is no pending soft message and $chipTimer$ has timed
  out.

  To implement the emission failure tolerance, processes check whether some soft
  message has been transmitted during the previous \SW. In such case, $SoftMsg[j]$
  equals ``received'' for some $j$, $token$ remains unchanged and $SoftMsg$ is set
  to ``undef'' for all processes. Otherwise, $SoftMsg[j]$ equals ``undef'' for all
  processes, and $token$ has to be incremented to avoid deadlock.

  % \newpage
  Note that the message list is defined periodically (when $ChipCount' = 1$).  This
  is done in order to avoid state explosion caused by asynchronously generated
  message list. Since it is just a simple assignment, the $defineSoft(MsgList')$
  action is omitted here.

  % -------------------------------------------------------------------------
  % \begin{comment}
  \section{Verification} %Model checking}
  \label{sec:verif}

  % In order to check a TLA+ specification, the TLC model-checker uses a
  % configuration file, which defines the values of constants and of . This allows
  % the model-checker TLC to verify a finite model of the specification.


  In order to check some finite models of the system with the TLC
  model-checker~\cite{Yu99}, one uses a configuration file to assign a value to each
  constant defined by the TLA+ specification.  In most of the TLC runs for the
  \doris{} specification, the execution time for some finite models was found to be
  reasonable, although no comparison was made with other tools. For example, for 8
  tasks and 7 processes, TLC ran in less then 15 minutes on a 2 Ghz Intel Core Duo
  processor using a java virtual machine with a 512M heap size.

  After the detection of syntax errors, TLC checks possible deadlocks.  Thereafter,
  TLC checks that the specification implies the temporal formulas that are listed in
  the configuration file.  Whenever it detects a property violation, TLC produces a
  behavior that is a counter-example for that property, generating a sequence of
  states with the values of all variables for each state. The analysis of this trace
  is a valuable tool to identify the cause of the error and to correct the protocol
  (or its specification). What follows is the description of some formula used to
  verify some relevant properties of \doris{}.

  \act{TypeInvariance} The type invariance of variables is the simplest property to
  be verified in TLA+.  Such a property ensures that a variable remains in its type
  domain during a behavior that satisfies the specification. Specifying the type
  invariance of each variable ensures the detection of obvious errors.  Here is an
  example that asserts the type invariance of variable $HardMsg$:

  \iniTLA
  \begin{tla}
    TypeInvariance == HardMsg \in [ Task -> {<< >>} \cup Seq( [ src : Task, res :
    SUBSET ResSet, procTime : 0..pi ] ) ]
  \end{tla}
  \begin{tlatex}
    \@x{ TypeInvariance \.{\defeq}\@s{4.1} HardMsg \.{\in} [ Task \.{\rightarrow} \{
      {\langle} {\rangle} \} \.{\cup}}%
    \@x{\@s{24.59} Seq ( [ src \.{:} Task ,\, res \.{:} {\SUBSET} ResSet ,\,
      procTime \.{:} 0 \.{\dotdot} pi ] ) ]}%
  \end{tlatex}
  \finTLA

  It states that each element of the $nTask$-tuple \emph{HardMsg} is empty or
  contains a sequence of records formatted as $[ src, res, procTimer ]$. The TLA+
  symbol ``:'' in $src : Task$ means that the field $src$ can take any value in the
  set $Task$. The reservation list, denoted by the field $res$, is a subset of the
  possible reservations $ResSet$, which is defined as $1..nTask-1 \cup
  NoRes$. Finally, $procTime$ is a delay ranging from $0$ to $pi$.  Similar
  formulas, although not shown here for the sake of space, were checked for each
  variable.

  \act{CollisionAvoidance} This more elaborated temporal formula asserts that at
  most one task can send its message in a given slot.

  \iniTLA
  \begin{tla}
    CollisionAvoidance == \A i, j \in Task \cup Proc: [] ( ( Slot(i) /\ Slot(j) ) =>
    ( i = j ) )
  \end{tla}
  \begin{tlatex}
    \@x{ CollisionAvoidance \.{\defeq}}%
    \@x{\@s{8.2} \A\, i ,\, j \.{\in} Task \.{\cup} Proc \.{:} {\Box} ( ( Slot ( i )
      \.{\land} Slot ( j ) ) \.{\implies} ( i \.{=} j ) )}%
  \end{tlatex}
  \finTLA

  The above formula ensures no collision by asserting that two distinct sending
  operations cannot be enabled at the same time.  The $Slot$ operator is a predicate
  that is true whenever one of the sending operations is true for a given task or
  process $i$.

  \iniTLA
  \begin{tla}
    Slot(i) == \/ IF i \in Task THEN \/ ENABLED ElemSlot(i) \/ ENABLED SendRese(i)
    ELSE FALSE \/ IF i \in Proc THEN ENABLED SoftWind(i) ELSE FALSE
  \end{tla}
  \begin{tlatex}
    \@x{ Slot ( i ) \.{\defeq} \.{\lor} {\IF} i \.{\in} Task\@s{4.1} \.{\THEN}
      \.{\lor} {\ENABLED} ElemSlot ( i )}%
    \@x{\@s{119.60} \.{\lor} {\ENABLED} SendRese ( i )}%
    \@x{\@s{98.80} \.{\ELSE} {\FALSE}}%
    \@x{\@s{41.81} \.{\lor} {\IF} i \.{\in} Proc\@s{5.11} \.{\THEN} {\ENABLED}
      SoftWind ( i )}%
    \@x{\@s{98.80} \.{\ELSE} {\FALSE}}%
  \end{tlatex}
  \finTLA

  % \newpage
  It is worth mentioning that in order to produce behavioral traces for each checked
  property, we systematically ran the TLC model-checker twice per property.  First,
  checking the formula and then its contraposition. Doing so, we were able to verify
  that the TLC model-checker always succeed to detect the false formula, producing
  the associated counter-example trace. Analyzing such traces was very handful since
  we could achieve confidence that the temporal formula was expressing the property
  we wanted to check.

  $NoCollisionAvoidance$ is the contraposition of predicate $CollisionAvoidance$ and
  exemplifies such a useful approach.

  % \newpage
  \iniTLA
  \begin{tla}
    NoCollisionAvoidance == \E i, j \in Task \cup Proc: <> ( ( i # j ) /\ Slot(i) /\
    Slot(j) )
  \end{tla}
  \begin{tlatex}
    \@x{ NoCollisionAvoidance \.{\defeq}}%
    \@x{\@s{8.2} \E\, i ,\, j \.{\in} Task \.{\cup} Proc \.{:} {\Diamond} ( ( i
      \.{\neq} j ) \.{\land} Slot ( i ) \.{\land} Slot ( j ) )}%
  \end{tlatex}
  \finTLA


  \act{HardRingCorrectnesss} In the following formula, we were able to check some
  properties of the protocol regarding the hard ring.

  \iniTLA
  \begin{tla}
    HardRingCorrectness == /\ \A i \in Task : /\ [] ( Len( HardMsg[i] ) \leq bufCap
    ) /\ []<> ENABLED ElemSlot(i) /\ [] ( ENABLED NextChip => History.elemSlot =
    ChipCount )
  \end{tla}
  \begin{tlatex}
    \@x{ HardRingCorrectness \.{\defeq}}%
    \@x{\@s{8.2} \.{\land} \A\, i \.{\in} Task \.{:} \.{\land} {\Box} ( Len (
      HardMsg [ i ] ) \.{\leq} bufCap )}%
    \@x{\@s{63.55} \.{\land} {\Box} {\Diamond} {\ENABLED} ElemSlot ( i )}%
    \@x{\@s{8.2} \.{\land} {\Box} ( {\ENABLED} NextChip \.{\implies} History .
      elemSlot \.{=} ChipCount )}%
  \end{tlatex}
  \finTLA

  First, it is checked that no buffer overflow occurs, where $bufCap$ is a defined
  constant to represent the maximum buffer size.  In the second line, it is asserted
  that whenever $NextChip$ takes place, the action $ElemSlot$ has been executed
  $nTask$ times.  It is worth noticing that it was necessary to define an observer
  called $History$, which has a counter, named $elemSlot$, as a field.  This counter
  is reset at the beginning of every cycle and is incremented when $ElemSlot$ action
  is true.  Thus, at the end of each cycle, $History.elemSlot$ must be equal to
  $nTask$ if all tasks have sent their mandatory elementary messages. In other
  words, the action $ElemSlot$ is regularly enabled.  The fact that this action is
  timely enabled is ensured by the guard $i = ChipCount$, present in the action
  formula (see section \ref{sec:hardRing}).

  Recall that we specified omission failures in the reception action (see $HardRecv$
  formula).  This implies that sending omission and crash failures were modeled. For
  instance, sending omission failure can be seen as reception failures at all nodes
  and crash failures are permanent sending omission failures.  Therefore, it was not
  necessary to check specific scenarios of message sending omission nor task crash
  failures.

  % : whenever the value of the constant \DDC is less than $2 \pi$, the processing
  % of the two eventual hard messages (elementary and reservation) sent in a chip
  % can not be completed during the same chip, and hard message are enqueued from
  % one chip to another, eventually causing buffer overflow.  The second formula
  % simply asserts that the token always circulates.
 

  \act{ReservationSafety} This property asserts that when task $j$ has a reservation
  for some \RS, all other tasks are aware either of this reservation or that they
  have not reserved such a slot.

  \iniTLA
  \begin{tla}
    ReservationSafety == [] ( \A chip \in Task: \E j \in Task: Reserv[j][chip] # -1
    /\ ENABLED ReseSlot(j) => \A i \in Task\{j}: Reserv[i][chip] \in {
    Reserv[j][chip], -1 } )
\end{tla}
\begin{tlatex}
  \@x{ ReservationSafety \.{\defeq} {\Box} ( \A\, chip \.{\in} Task \.{:}}%
  \@x{\@s{8.2} \E\, j \.{\in} Task \.{:} Reserv [ j ] [ chip ] \.{\neq} \.{-} 1
    \.{\land} {\ENABLED} ReseSlot ( j ) \.{\Rightarrow}}%
  \@x{\@s{20.} \A\, i\@s{0.42} \.{\in} Task \.{\,\backslash\,} \{ j \} \.{:} Reserv
    [ i ] [ chip ] \.{\in} \{ Reserv [ j ] [ chip ] ,\, \.{-} 1 \} )}%
\end{tlatex}
\finTLA

This formula implies that two task cannot own a reservation for the same slot. Along
with the enabling predicate $Reser[i][ChipCount] = i$ of the $ReseSlot$ action, the
specification also implies that task $i$ can only send a reservation message in a
\RS that it has previously reserved.

\act{SoftRingFairness} This property asserts that all processes will eventually
receive the token (first line), and that its list of message will eventually be
exhausted.


\iniTLA
\begin{tla}
  SoftRingFairness == \A i \in Proc : []<> /\ i = Token[i] /\ Len(MsgList[i]) = 0
\end{tla}
\begin{tlatex}
  \@x{ SoftRingFairness \.{\defeq}\@s{8.2} \A\, i \.{\in} Proc \.{:} {\Box}
    {\Diamond} \.{\land} i \.{=} Token [ i ]}%
  \@x{\@s{146.53} \.{\land} Len ( MsgList [ i ] ) \.{=} 0}%
\end{tlatex}
\finTLA

Should the list of messages of all processes in a cycle exceed the available
bandwidth capacity for the soft communication, TLC indicates out the violation of
the second line of the formula, as expected.

% \act{Omission}

% \iniTLA
% \begin{tla}
%   Omission == \E i \in Task : <> ( ENABLED ElemSlot(i) /\ Consistency[i] < nTask )
% \end{tla}
% \begin{tlatex}
%   \@x{ Omission \.{\defeq} \E\, i \.{\in} Task \.{:}}%
%   \@x{\@s{12.29} {\Diamond} ( {\ENABLED} ElemSlot ( i )\@s{4.1} \.{\land}
%     Consistency [ i ] \.{<} nTask )}%
% \end{tlatex}
% \finTLA

% \act{Failure}

% \iniTLA
% \begin{tla}
%   Failure == \E i \in Proc : []<> ( ENABLED failure(i) )
% \end{tla}
% \begin{tlatex}
%   \@x{ Failure \.{\defeq} \E\, i \.{\in} Proc \.{:} {\Box} {\Diamond} ( {\ENABLED}
%     failure ( i ) )}%
% \end{tlatex}
% \finTLA


% This is stated by the formula $\Box ( ChipCount = nTask \land \ENABLED NextChip
% \implies History = nTask )$.

As can be seen, we were able to verify relevant properties of the \doris
protocol. In summary, model-checking has ensured that: (i) the protocol provides
communication isolation, avoiding collisions; (ii) each task always sends an
elementary message per cycle and no task's buffer overflow occurs; (iii) the
reservation mechanism is safe and correct; (iv) soft communication fairness holds;
and (v) the desired fault tolerance is guaranteed.
% Other verification can be carried out such as the existence of fault scenarios or
% other ,

% We invite the interested reader to refer to \cite{DoRiS07} for the complete set of
% these temporal formulas.

% -------------------------------------------------------------------------
\section{Conclusions}
\label{sec:conclusion}

A TLA+ specification of \doris{}, an Ethernet based protocol, have been shown in
this paper. \doris{} is designed for modern real-time systems, which require
predictability, fault tolerance and flexibility.  The specification and its
properties were checked for several different scenarios.  For this purpose, the TLA+
language was found to have a powerful expressiveness at a satisfactory level of
abstraction. Moreover, as we have specified and checked complex temporal properties
using TLA+, we believe that it is appropriate for helping one in designing real-time
communication protocols.

From a software engineering perspective, the approach used to define \doris{} has
shown how one can benefit from formal methods.  Indeed, using the TLA+ language and
its tools, we have carried out an interactive design methodology, where
specification and model-checking were performed during the definition of the
protocol functions.  We are currently starting the implementation of
\doris{}. Although still in an early stage, implementing the protocol is being
greatly favored by the specification presented here, indicating the strength of the
adopted methodology.

% The description and a TLA+ specification of \doris{}, an Ethernet based protocol,
% have been presented. The TLA+ language was found to have a powerful expressiveness
% at a satisfactory level of abstraction. From a software engineering perspective,
% this work has shown how one can benefit from formal methods to design
% communication protocols. % We are currently implementing
% Although still in an early stage, the implementation of \doris{} is being greatly
% favored by its TLA+ specification, indicating the strength of the adopted
% methodology.
