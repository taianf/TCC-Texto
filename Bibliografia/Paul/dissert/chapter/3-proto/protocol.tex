\chapter{DORIS: Especificação e verificação}
\label{cap:doris}

\section{Introdução}
\label{sec:intro}

Neste capítulo, um novo protocolo de comunicação de tempo real, baseado em Ethernet
compartilhada, é apresentado através das sua especificação formal na linguagem TLA+
\cite{Lamport02a}.

O protocolo \doris, cujo significado em inglês é \emph{An Ethernet
  \underline{Do}uble \underline{Ri}ng \underline{S}ervice for Real -Time Systems},
teve como fontes de inspiração principais os protocolos VTPE \cite{Carreiro03} e
TEMPRA \cite{Pritty95}, apresentados no capítulo \ref{cap:motivacao}.  \doriss foi
concebido para dar suporte a sistemas híbridos nos quais dispositivos industriais
como sensores, atuadores e controladores compartilham a mesma rede de comunicação
com aplicações ou serviços não-críticos. Assim como foi mencionada anteriormente, a
velocidade de processamento e as características da comunicação das aplicações de
tempo real críticas e das aplicações com requisitos temporais não-críticos podem ser
bastante diferentes. De fato, a maioria dos dispositivos de prateleira disponíveis
tem capacidade de processamento pequena em relação à largura da banda Ethernet.  Por
exemplo, vimos na seção \ref{sec:sisHibrid}, que Carreiro et al \cite{Carreiro03}
utilizaram micro-controladores que podem gastar até $111 \, \mu s$ para processar
uma mensagem de 64B. Como o tempo de transmissão de tal mensagem numa rede 100Mbps é
$\delta = 5,76 \, \mu s$, isso permite somente cerca de $5,2\%$ de utilização do
barramento para a comunicação com requisitos temporais críticos. Por outro lado,
aplicações não-críticas têm geralmente capacidade de processamento maiores e podem,
portanto, utilizar taxas de transmissão mais elevadas.  Considerando estas
características dos sistemas híbridos, este trabalho propõe \doris, um protocolo
novo que combina as abordagens de bastão circulante e \emph{Time Division Multiple
  Access} (TDMA) para: \newpage

\begin{enumerate}
\item prover previsibilidade num segmento Ethernet compartilhada;
\item oferecer garantias temporais às tarefas de tempo real;
\item disponibilizar a largura de banda não aproveitada pela comunicação
crítica para a comunicação não-crítica. 
\end{enumerate}

A seção \ref{sec:escolTLA} apresentará brevemente as motivações para a escolha da
linguagem formal utilizada para especificar \doris. Em seguida, após introduzir
alguns termos e elementos concernentes o modelo do sistema especificado,
a seção \ref{sec:dorisProt} apresentará uma visão geral do protocolo \doris. As
hipóteses de modelagem e uma breve introdução da linguagem formal escolhida darão o
início da seção \ref{sec:dorisSpec}, que prosseguirá com a descrição detalhada da
especificação formal de \doris. Finalmente, a seção \ref{sec:verifAuto} será
dedicada à discussão da verificação automática da especificação e das suas
propriedades temporais. A seção \ref{sec:dorisConc} concluíra este capítulo.


\section{A escolha da linguagem formal}
\label{sec:escolTLA}

A concepção e implementação de um novo protocolo tal como \doriss envolve decisões
importantes. Neste processo, a especificação formal do protocolo e sua verificação
automática permitem adquirir confiança no projeto elaborado. De fato, especificar
formalmente um sistema e verificar a sua correção de maneira automática aumenta
significativamente a compreensão do seu comportamento e pode ajudar a detectar erros
ou defeitos de concepção numa fase inicial do desenvolvimento do \ing{software}
\cite{Auslander96, Clarke99}. Tal abordagem já foi utilizada em vários domínios de
aplicação \cite{Barboza06, Johnson04, Hanssen06}.

Na últimas três décadas, várias linguagens formais e ferramentas de verificação
foram desenvolvidas baseadas em lógica temporal \cite{Pnueli79, Larsen97,
  Henzinger91}. Por exemplo, Esterel \cite{Berry92} é uma linguagem síncrona
bastante adequada para especificar componentes de \ing{hardware} e para expressar
propriedades complexas de circuitos ou sistemas síncronos mais amplos.  A linguagem
de Especificação e Descrição (SDL) e o padrão Estelle foram recentemente estendidos
para permitir a especificação de STR \cite{Fischer96, Sinnott04}. No entanto, SDL e
Estelle são dedicados a descrição formal e a geração automática de código na fase
inicial do projeto e ambas não permitem a verificação automática de modelos. Várias
outras ferramentas são baseadas em autômatos temporais tal como Kronos \cite{Daws96}
e HyTech \cite{Alur96}.  Promela, por exemplo, é dotada de uma extensão de tempo real que
fornece uma semântica para a especificação e a verificação de propriedades temporais
\cite{Tripakis96}.  Uma outra ferramenta bastante utilizada para especificar e
verificar sistemas de tempo real é UPPALL \cite{Larsen97}. Por exemplo, num trabalho
recente \cite{Hanssen06}, o protocolo RTnet, de tempo real baseado em Ethernet, foi
especificado e suas propriedades temporais foram verificadas com UPPAAL.

Uma outra alternativa possível para especificar Sistemas de Tempo Real
\cite{Abadi94, Lamport05} é a linguagem de especificação formal TLA+ (\ing{Temporal
  Logic of Actions}) \cite{Lamport02a}, junto com o seu verificador de modelo
associado TLC (\ing{Temporal Logic Checker}) \cite{Yu99}.  Baseada na teoria dos
conjuntos de Zermelo-Fraenkel e na lógica temporal ~\cite{Pnueli79}, a linguagem
TLA+ foi especialmente concebida para expressar propriedades temporais de sistemas
concorrentes e distribuídos ~\cite{Johnson04}.  A escolha de TLA+ para especificar e
verificar \doriss se deu pelas razões principais seguintes:

\begin{enumerate}
\item TLA+ tem uma estrutura modular que permite um processo de escrita por incrementos
  sucessivos, de acordo com o grau de abstração ou de detalhe desejado;
\item Uma especificação em TLA+ é bastante parecida com código de programas, e,
  portanto, oferece uma base sólida para a implementação de \doris;
\item O verificador de modelo TLC permite verificar automaticamente a especificação, 
  assim como as propriedades temporais a ela associadas;
\item Tanto os documentos de definição da linguagem TLA+ como a ferramenta TLC e
  vários exemplos são disponíveis livremente na Internet \cite{TLA}.
\end{enumerate}

\section{\doris: o protocolo}
\label{sec:dorisProt}

Localizado nas camadas \ing{LLC} e MAC do modelo OSI, entre as camadas de rede e
física, o protocolo \doriss atua como um filtro lógico, evitando as colisões
inerentes à camada de controle de acesso ao meio do protocolo CSMA/CD
\cite{CSMA/CD01}.  \doriss é concebido para dar suporte a sistemas híbridos, nos
quais sensores industriais, atuadores e controladores compartilham a rede de
comunicação com as demais aplicações com requisitos temporais
não-críticos. Dispositivos industriais (micro-controladores, sensores, etc.) são
chamados de ``estações lentas'', pois a velocidade de processamento de tais
dispositivo é relativamente baixa em comparação com a dos micro-computadores,
chamados de ``estações rápidas''. Nas seções seguintes, o protocolo é detalhado.

\subsection{Sistema, modelo e terminologia}
\label{sec:dorisModel}

O conjunto de estações (lentas e rápidas) interligadas num barramento Ethernet
compartilhada constitui um segmento \doris. Embora vários segmentos \doriss possam
ser inter-conec\-tados por comutadores ou roteadores, a especificação e verificação de
\doriss se restringe a um segmento isolado. Em tal segmento, cada estação executa um
servidor \doris, que é responsável pela execução das suas funcionalidades. Uma
estação rápida pode hospedar tanto tarefas críticas como processos com requisitos
temporais não-críticos. Para fins de clareza das notações, as primeiras serão
simplesmente chamados de tarefas e os segundos, de processos.  Os dois conjuntos, de
tarefas e de processos, denotados respectivamente \txtla{TaskSet} e \txtla{ProcSet},
definem os dois anéis lógicos de um segmento \doris, nos quais um único bastão
circula.

Mensagens enviadas pelas estações lentas são curtas, usualmente periódicas, e têm
requisitos de tempo real críticos.  Assume-se que tais mensagem, chamadas de
``mensagens críticas'', têm um tamanho mínimo de 64 bytes e que, conseqüentemente,
são transmitidas no barramento no tempo de transmissão $\delta$. Denota-se $\pi$ o
tempo de processamento, no pior caso, da estação mais lenta do segmento \doris.
Assume-se que $\delta \ll \pi$ e que a recepção e o processamento das mensagens são
duas operações independentes que podem ser realizadas simultaneamente.  A primeira
suposição reflete a existência de estações lentas no segmento, enquanto a segunda
corresponde à realidade dos dispositivos de hardware modernos dotadas de memórias
locais e de capacidade de DMA (\ing{Direct Memory Access}). A segunda suposição
implica, notadamente, que duas ou mais mensagens críticas podem ser enviadas em
seguida. Observa-se que se houver somente estações lentas presentes no segmento
\doris, a taxa máxima de utilização do barramento é de $\frac{\delta}{\pi +
  \delta}$.  No entanto, se houver também estações rápidas, a fração da banda não
utilizada pode ser aproveitada pelos processos. É desta constatação que surgiu a
proposta de \doris.

Assim como os protocolos VTPE e TEMPRA (ver seção \ref{sec:TempraVTPE}), \doriss
utiliza o modelo de comunicação \ing{publish-subscribe} \cite{Dolejs04}, de acordo
com o qual, quando uma aplicação quer enviar uma mensagem, ela utiliza o endereço
Ethernet de comunicação um-para-todos padrão (\cod{FF:FF:FF:FF:FF:FF}).
% Porém, várias aplicações podem ser hospedadas numa mesma estação. Para identificar
% as mensagens de cada aplicação, usa-se o \ing{type field} do quadro Ethernet
% \ref{fig:ethernetFrame}.
Quando um servidor \doriss recebe uma mensagem, ele determina, de acordo com a
identidade do seu emissor, se há alguma aplicação interessada naquela mensagem. Caso
positivo, ele entrega a mensagem. Senão, ele a descarta.  A princípio, as tarefas
não precisam completar o processamento de todas as mensagens críticas. No entanto,
para simplificar o modelo, assume-se aqui que todas as mensagens críticas são
inteiramente processadas por todas as tarefas. Distinguem-se portanto as operações de
recepção e de processamento de uma mensagem.

Em relação ao modelo temporal, assume-se um sistema distribuído síncrono. Isto significa
que as operações efetuadas pelas estações podem ser sincronizadas umas com as outras. 
Esta suposição se baseia no esquema de divisão temporal de \doris, que, como será visto, 
tem pontos de sincronização regulares e previsíveis, que ocorrem dentro de uma janela
de tempo curta comparada com o desvio dos relógios locais. Isto implica que
os relógios locais das estações são sincronizados.

Por fim, assume-se que as estações podem falhar por \ing{crash-recovery}, ou seja,
parar qualquer tipo de atividade \cite{Schlichting83}, e voltar a funcionar
normalmente depois de um tempo arbitrário. Mensagens enviadas podem eventualmente
ser perdidas, porém, estações rápidas devem imperativamente perceber a interrupção
associada à recepção de uma mensagem, mesmo que o conteúdo da mensagem seja
perdido. Como será visto, este requisito é necessário para controlar a circulação do
bastão entre os processos.

\subsection{O esquema de controle de acesso ao meio}
\label{sec:dorisMAC}

A comunicação num barramento \doriss é temporalmente dividida em uma alternância de
fases (\ing{rounds}) de comunicação (\emph{C-Rd}) e fases de configuração dos
membros (\emph{M-Rd}), assim como ilustrado na figura \ref{fig:dorisStruct}. Durante
a fase de configuração, o algoritmo de controle da composição do segmento \doriss é
responsável por estabelecer uma visão única da composição do grupo de participantes
do segmento \doris. Esta visão é compartilhada por todos os membros deste
segmento. O problema do estabelecimento de tal visão, também conhecido como o
problema de composição de grupos, são assuntos de vários trabalhos
\cite{Cristian88, Chandra96, Lamport98}.  No contexto desta dissertação,
considera-se que os grupos de tarefas \cmtla{TaskSet} e processos \cmtla{ProcSet}
são definidos em tempo de projeto e especifica-se somente a fase de comunicação do
protocolo \doris. Denota-se $nTask$ e $nProc$ os cardinais destes dois conjuntos.

\begin{figure}[tb]
  \centering
  \input{fig/dorisStruct.pstex_t}
  \caption{O esquema de Divisão Temporal de \doris}
  \label{fig:dorisStruct}
\end{figure}

Usando TDMA, cada fase de comunicação (\emph{C-Rd}) define um número arbitrário,
porém fixo, de ciclos periódicos, os quais são subdivididos em exatamente $nTask$
\ing{chips}, assim como pode ser observado na figura \ref{fig:dorisStruct}. Um
mapeamento dos naturais sobre o conjunto dos \ing{chips} associa um inteiro positivo
módulo $nTask$ a um \ing{chip}. Este mapeamento define um contador, que é denotado
$chipCount$. Cada \ing{chip} é, por sua vez, dividido em duas janelas, críticas e
não-críticas, denotadas \HW e \SW, e associadas, respectivamente, às comunicações de
tempo real críticas e não-críticas. As tarefas só transmitem mensagens durante as
janelas \HW, enquanto os processos apenas utilizam \SW{} para transmitir as suas. Os
tamanhos destas duas janelas são, respectivamente, denotados por \DHW e \DSW e o
tamanho de um \ing{chip} é definido por $\DDC = \DHW + \DSW$. Para permitir um certa
flexibilidade e a definição de políticas de escalonamento das mensagens, a janela
\HW é também subdividida em dois \ing{slots}: o \ing{slot} elementar (\ES) e o
\ing{slot} de reserva (\RS).  As mensagens transmitidas nos \ing{slots} \ES{} e
\RS{} são mensagens críticas, chamadas, respectivamente, de mensagem elementar e de
reserva. Uma vez por ciclo, cada tarefa envia uma mensagem elementar dentro de \ES{}
enquanto \RS{} é utilizada para oferecer um mecanismo de reserva. 

Uma propriedade fundamental de \doriss é que todas as tarefas devem
imperativamente enviar uma única mensagem elementar por ciclo, no seu
respectivo \ing{chip}.  Desta forma, estas mensagens podem ser
utilizadas para fins de detecção de falhas e de sincronização dos relógios locais.

Para permitir o aumento da taxa disponível para uma ou outra tarefa, é possível
atribuir vários \ing{chips} de um mesmo ciclo a uma mesma estação.  No entanto, com
o objetivo de facilitar a apresentação e a especificação de \doris, assume-se nesta
apresentação, sem perda de generalidade, que cada estação envia uma única
mensagem elementar por ciclo. No entanto, esta suposição poderia ser relaxada, de
acordo com o algoritmo utilizado na fase de configuração, alocando um número maior
de \ing{chips} por ciclo a cada estação.  

O controle de acesso ao meio de \doriss é organizado por um bastão circulante
virtual, que circula nos anéis críticos e não-críticos, descritos na seção
\ref{sec:dorisModel}. O bastão circulante é dito virtual porque sua transmissão é
associada a regras temporais e lógicas baseadas na observação da comunicação
no barramento. O isolamento dos dois anéis de \doriss é garantido pelo uso do mecanismo
de TDMA. Em relação ao anel não-crítico, o bastão circula durante a janela
\SW{} a cada vez que uma interrupção é gerada pela placa de rede. Quando um processo
não tem nenhuma mensagem a transmitir, o servidor envia uma mensagem de tamanho
mínimo para passar o bastão circulante ao próximo processo do anel não-crítico.
 
Observa-se que numa fase inicial de concepção do protocolo \doris, pensou-se em
utilizar a capacidade de sensoriamento do meio para organizar a transmissão do
bastão utilizando o mecanismo TPR do protocolo Tempra, apresentado na seção
\ref{sec:TempraVTPE}. No entanto, em face da dificuldade de conseguir placas de
rede que permitam o acesso ao estado do meio (livre ou ocupado), esta
possibilidade foi descartada.


\subsection{O mecanismo de reserva}
\label{sec:mecaRes}

Para aumentar a sua taxa de transmissão de mensagens críticas, uma tarefa
pode utilizar os \ing{slots} de reservas de acordo com o seguinte mecanismo.

Cada mensagem elementar enviada por uma tarefa $T_i$ carrega uma lista de inteiros
(módulo $nTask$), que especifica os identificadores dos \ing{slots} que $T_i$
pretende usar para enviar mensagens adicionais.  Esta lista é um subconjunto do
conjunto dos $nTask$ \ing{chips} seguindo o \ing{chip} no qual $T_i$ envia sua
mensagem. A tarefa $T_i$ só pode reservar um \ing{slot} que ainda não foi reservado
por uma outra tarefa. Para este efeito, cada servidor mantém uma tupla de reservas,
denotado $res$, no qual ele armazena as reservas especificadas em cada mensagem
elementar recebida. A consistência da tupla $res$ pode eventualmente ser
comprometida por falhas de omissão de mensagens elementares. Efetivamente, quando um
servidor não recebe uma mensagem elementar, ele deixa de atualizar $res$ e alguma
tarefa pode tentar reservar algum \ing{slot} previamente reservado. Para evitar tal
cenário, que poderia levar a uma colisão, uma tarefa $T_i$ só pode reservar um
\ing{slot}, se a tupla $res$ do seu servidor estiver em estado consistente, isto é,
se o servidor de $T_i$ tiver recebido as $nTask$ mensagens elementares precedendo o
\ing{chip} de emissão de $T_i$. Desta forma, a alocação dinâmica de \ing{slots} de
reserva é tolerante a falhas de omissão.

Este mecanismo de reserva é uma inovação do protocolo \doriss que permite a
implementação de alguma política de escalonamento. Efetivamente, uma tarefa dispõe
de um \ing{slot} elementar por ciclo e pode usar até $nTask$ outros \ing{slots}. No
entanto, a discussão de tal política foge do escopo desta dissertação.


\section{A especificação formal de DORIS}
\label{sec:dorisSpec}

A descrição do protocolo \doriss e de sua especificação é realizada de forma
progressiva, fornecendo inicialmente uma visão de alto nível, e entrando
gradativamente na apresentação dos detalhes do protocolo. A seção
\ref{sec:modelHipot} descreve o conjunto das hipóteses de modelagem adotadas para
especificar o protocolo. Em seguida, a seção \ref{sec:basicTLA} introduz alguns
conceitos básicos de TLA+. As demais seções apresentam as principais fórmulas que
compõem a especificação formal de \doris. No âmbito de focalizar a descrição da
especificação no protocolo \doriss e na verificação das suas propriedades, algumas
fórmulas foram omitidas. No entanto, a especificação completa está sendo anexada no
final desta dissertação no apêndice~\ref{ap:dorisSpec}.

\subsection{Hipóteses de modelagem}
\label{sec:modelHipot}

Características importantes do sistema devem ser incluídas na especificação de modo
que se possa verificar propriedades interessantes. No entanto, é preciso ter cuidado
para não especificar muitos detalhes devido ao problema da explosão de estados
durante a verificação automática do modelo. As suposições feitas nesta seção têm por
finalidade contornar este problema sem comprometer a descrição do protocolo e sua
verificação.

Em primeiro lugar, como o nosso principal objetivo aqui é fornecer uma descrição
formal do protocolo \doris, a fim de verificar a sua correção, supôs-se que cada
estação hospeda apenas uma tarefa e/ou um processo. Desta forma, evita-se a necessidade
de especificar os servidores \doris.

Em segundo lugar, representou-se o tempo por uma variável inteira. Embora tal
representação discreta do tempo possa comprometer a precisão do modelo no caso de
sistemas assíncronos em geral \cite{Clarke99}, ela é aceitável para protocolos
síncronos baseados em troca de mensagens \cite{Lamport05}. Uma justificativa
intuitiva da correção desta hipótese é que marcas temporais inteiras podem ser
associadas ao início e ao fim de cada ação de envio ou recepção de mensagens. Se
estas marcas foram iguais, devido a um resolução temporal discreta, isto significa
simplesmente que as ações correspondentes são concorrentes.

Em terceiro lugar, considerou-se que, sempre que uma ação especificada for habilitada,
ela acontece sem demora ou é desabilitada imediatamente. Isto significa
que os temporizadores são especificados sem desvios ou atrasos.

Finalmente, considera-se que todas as estações compartilham um relógio comum global,
pois assume-se um modelo síncrono para evitar a especificação de detalhes de
sincronização. Observa-se que, na prática, todas as estações podem sincronizar os seus
relógios locais com precisão, pois as mensagens elementares são obrigatórias e
periódicas.  Detalhes de tal procedimento serão abordados na fase de implementação
descrita no capítulo \ref{cap:implementacao}.

É importante notar que as considerações sobre o desvio nulo dos relógios e sobre a
sincronia do sistema permite a definição de temporizadores globais na especificação,
o que reduz consideravelmente os problemas de explosão de estados.

\subsection{Conceitos de TLA+}
\label{sec:basicTLA}

A Lógica Temporal de Ações (TLA) e sua linguagem formal associada (TLA+) combina a
Lógica Temporal de TLA \cite{Lamport94a} com a expressividade da lógica dos
predicados e a teoria dos conjuntos de Zermelo-Fraenkel. Dotado do verificador de
modelo TLC \cite{Yu99}, TLA+ permite a especificação e a verificação tanto de
protocolos de \ing{hardware} quanto de sistemas distribuídos. Esta seção apresenta
a sintaxe básica de TLA+. Quando necessário, informações complementares
sobre TLA+ serão dadas ao longo da descrição da especificação de \doris.  Leitores
interessados numa descrição ampla de TLA+ podem se referir à publicação de Lamport
\cite{Lamport02a}.

Numa especificação em TLA+, uma computação de um sistema é representada por uma
seqüência de estados, também chamada de comportamento. Para caracterizar os estados
do sistema, uma especificação define o conjunto de variáveis (\textsc{variables})
utilizado para descrever o sistema e o conjunto de constantes (\textsc{constants}),
que são utilizadas para definir os valores eventualmente atribuídos às variáveis.
Um \textbf{estado} do sistema é, portanto, definido pela atribuição de valores
constantes às variáveis da especificação.

Um par de estados consecutivos, suponha $i$ e $f$ em referência a inicial e final,
é chamada de \textbf{passo} (\ing{step}) e é denotado \txtla{i \.{\rightarrow} f}. O operador
linha ``\txtla{\,'\,}'' é utilizado para distinguir os valores de variáveis num
passo. Considerando um certo passo \txtla{S: i \.{\rightarrow} f} e uma variável
$v$, a ocorrência de $v$ sem linha ($v$) faz referência ao valor de $v$ em $i$,
enquanto a ocorrência de $v$ com linha ($v'$) faz referência ao valor de $v$ em $f$.

Uma \textbf{função de estado} é um expressão na qual aparecem somente
variáveis sem linhas. Tal função associa valores constantes aos
estados de um comportamento.  As funções de estado que associam a
valores booleanos são simplesmente chamados de \textbf{predicados} de
estado.

Uma \textbf{função de transição} é uma expressão na qual aparecem
variáveis sem linhas e com linhas. Portanto, denotando $\mathcal{S}$ o
conjunto dos passos de um sistema, e $\mathcal{C}$ um conjunto
qualquer, uma função de transição $F$ é um mapeamento de $\mathcal{S}$
sobre $\mathcal{C})$. Por exemplo, seja um passo \txtla{S: i
  \.{\rightarrow} f} e $v$ uma variável, tal como $v = 0$ no estado
$i$ e $v = 1$ no estado $f$, e seja $F$ a função de transição definida
por $F(S) = v' - v$, tem-se $F(S) = 1$.

Finalmente, uma \textbf{ação} é, por definição, uma função de transição a valores
booleanos. Portanto, uma ação é um mapeamento de $\mathcal{S}$ sobre $\{ V, F \}$,
onde $V$ e $F$ correspondem aos valores de verdade e falso da lógica de
predicados. Considerando o exemplo apresentado acima, a ação $\mathcal{A}$, definida
pela expressão \txtla{\mathcal{A} \defeq v' = v + 1}, na qual o símbolo TLA+
\txtla{\defeq} significa ``igual, por definição'', é verdadeira no passo $S$.  Para
um dado passo $S$, a relação de sucessão do estado $i$ para o estado $f$, usualmente
chamada de função de transição de estado no formalismo das Máquinas de Estado
Finitos, é definida pelo conjunto de ações definidas sobre o passo $S$. Este
conjunto também é uma ação, pois uma ação pode ser composta de várias ações.

As fórmulas temporais de TLA+, como, por exemplo, a relação de transição entre
estados, são asserções booleanas sobre comportamentos.  Diz-se que um comportamento
satisfaz uma fórmula $\mathcal{F}$ se $\mathcal{F}$ é uma asserção verdadeira deste
comportamento.  O operador da lógica temporal $\Box$ é utilizado para escrever as
fórmulas temporais. A semântica do operador $\Box$ é definida da seguinte maneira.
Para algum comportamento $\Sigma$, e alguma ação $\mathcal{A}$, a fórmula temporal
$\mathcal{F} = \Box [ \mathcal{A} ]_{vars}$ é verdadeira -- ou simplesmente ``$\, \Sigma$ 
satisfaz $\mathcal{F} \,$'' -- se e somente se, para qualquer passo \txtla{S: i
  \.{\rightarrow} f} de $\Sigma$ que altera o conjunto $vars$ de todas as variáveis,
$A$ é verdadeira em $S$.


\subsection{Elementos da linguagem TLA+} %Guia de leitura}
\label{sec:guiaLeitura}

Com o intuito de facilitar o entendimento dos detalhes da especificação de \doris,
esta seção agrupa algumas definições dos operadores de TLA+ utilizados.

\act{A construção ``\txtla{[ e \.{\in} E \.{\mapsto} f(e) ]}''} Seja $n$ o cardinal
de $E$. A expressão \txtla{[ e \.{\in} E \.{\mapsto} f(e) ]} representa a tupla de
$n$ elementos definida por \txtla{(f(e_1), f(e_2), \ldots, f(e_n))}.  O símbolo
$\mapsto$ é utilizado aqui para atribuir valores às entradas da tupla. Por exemplo,
a expressão \txtla{[ j \.{\in} Task \.{\mapsto} \.{-} 1 ]}, representa a tupla de
dimensão $nTask$ que recebe o valor -1 para todas as suas coordenadas.

\act{Tarefas e Processos} Para representar os conjuntos \txtla{TaskSet} e
\txtla{ProcSet}, definiam-se as tuplas $Ti$ e $Pj$ das tarefas e dos processos:

\begin{tlafor}
\begin{tla}
Ti == [ i \in Task |-> << "T", i >> ]   /\  Pj == [ j \in Proc |-> << "P", j >> ]
\end{tla}
\begin{tlatex}
 \@x{ Ti \.{\defeq} [ i \.{\in} Task \.{\mapsto} {\langle}\@w{T} ,\, i
 {\rangle} ]\@s{8.2} \.{\land}\@s{4.1} Pj \.{\defeq} [ j \.{\in} Proc
 \.{\mapsto} {\langle}\@w{P} ,\, j {\rangle} ]}%
\end{tlatex}
\end{tlafor}

Utilizando estas duas tuplas, as expressões para  \txtla{TaskSet} e
\txtla{ProcSet} são dadas por:

\begin{tlafor}
\begin{tla}
TaskSet == { Ti[i]: i \in Task }  /\  ProcSet == { Pj[j]: j \in Proc }
\end{tla}
\begin{tlatex}
 \@x{ TaskSet \.{\defeq} \{ Ti [ i ] \.{:} i \.{\in} Task \}\@s{4.1}
 \.{\land}\@s{4.1} ProcSet \.{\defeq} \{ Pj [ j ] \.{:} j \.{\in} Proc \}}%
\end{tlatex}
\end{tlafor}

O símbolo ``$\,:\,$'' tem aqui o sentido ``tal que'' usual na matemática.

\act{O operador ``\txtla{\,\CHOOSE}''} Numa expressão do tipo \txtla{\CHOOSE x
  \.{\in} C : F ( x )}, o operador \txtla{\CHOOSE} escolhe um elemento $x$ qualquer
do conjunto $C$ tal que (``$\,:\,$'') a proposição $F(x)$ seja verdadeira.  Por
exemplo, considerando um elemento \txtla{t \.{\in} TaskSet} ou \txtla{p \.{\in}
  ProcSet}, o seu índice é encontrado pelas funções \txtla{taskId } e \txtla{procId}
assim definidas:

\begin{tlafor}
\begin{notla}
taskId(T) == CHOOSE i \in Task : T = Ti[i]
procId(P) == CHOOSE j \in Proc : P = Pj[j]
\end{notla}
\begin{tlatex}
\@x{ taskId ( T ) \.{\defeq} {\CHOOSE} i \.{\in} Task \.{:} T \.{=} Ti [ i ]}%
\@x{ procId ( P ) \.{\defeq} {\CHOOSE} j \.{\in} Proc \.{:} P \.{=} Pj [ j ]}%
\end{tlatex}
\end{tlafor}

Nestes exemplos, a escolha é única, pois existe um único índice verificando a
proposição especificada em ambos os casos.

\act{A construção ``\txtla{\,\LET} $\ldots\;$ \textsc{in }''} Esta construção
sintática é utilizada para definir constantes locais. O escopo das definições
efetuadas na cláusula do \textsc{\,let\,} é o conjunto de fórmulas da cláusula do
\textsc{\,in}.  Por exemplo, na seguinte expressão

\vspace{3mm}
\setstretch{0.}
\begin{tla}
\E T \in TaskSet : LET i == taskId(T)
                   IN F(i)
\end{tla}
\begin{tlatex}
\@x{ \@s{140}\E\, T \.{\in} TaskSet \.{:} \.{\LET} i \.{\defeq} taskId ( T )}%
\@x{\@s{220.17} \.{\IN} F ( i )}%
\end{tlatex}
\par\setstretch{1.4}

\noindent a constante $i$, definida como o índice da tarefa $T$, é conhecida apenas
na proposição $F(i)$.

\act{A construção ``\txtla{\EXCEPT}, \txtla{\;\.{!}\;} e \txtla{\;\.{@}\,}''} A
palavra \txtla{\EXCEPT}, juntamente com os símbolos \txtla{\;!\;} e \txtla{\;@}, são
utilizados para definir as ações que envolvem tuplas. Por
exemplo, a ação $A$, definida por

\begin{tlafor}
\begin{tla}
A == History' = [ History EXCEPT !.elem = @ + 1 ]
\end{tla}
\begin{tlatex}
\@x{ A \.{\defeq} History \.{'} \.{=} [ History {\EXCEPT} ! . elem  \.{=} @ \.{+} 1 ]}%
\end{tlatex} 
\end{tlafor}

\noindent é verdadeira num passo \txtla{i \rightarrow f} se a tupla \txtla{History}
for igual nos dois estados $i$ e $f$, com a exceção do campo \txtla{elem}, cujo
valor no estado $f$ (\txtla{!.elem}) deve ser igual ao seu valor no estado $i$
($@$) incrementado de 1. O símbolo ``$\;!\;$'' é uma abreviação para o sujeito
%nome da variável que figura a esquerda
da palavra \textsc{except}, e o símbolo ``$@$'', por sua vez, representa o valor, no
estado $i$, do campo a ser modificado pela cláusula do % subordinada do %na 
\textsc{except}.  Portanto, uma sintaxe equivalente de $A$, porém menos concisa,
seria:

\begin{tlafor}
\begin{tla}
A == History' = [ History EXCEPT History.elem' = History.elem + 1 ]
\end{tla}
\begin{tlatex}
\@x{ A \.{\defeq} History \.{'} \.{=} [ History {\EXCEPT} History. elem \.{'}
\.{=} History.elem \.{+} 1 ]}%
\end{tlatex} 
\end{tlafor}

\act{A construção ``\txtla{\; \CASE}, \txtla{\;\.{\Box}\;} e \txtla{\;\.{\rightarrow}}''}
O operador \txtla{\CASE} permite a escolha múltipla de valores, baseado no caráter de 
verdade de um conjunto de predicados logicamente exclusivos. Um exemplo de uso
desta construção será visto na definição da função $list$, apresentada na 
figura \ref{fig:listFunc}. 

\act{O operador ``\txtla{\;@@\;}''} Este operador é utilizado para construir tuplas
a partir de tuplas menores. Considerando, por exemplo, dois conjuntos C e D disjuntos,
o operador ``\txtla{\;@@\;}'' pode ser definido pela fórmula seguinte:

\begin{tlafor}
\begin{tla}
[ i \in C |-> << "V", i >> ] @@ [ i \in D |-> << ''V'', i >> ] == [ i \in C \cup D |-> << ''V'', i >> ]
\end{tla}
\begin{tlatex}
 \@x{ [ i \.{\in} C \.{\mapsto} {\langle}\@w{V} ,\, i {\rangle} ] \.{\,@@\,} [
 i \.{\in} D \.{\mapsto} {\langle} \@w{V} ,\, i {\rangle}
 ] \.{\defeq} [ i \.{\in} C \.{\cup} D \.{\mapsto} {\langle}\@w{V} ,\, i {\rangle} ]}%
\end{tlatex}
\end{tlafor}

Por exemplo, se \txtla{C \.{\defeq} 1 \.{\dotdot} 3} e \txtla{D \.{\defeq} 4 \.{\dotdot} 7}, tem-se:

\begin{tlafor}
\begin{tla}
[ i \in 1..3 |-> << "V", i >> ] @@ [ i \in 4..7 |-> << ''V'', i >> ] == [ i \in 1..7 |-> << ''V'', i >> ]
\end{tla}
\begin{tlatex}
 \@x{ [ i \.{\in} 1 \.{\dotdot} 3 \.{\mapsto} {\langle}\@w{V} ,\, i {\rangle} ]
 \.{\,@@\,} [ i \.{\in} 4 \.{\dotdot} 7 \.{\mapsto} {\langle}\@w{V} ,\, i {\rangle} ]
\.{\defeq} [ i \.{\in} 1 \.{\dotdot} 7 \.{\mapsto} {\langle}\@w{V} ,\, i {\rangle} ]}%
\end{tlatex}
\end{tlafor}

\act{O operador ``\txtla{\UNCHANGED}''} Para otimizar o algoritmo de
verificação automática e garantir que a especificação de alguma ação não seja
esquecida, uma especificação em TLA+ deve imperativamente especificar, para cada uma
das ações principais da relação de transição, as regras de evolução de todas as
variáveis do conjunto $vars$. Se uma variável $v$ não for modificada, a ação
particular \txtla{ v \.{'} = v } é utilizada. Para efeito de concisão, a palavra
\txtla{\UNCHANGED E} é utilizada para definir o conjunto $E$ das variáveis não
modificadas por uma determinada ação. Por exemplo, \txtla{\quad {\UNCHANGED}
  {\langle} v {\rangle} \.{\defeq} v \.{'} \.{=} v}.

\act{Indentação} Deve ser ressaltado que, em TLA+, a indentação é
utilizada preferencialmente no lugar de parênteses. Desta forma, os operadores
\txtla{\.{\land}} e \txtla{\.{\lor}} são utilizados para escrever fórmulas lógicas
complexas sob a forma de listas indentadas.


\subsection{Constantes e variáveis}
\label{sec:consVar}

As constantes da especificação de \doriss são definidas na tabela
\ref{tab:specCons}. Um conjunto de valores possíveis para verificar \doriss é, por
exemplo: $nTask = 8, nProc = 7, deltaChip = 300, delta = 6, pi = 111, maxTxTime =
122$. Os valores de $nTask$ e $nProc$ são escolhidos arbitrariamente. Porém, valores
muito grandes provocam uma explosão do número de estados do sistema.  Os valores de
delta ($\delta$) e $maxTxTime$ correspondem aos tempos de transmissão em $\mu s$ de
mensagens de 72 bytes e 1524 bytes num barramento Ethernet de 100Mbps (ver seção
\ref{sec:sisHibrid}).  $pi$ ($\pi$) é o tempo utilizado por \cite{Carreiro03}. Finalmente,
$\Delta_C$ deve ser maior que $2 \pi$, para garantir que as duas mensagens críticas
enviadas num \ing{chip} sejam processadas antes do início do próximo \ing{chip}.


\begin{table}[t!b]
  \begin{center}
    \begin{tabular}{ | c |  p{12cm} | }
      \hline  \hline 
      \textbf{Constantes}
      & \textbf{Descrição}    \rule{0pt}{6.mm}  \\[1.4mm]
      \hline
      \txtla{nTask} \vbar     
      & Número de tarefas participando do segmento \doris. \vspc
      \hline
      \txtla{nProc} \vbar     
      & Número de processos participando do segmento \doris.  \vspc 
      \hline
      \txtla{deltaChip} \vbar     
      & Duração ($\Delta_C$) de um \ing{chip}.  \vspc 
      \hline
      \txtla{delta} \vbar     
      & Tempo de transmissão ($\delta$) de um quadro Ethernet de tamanho mínimo.  \vspc 
      \hline
      \txtla{pi} \vbar     
      & Tempo de processamento ($\pi$) de uma mensagem crítica pelo dispositivo
      mais lento.  \vspc 
      \hline
      \txtla{maxTxTime} \vbar     
      & Tempo de transmissão de um quadro Ethernet de tamanho máximo.  \vspc 
      \hline \hline
    \end{tabular}
    \caption{O conjunto \textsc{constants} da especificação de \doris}
    \label{tab:specCons}
  \end{center}
\end{table}

\newcommand{\loclenA}{18.5mm}
\newcommand{\loclenB}{98.mm}
\newcommand{\loclenR}{2.5mm}
%\bigskip
\begin{table}[htb!]
  \begin{center}
    \begin{tabular}{ | p{20.5mm} | @{} p{125mm} @{} |}
      \hline  \hline 
      \textbf{Variável}
      &
      \begin{tabular}{  p{\loclenA} | p{\loclenB} }
        \textbf{Campo}  & \textbf{Descrição} \rule{0pt}{6.mm}  \\[1.4mm]
      \end{tabular}\\

      \hline
      \parbox{20.5mm}{\txtla{Shared} (global)}
      &
      \begin{tabular}{  p{\loclenA} | p{\loclenB} }
        \raisebox{-\loclenR}{\txtla{chipTimer}} 
        & \vbar é um temporizador crescente, que varia de 0 a $\Delta_C$,  e representa
        o fluxo do tempo durante um \ing{chip}. %\newline (\txtla{deltaChip}). 
         \vspc \hline

        \txtla{chipCount}
        & \vbar é um contador que identifica os \ing{chips} módulo $nTask$. 
         \vspc \hline 
        
        \raisebox{-5mm}{\txtla{medium}}\vbar
        & representa o estado do meio.  Na ausência de transmissão, \txtla{medium} vale
        \txtla{\{ \}}. Senão, \txtla{medium} contém uma mensagem em fase de transmissão. 
        \vspc \hline     

        \raisebox{-5mm}{\txtla{macTimer}}\vbar
        & é um temporizador decrescente que indica o tempo que falta para
        completar a transmissão de uma mensagem. Em particular, 
        \txtla{\; macTimer \.{=} 0 \; \.{\implies} \;  medium \.{=} \{ \}}. \vspc 
      \end{tabular}\\

      \hline
      \parbox{20.5mm}{\txtla{TaskState} (tupla local)}
      &
      \begin{tabular}{  p{\loclenA} | p{\loclenB} }
        \raisebox{-\loclenR}{\txtla{msg}}\vbar
        & representa a lista de mensagens críticas armazenadas na memória local
        após recepção na placa de rede. \vspc  \hline

        \raisebox{-5mm}{\txtla{execTimer}}\vbar
        & é um temporizador decrescente que indica o tempo de execução que falta para
        completar o processamento de uma mensagem crítica. \vspc \hline

        \raisebox{-\loclenR}{\txtla{res}}\vbar
        & é a lista de reservas existentes para os \txtla{nTask}
        próximos \ing{slots}. \vspc \hline

        \raisebox{-5mm}{\txtla{cons}}\vbar
        & é um contador que contabiliza o número de mensagens elementares recebidas
        num ciclo completo de \doris. \vspc
      \end{tabular}\\

      \hline
      \parbox{20.5mm}{\txtla{ProcState} (tupla local)}
      &
      \begin{tabular}{  p{\loclenA} | p{\loclenB} }
        \raisebox{-\loclenR}{\txtla{token}}\vbar
        & é o contador associado ao bastão circulante utilizado nas janelas \SW.  \vspc  \hline

        \raisebox{-\loclenR}{\txtla{list}}\vbar
        & é a lista das mensagens não-críticas esperando para ser enviadas.  \vspc  \hline

        \raisebox{-\loclenR}{\txtla{count}}\vbar
        & é um contador que contabiliza o número de mensagens não-críticas recebidas
        durante uma janela \SW.  \vspc
      \end{tabular}\\

      \hline
      \parbox{20.5mm}{\txtla{History} (observador global)}
      &
      \begin{tabular}{  p{\loclenA} | p{\loclenB} }
        \raisebox{-\loclenR}{\txtla{elem}}\vbar
        & é um contador que contabiliza o número de mensagens elementares enviadas
        num ciclo. \vspc \hline
      
        \raisebox{-\loclenR}{\txtla{rese}}\vbar
        & é um contador que contabiliza o número de mensagens de reservas enviadas
        num ciclo.  \vspc 
      \end{tabular}\\
      \hline \hline
    \end{tabular}
    \caption{O conjunto \textsc{variables} da especificação de \doris}
    \label{tab:specVars}
  \end{center}
\end{table}

%\clearpage

Outras constantes podem ser definidas no decorrer da especificação, utilizando o
símbolo ``\txtla{\defeq}''.  Por exemplo, define-se \txtla{ Task \.{\defeq} 1
  \.{\dotdot} nTask} e \txtla{ Proc \.{\defeq} 1 \.{\dotdot} nProc}, os dois
conjuntos de inteiros isomorfos a \txtla{TaskSet} e \txtla{ProcSet}, respectivamente.
Nestas definições, a definição do símbolo ``\txtla{\,{..}}'' é: para dois inteiros
$i$, $j$ tal que $i < j$, \txtla{ i \.{\dotdot} j \.{\defeq} \{ i ,\, i \.{+} 1 ,
  \.{\ldots} ,\, j \}}. Outros exemplos são as definições subseqüentes dos
conjuntos: \txtla{TaskSet \.{\defeq} \{ T [ i ] \.{:} i \.{\in} Task \}} e
\txtla{ProcSet \.{\defeq} \{ P [ j ] \.{:} j \.{\in} Proc \}}.

As variáveis da especificação, apresentadas na tabela \ref{tab:specVars}, são
agrupadas em quatro estruturas chamadas $Shared$, $TaskState$, $ProcState$ e
$History$ de acordo com as suas características. A variável $Shared$ é uma tupla com
quatro campos, utilizada para armazenar a visão distribuída compartilhada por
todos. As duas outras variáveis, $TaskState$ e $ProcState$, são tuplas de dimensão
 $nTask$ e $nProc$,  com 4 e 3 campos, respectivamente, que armazenam as
informações locais de cada tarefa e processo.  Finalmente, a variável $History$ é
uma tupla com 2 campos, utilizada para especificar propriedades temporais. Esta
variável é apenas um ``observador'' que não interfere na especificação do
protocolo.


\subsection{A fórmula principal de \doris}
\label{sec:formPrinc}

\act{Spec} A fórmula \txtla{Spec}, apresentada na figura \ref{fig:formPrinc2}, é a
fórmula principal da especificação de \doris{}.

\begin{tlafig}
\begin{tla}
  Spec == Init /\ [] [ Next \/ Tick ]_vars /\ Liveness
\end{tla}
\begin{tlatex}
 \@x{ \@s{94} Spec \.{\defeq} Init \.{\land} {\Box} [ Next \.{\lor} Tick ]_{
 vars} \.{\land} Liveness}%
\end{tlatex}
\tlacaption{A fórmula Spec \label{fig:formPrinc2}}
\end{tlafig}

\txtla{\quad \; Init} é o conjunto dos estados iniciais, \txtla{{\Box} [ Next \.{\lor} Tick
  ]_{ vars}} é a relação de sucessão, aqui composta da disjunção das duas ações
\txtla{Next} ou \txtla{Tick}, e \txtla{Liveness} é uma condição de evolução do
sistema.  \txtla{Next} e \txtla{Tick} são os conjuntos de ações que podem ser
verdadeiras num certo passo de um comportamento. Conseqüentemente, um comportamento
$\Sigma$ satisfaz \txtla{Spec} se e somente se o primeiro estado de $\Sigma$ é um
elemento de \txtla{Init} e todos os passos de $\Sigma$ satisfazem \txtla{Next} ou
\txtla{Tick} e a condição \txtla{Liveness}.

\act{Init} A fórmula \txtla{Init}, apresentada na figura \ref{fig:Init}, descreve o
conjunto dos estados iniciais do sistema, ou seja, \txtla{Init} é a definição dos
conjuntos de valores inicias possíveis para cada variável da especificação. Aqui,
cada conjunto contém apenas um elemento, pois considera-se um estado inicial único do
sistema.

\begin{tlafig} 
\begin{tla}
Init ==
      /\ Shared = [ chipTimer |-> 0, chipCount |-> 1, macTimer |-> 0, medium |-> {} ]
      /\ TaskState = [ i \in Task |-> [ msg |-> << >>, execTimer |-> Infinity, 
                                        res |-> [ j \in Task |-> -1 ], cons |-> nTask - i + 1 ] ] 
      /\ ProcState = [ j \in Proc |-> [ token |-> 1, list |-> list(j), count |-> 0 ] ]
      /\ History = [ elem |-> 0, rese |-> 0 ]
\end{tla}
\begin{tlatex}
\@x{ Init \.{\defeq}}%
 \@x{\@s{23.85} \.{\land} Shared \.{=} [ chipTimer \.{\mapsto} 0 ,\, chipCount
 \.{\mapsto} 1 ,\, macTimer \.{\mapsto} 0 ,\, medium \.{\mapsto} \{ \} ]}%
 \@x{\@s{23.85} \.{\land} TaskState \.{=} [ i\@s{0.51} \.{\in} Task
 \.{\mapsto} [ msg \.{\mapsto} {\langle} {\rangle} ,\, execTimer \.{\mapsto}
 Infinity ,\,}%
 \@x{\@s{174.68} res\@s{5.30} \.{\mapsto} [ j \.{\in} Task \.{\mapsto} \.{-} 1
 ] ,\, cons \.{\mapsto} nTask \.{-} i \.{+} 1 ] ]}%
 \@x{\@s{23.85} \.{\land} ProcState\@s{0.58} \.{=} [ j \.{\in} Proc\@s{1.18}
 \.{\mapsto} [ token\@s{8.52} \.{\mapsto} 1 ,\, list \.{\mapsto} list ( j )
 ,\, count \.{\mapsto} 0 ] ]}%
 \@x{\@s{23.85} \.{\land} History \.{=} [ elem \.{\mapsto} 0 ,\, rese
 \.{\mapsto} 0 ]}%
\end{tlatex}
\tlacaption{A fórmula $Init$ \label{fig:Init}}
\end{tlafig} 

%Voltando à descrição da formula $Init$, 
Os valores definidos para os quatro campos da variável global \txtla{Shared} indicam
que o \ing{chip}~$1$ está iniciando \cmtla{chipTimer \.{\mapsto} 0, chipCount
  \.{\mapsto} 1}, que o meio está livre \cmtla{medium \.{\mapsto} \{ \}} e que
\txtla{macTimer} é nulo \cmtla{macTimer \.{\mapsto} 0 }, pois nenhuma mensagem está
sendo transmitida.  Assim como foi visto na seção \ref{sec:guiaLeitura}, a expressão
\txtla{res \.{\mapsto} [ j \.{\in} Task \.{\mapsto} \.{-} 1 ]} significa que, no
estado inicial, todas as entradas da tupla $res$ valem $-1$. Lembrar da seção
\ref{sec:mecaRes} que $res$ é a tupla que armazena as reservas recebidas por uma
tarefa. O valor arbitrário $-1$ é utilizado aqui para indicar que não há reserva
para o \ing{slot} correspondente.

No caso das variáveis locais, \txtla{TaskState} e \txtla{ProcState}, as fórmulas têm
o seguinte significado. Cada tarefa $i$ do conjunto \txtla{Task} assume que:

\begin{itemize}
\item A sua lista de mensagens críticas para serem processadas está vazia \cmtla{msg
    \.{\mapsto} {\langle} {\rangle}}
\item Conseqüentemente, o temporizador \txtla{execTimer}, utilizado para representar
  o tempo de execução que falta para processar um mensagem crítica, é desabilitado
  (\txtla{execTimer \.{\mapsto} Infinity });
\item A sua lista de reservas está vazia, ou seja, todas os campos da tupla
  \txtla{res} valem $-1$ \cmtla{res \.{\mapsto} [ j \.{\in} Task \.{\mapsto} \.{-} 1
    ]};
\item Ela está num estado consistente \cmtla{cons \.{\mapsto} nTask \.{-} i \.{+} 1
  }. Lembrar que uma tarefa está num estado consistente se ela recebeu todas as
  mensagens elementares desde o último \ES{} no qual ela enviou uma mensagem (ver
  seção \ref{sec:mecaRes}).
\end{itemize}

Cada processo $j$ do conjunto \txtla{Proc}:
\begin{itemize}
\item Assume que o processo $1$ está inicialmente em posse do bastão circulante \cmtla{token
    \.{\mapsto} 1};
\item Utiliza a função de estado \txtla{list} (ver figura \ref{fig:listFunc}) para definir a
  lista da suas mensagens não-críticas. 
\item Assume que ele ainda não recebeu nenhuma mensagem não-crítica \cmtla{count
    \.{\mapsto} 0}.
\end{itemize}

Finalmente, os dois contadores de mensagens elementares e de reservas da variável de
observação \txtla{History} são iniciados com ``$0$'' \cmtla{elem \.{\mapsto} 0 ,\, rese
 \.{\mapsto} 0}. 

\act{list} A função \txtla{ list } define a lista de mensagens a serem
enviadas por cada processo durante um ciclo de \doris. Esta função é
escolhida arbitrariamente de acordo com o cenário de verificação
desejado. Uma das possíveis definições desta função é apresentada na
figura \ref{fig:listFunc}.

\begin{tlafig} 
\begin{tla}
list(j) == CASE j \in { 1 } -> [ i \in 1..4 |-> [ txTime |-> maxTxTime ] ]
           []   j \in { 2 } -> << >>
           []   j \in Proc \ { 1, 2 } -> 1 :> [ txTime |-> maxTxTime ]
\end{tla}
\begin{tlatex}
 \@x{ list ( j ) \.{\defeq} {\CASE} j \.{\in} \{ 1 \} \.{\rightarrow} [ i
 \.{\in} 1 \.{\dotdot} 4 \.{\mapsto} [ txTime \.{\mapsto} maxTxTime ] ]}%
 \@x{\@s{70.26} {\Box}\@s{4.1} j \.{\in} \{ 2 \} \.{\rightarrow}
 {\langle} {\rangle}}%
 \@x{\@s{70.26} {\Box}\@s{4.1} j \.{\in} Proc \.{\,\backslash\,} \{
 1 ,\, 2 \} \.{\rightarrow} 1 \.{\colongt} [ txTime \.{\mapsto} maxTxTime ]}%
\end{tlatex}
\tlacaption{A função $list$ \label{fig:listFunc}}
\end{tlafig} 

Aqui, a função $list$ utiliza a construção TLA+ ``\textsc{CASE}, \txtla{\.{\Box}},
\txtla{\.{\rightarrow}}'' para diferenciar as tuplas de acordo com o valor de
$j$. Em tal construção, o símbolo \txtla{\.{\Box}} é utilizado para listar todos os
casos do \textsc{CASE}, e o símbolo \txtla{\.{\rightarrow}} indica o valor para ser
adotado em cada caso. Neste exemplo, as tuplas de mensagens definidas para cada
processo são: $list(1)$ de $P[1]$ contém 4 mensagens, cada uma com o tempo de
processamento ($txTime$) de uma mensagem Ethernet de tamanho máximo ($maxTxTime$);
$list(2)$ de $P[2]$ está vazia; para os demais processos, $list(j)$ contém apenas uma
mensagem de tamanho máximo. Outras definições de $list(j)$ são possíveis, de acordo
com o cenário de comunicação para ser verificado.


\subsection{Ações principais}

A especificação de \doriss é constituída por 7 ações principais, cinco que compõem a
fórmula \txtla{Next}, e duas que compõem a fórmula \txtla{Tick}.  O conjunto de
fórmulas de cada uma destas ações principais é dividido em dois conjuntos lógicos
diferentes. O primeiro conjunto é constituído pelos predicados de estados, também
chamados de guardas, nos quais figuram constantes e variáveis sem linhas. Este
conjunto representa as condições de realização da ação.  O segundo conjunto é
constituído pelas ações -- nas quais figuram constantes, variáveis sem linhas e com
linhas -- que especificam as operações de \doris.

\act{Next} Esta ação, apresentada na figura \ref{fig:Next}, descreve as operações do
protocolo que acontecem instantaneamente, ou seja, as ações que não decrementam os
temporizadores, pois suas durações são muito curtas, comparativamente com os tempos
de transmissões das mensagens.  Este é o caso, aqui, das operações de emissão e
recepção de mensagens.  Lembrar que, para as tarefas, receber não significa
processar, mas somente colocar na memória local da placa de rede.

\begin{tlafig} 
\begin{notla}
Next  ==  \/ \E T \in TaskSet : SendElem(T) \/ SendRese(T)
          \/ \E P \in ProcSet : SendSoft(P)
          \/ \E msg \in Shared.medium : RecvHard(msg) \/ RecvSoft(msg)
\end{notla}
\begin{tlatex}
 \@x{ Next\@s{4.1} \.{\defeq}\@s{4.1} \.{\lor} \E\, T\@s{1.69} \.{\in} TaskSet
 \.{:} SendElem ( T ) \.{\lor} SendRese ( T )}%
\@x{\@s{55.22} \.{\lor} \E\, P \.{\in} ProcSet\@s{0.58} \.{:} SendSoft ( P )}%
 \@x{\@s{55.22} \.{\lor} \E\, msg \.{\in} Shared . medium \.{:} RecvHard ( msg
 ) \.{\lor} RecvSoft ( msg )}%
\end{tlatex}
\tlacaption{A ação $Next$ \label{fig:Next}}
\end{tlafig} 

Como pode ser observado, a ação \txtla{Next} é uma disjunção de cinco ações,
correspondendo à emissão e recepção de mensagens. O uso do operador \txtla{\E}
permite expressar a dependência de uma ação com relação ao seu argumento. Por
exemplo, a ação \txtla{SendElem} só pode satisfazer um passo $S$ se existir uma
tarefa $T$ tal que \txtla{SendElem ( T )} seja verdadeira em $S$.  A primeira linha
da ação \txtla{Next} especifica a emissão de uma mensagem por uma tarefa $T$ e a
segunda, por um processo $p$.  As duas ações \txtla{SendElem} e \txtla{SendRese}
correspondem às janelas \HW -- subdividida em \ES{} e \RS{} -- e a ação
\txtla{SendSoft} corresponde à janela \SW.  A terceira linha especifica a recepção
de uma mensagem presente no meio, de acordo com o seu tipo.  \txtla{RecvHard}
corresponde à recepção de uma mensagem crítica, enquanto \txtla{RecvSoft}
corresponde à recepção de uma mensagem não-crítica.

Assim como será visto nas próximas seções, cada uma destas ações é regida por um
conjunto de predicados, também chamado de condições de realizações ou guardas
(\ing{enabling conditions}). Em conseqüência da estrutura temporalmente seqüencial
de \doris, este conjunto de guardas corresponde, na maioria das ações de \doris{}, às
condições exclusivas de realização. Portanto, o operador ``\txtla{\lor}'' é
exclusivo em quase todas as suas ocorrências.

Considera-se agora um estado $e$ alcançável da especificação, isto é,
tal que exista uma seqüência de passos levando de \txtla{i \.{\in} Init} a
$e$. Suponha, ainda, que no estado $e$, pelo menos um dos guardas das cinco ações
sejam falsos. Neste caso, não existe estado $f$ tal que \txtla{Next} satisfaz o passo 
\txtla{e \rightarrow f}. Isto pode acontecer por duas razões. O sistema ficou
numa situação de bloqueio (\ing{deadlock}) por causa de um erro de especificação
 ou de projeto, ou a ação \txtla{Tick} está habilitada.

 \act{Tick} Esta ação, definida pela fórmula \txtla{Tick \.{\defeq} NextTick
   \.{\lor} NextChip}, especifica o fluxo do tempo. Para permitir a verificação de
 alguns modelos finitos do sistema, apesar da natureza sem limite do tempo,
 utilizou-se uma representação do tempo circular. Isto foi realizado dividindo a
 ação \txtla{Tick} na disjunção de duas ações: \txtla{NextTick}, que incrementa o
 tempo por passos discretos, e \txtla{NextChip}, que realiza a transição de um
 \ing{chip} para o próximo, incrementando o valor do contador $chipCount$. Se fosse
 só a ação \txtla{NextTick}, o temporizador \txtla{chipTimer} poderia crescer
 indefinidamente. Porém, a cada vez que a ação \txtla{NextChip} acontece, ela
 redefine o temporizador \txtla{chipTimer} para o valor ``$0$'' de tal forma que
 este temporizador varia de ``$0$'' a $\Delta_C$. Além disso, o contador $chipCount$
 é também redefinido para o seu valor inicial $1$, sempre que ele atinge o valor
 $nTask$. Desta forma, a representação do tempo permite verificar comportamentos do
 sistema durante um ciclo completo de \doris.

\newpage
\act{Liveness} Esta restrição, definida pela fórmula \txtla{Liveness
  \.{\defeq} {\Box} {\Diamond} Tick}, (na qual \txtla{ {\Diamond} F
  \.{\defeq} {\neg} {\Box} {\neg} F}) garante que um comportamento que satisfaz
$Spec$ tenha estados em todos os \ing{chips} de um ciclo de \doris. De fato, devido
à representação circular do tempo, \txtla{Liveness} é satisfeita apenas por
comportamentos cíclicos, porém sem bloqueio, permitindo a verificação de modelos
finitos de \doris.

\begin{comment}
  \iniTLA
  \begin{notla}
    Liveness == []<> Tick
  \end{notla}
  \begin{tlatex}
    \@x{ Liveness \.{\defeq} {\Box} {\Diamond} Tick}%
  \end{tlatex}
  \finTLA
\end{comment}


\subsection{O anel crítico}
\label{sec:anelCrit}

Assim como foi visto na seção \ref{sec:dorisMAC}, a alternância das janelas \HW do
anel crítico e \SW{} do anel não-crítico é definida pelo mecanismo TDMA. As janelas
\HW{} e \SW{} iniciam quando o valor de \txtla{chipTimer} é igual a ``$0$'' e $2
\delta$, respectivamente. Dentro da janela \HW, o valor $\delta$ de
\txtla{chipTimer} indica que o \ing{slot} de reserva começa. Além destas condições
temporais, a circulação do bastão no anel crítico utiliza condições lógicas baseadas
no valor de \txtla{chipCount}, o contador de \ing{chip}. Detalhes desta condições
serão dadas durante a descrição das ações correspondentes.

O anel crítico é especificado por três ações principais \txtla{SendElem}, \txtla{SendRese}
e \txtla{RecvHard}, cujas descrições são objetos desta seção.

% -------------------------------- Action -------------------------------
\act{SendElem} Esta ação, apresentada na figura \ref{fig:SendElem}, descreve as
regras que regem a emissão de uma mensagem elementar.

\begin{tlafig}
\begin{tla}
SendElem(T) ==
      /\ Shared.medium = {}
      /\ Shared.chipTimer = 0
      /\ LET i == taskId(T)
         IN /\ Shared.chipCount = i
            /\ LET resSet == reservation(i) 
               IN /\ Shared' = [ Shared EXCEPT 
                         !.macTimer = delta,
                         !.medium = { [ id |-> i, type |-> "hard", res |-> resSet ] }]
                  /\ TaskState' = [ TaskState EXCEPT
                         ![i].res = [ j \in Task |-> IF j \in resSet THEN i ELSE @[j] ],
                         ![i].cons = 1 ] 
            /\ History' = [ History EXCEPT !.elem = @ + 1 ]
            /\ UNCHANGED ProcState
\end{tla}
\begin{tlatex}
\@x{ SendElem ( T ) \.{\defeq}}%
\@x{\@s{24.59} \.{\land} Shared . medium \.{=} \{ \}}%
\@x{\@s{24.59} \.{\land} Shared . chipTimer \.{=} 0}%
\@x{\@s{24.59} \.{\land} \.{\LET} i \.{\defeq} taskId ( T )}%
\@x{\@s{37.93} \.{\IN} \.{\land} Shared . chipCount \.{=} i}%
\@x{\@s{60.30} \.{\land} \.{\LET} resSet \.{\defeq} reservation ( i )}%
\@x{\@s{73.63} \.{\IN} \.{\land} Shared \.{'} \.{=} [ Shared {\EXCEPT}}%
\@x{\@s{125.73} ! . macTimer \.{=} delta ,\,}%
 \@x{\@s{125.73} ! . medium \.{=} \{ [ id \.{\mapsto} i ,\, type
 \.{\mapsto}\@w{hard} ,\, res \.{\mapsto} resSet ] \} ]}%
\@x{\@s{96.00} \.{\land} TaskState \.{'} \.{=} [ TaskState {\EXCEPT}}%
 \@x{\@s{125.73} ! [ i ] . res \.{=} [ j \.{\in} Task \.{\mapsto} {\IF} j
 \.{\in} resSet \.{\THEN} i \.{\ELSE} @ [ j ] ] ,\,}%
\@x{\@s{125.73} ! [ i ] . cons \.{=} 1 ]}%
 \@x{\@s{60.30} \.{\land} History \.{'} \.{=} [ History {\EXCEPT} ! . elem
 \.{=} @ \.{+} 1 ]}%
\@x{\@s{60.30} \.{\land} {\UNCHANGED} ProcState}%
\end{tlatex}
\tlacaption{A ação $SendElem$ \label{fig:SendElem}}
\end{tlafig}

Antes de descrever passo-a-passo esta ação, alguns conceitos e termos precisam
ser introduzidos. O mecanismo de rotação do bastão circulante utiliza o contador
\txtla{chipCount}, definido módulo \txtla{nTask}, que identifica o \ing{chip}
corrente. Assim como será visto na seção \ref{sec:AcaoTick}, este contador é
periodicamente incrementado pela ação \txtla{NextChip}, quando o temporizador
\txtla{chipTimer} expira, no fim de cada \ing{chip}. O temporizador \txtla{macTimer}
especifica o tempo de transmissão de uma mensagem.  Ele é igual a ``$0$'' quando o
meio físico está livre. Senão, seu valor indica o tempo restante para completar a
transmissão corrente.  Finalmente, o campo \txtla{medium} da variável
\txtla{Shared} representa o estado do meio. Quando uma mensagem $msg$ é enviada, ela
é armazenada na variável \txtla{medium}. Quando uma transmissão termina, o meio
volta a estar livre, o que é representado pela fórmula \txtla{\;medium = \{ \}}.

Voltando agora para a descrição da ação \txtla{SendElem}, os dois primeiros guardas
estabelecem que uma tarefa $T$ pode enviar uma mensagem elementar se: (i) o meio
está livre \linebreak (\txtla{Shared .medium \.{=} \{ \}}); e (ii) o \ing{chip} está
começando (\txtla{Shared .chipTimer \.{=} 0 }). Em seguida, a primeira construção
``\txtla{\.{\LET} \ldots\; \textsc{in}}'' define o índice $i$ da tarefa $T$ (tal que
\txtla{ T \.{=} T [ i ] }) para qual a ação \txtla{SendElem} é verdadeira e o guarda
\txtla{Shared .chipCount \.{=} i } garante que esta tarefa esteja em posse do bastão
circulante. Desta forma, assegura-se que uma tarefa só pode mandar uma única
mensagem elementar por ciclo de \doris.

Como pode ser observado na figura \ref{fig:SendElem}, a ação \txtla{SendElem} altera
os valores dos campos \txtla{macTimer} e \txtla{medium} da variável \txtla{Shared} e
\txtla{elem} da variável \txtla{History}.  Estas alterações globais têm o
seguinte significado:

\begin{enumerate}
\item O valor $\delta$ é atribuido ao temporizador \txtla{macTimer} para representar
  o tempo durante o qual o meio será ocupado pela transmissão da mensagem elementar
  enviada.
\item A mensagem elementar enviada, cujo identificador é $i$, é do tipo ``hard'' e
  carrega a lista de reservas \txtla{resSet}, armazenada no campo \txtla{medium}.
\item O contador $elem$ é incrementado para indicar que uma mensagem elementar
  foi enviada.
\end{enumerate}

Nota-se que a lista de reserva \txtla{resSet} é definida, na cláusula do segundo
\textsc{let}, pela função \txtla{reservation ( i )}. Esta função é apresentada logo
a seguir, na figura \ref{fig:reservation}.

Finalmente, para todas as tarefas, os campos \txtla{res} e \txtla{cons} da variável
\txtla{TaskState[i]} são atualizados.

\begin{enumerate}
\item A lista de reservas da tarefa $T[i]$ é atualizada, de acordo com a lista
  de reservas \txtla{resSet} enviada.
\item O contador \txtla{cons} é redefinido ao valor 1. Este contador é
  utilizado para criar um mecanismo de tolerância a falhas de omissão, como explicado
  a seguir.
\end{enumerate}

O contador \txtla{cons} contabiliza o número de mensagens críticas recebidas por uma
tarefa $T$ entre duas emissões consecutivas de mensagens elementares por esta
tarefa.  Cada vez que uma mensagem elementar é recebida, \txtla{cons} é
incrementado. Portanto, quando uma tarefa está em posse do bastão circulante num
\ing{slot} \ES, ela pode detectar se uma falha de omissão ocorreu desde seu último
\ES: se \txtla{cons} for menor que \txtla{nTask}, $T$ deixou de receber pelo menos
uma das mensagens elementares eventualmente enviadas nos \txtla{nTask} prévios
\ing{chip}. Neste caso, diz-se que $T$ está inconsistente. Senão \txtla{\;cons \.{=}
  nTask} indica que não houve falhas de omissão e $T$ está consistente.

\begin{tlafig}
\begin{tla}
reservation(i) ==
      IF TaskState[i].cons = nTask
      THEN { j \in Task: TaskState[i].res[j] = -1 }
      ELSE { ( ( (i - 1) + (nTask - 1) )  %  nTask ) + 1 }
\end{tla}
\begin{tlatex}
\@x{ reservation ( i ) \.{\defeq}}%
\@x{\@s{24.59} {\IF} TaskState [ i ] . cons \.{=} nTask}%
 \@x{\@s{24.59} \.{\THEN} \{ j \.{\in} Task \.{:} TaskState [ i ] . res [ j ]
 \.{=} \.{-} 1 \}}%
 \@x{\@s{24.59} \.{\ELSE} \{ ( ( ( i \.{-} 1 ) \.{+} ( nTask \.{-} 1 ) )
 \@s{4.1} \.{\%}\@s{4.1} nTask ) \.{+} 1 \}}%
\end{tlatex}
\tlacaption{A função $reservation$ \label{fig:reservation}}
\end{tlafig}

A função de reserva \txtla{reservation ( i )}, utilizada para definir
\txtla{resSet}, na ação da figura \ref{fig:SendElem}, é apresentada na figura
\ref{fig:reservation}. Esta função define a lista de reservas realizadas pela tarefa $T[i]$
para os \txtla{nTask} próximos \ing{chips}.  Sua definição depende da
necessidade de cada tarefa em largura de banda extra.  A função utilizada aqui
assume que todas as tarefas em estado consistente querem reservar todos os
\ing{slots} ainda não reservadas. Observa-se que a definição desta lista é diferente
se uma tarefa estiver em estado inconsistente. Nesta caso, é importante ressaltar que
a tarefa $T[i]$ ainda pode reservar o \ing{slot} \RS{} do \ing{chip} $i$ do próximo ciclo,
pois nenhuma outra tarefa pôde ainda ter reservado este \ing{slot}.

A tupla \txtla{TaskState[i].res} armazena a visão das reservas da tarefa
\txtla{T[i]} para os \txtla{nTask} próximos \ing{chips}. Na ação da figura
\ref{fig:SendElem}, a visão de \txtla{T[i]} é atualizada de acordo com as reservas
presentes na lista $resSet$ enviada por $T[i]$.  Se a lista $resSet$ contiver o
elemento $j$, então \txtla{TaskState[i].res[j]} recebe o valor $i$, indicando que
\RS{} do próximo \ing{chip} no qual \txtla{chipCount} valerá $j$ é reservado por
\txtla{T[i]}. Senão, \txtla{TaskState[i].res[j]} conserva o seu valor anterior
(\txtla{@ [ j ]}).

\act{SendRese} Esta ação, apresentada na figura \ref{fig:SendRese}, descreve as
regras que regem a emissão de uma mensagem de reserva.

\begin{tlafig} 
\begin{tla}
SendRese(T) ==
      /\ Shared.medium = {}
      /\ Shared.chipTimer = delta
      /\ LET i == taskId(T)
         IN /\ TaskState[i].res[Shared.chipCount] = i
            /\ Shared' = [ Shared EXCEPT 
                   !.macTimer = delta, 
                   !.medium = { [ id |-> i, type |-> "hard", res |-> {-1} ] } ]
            /\ TaskState' = [ j \in Task |-> [ TaskState[j] EXCEPT 
                   !.res[Shared.chipCount] = -1 ] ]
            /\ History' = [ History EXCEPT !.elem = @ + 1 ]
            /\ UNCHANGED ProcState               
\end{tla}
\begin{tlatex}
\@x{ SendRese ( T ) \.{\defeq}}%
\@x{\@s{24.59} \.{\land} Shared . medium \.{=} \{ \}}%
\@x{\@s{24.59} \.{\land} Shared . chipTimer \.{=} delta}%
\@x{\@s{24.59} \.{\land} \.{\LET} i \.{\defeq} taskId ( T )}%
 \@x{\@s{37.93} \.{\IN} \.{\land} TaskState [ i ] . res [ Shared . chipCount ]
 \.{=} i}%
\@x{\@s{60.30} \.{\land} Shared \.{'} \.{=} [ Shared {\EXCEPT}}%
\@x{\@s{90.03} ! . macTimer \.{=} delta ,\,}%
 \@x{\@s{90.03} ! . medium \.{=} \{ [ id \.{\mapsto} i ,\, type
 \.{\mapsto}\@w{hard} ,\, res \.{\mapsto} \{ \.{-} 1 \} ] \} ]}%
 \@x{\@s{60.30} \.{\land} TaskState \.{'} \.{=} [ j \.{\in} Task \.{\mapsto} [
 TaskState [ j ] {\EXCEPT}}%
\@x{\@s{90.03} ! . res [ Shared . chipCount ] \.{=} \.{-} 1 ] ]}%
 \@x{\@s{60.30} \.{\land} History \.{'} \.{=} [ History {\EXCEPT} ! . rese
 \.{=} @ \.{+} 1 ]}%
 \@x{\@s{60.30} \.{\land} {\UNCHANGED} ProcState }%
\end{tlatex}
\tlacaption{A ação $SendRese$ \label{fig:SendRese}}
\end{tlafig} 

Os dois primeiros guardas estabelecem que uma tarefa $T$ pode enviar uma mensagem
\linebreak de reserva se: (i) o meio está livre (\txtla{Shared .medium \.{=} \{
  \}}); e (ii) o \ing{slot} de reserva \RS{} \linebreak está começando
(\txtla{Shared .chipTimer \.{=} delta }). A construção ``\txtla{\.{\LET} \ldots\;
  \textsc{in}}'' define o índice $i$ \linebreak da tarefa $T$ (tal que \txtla{ T
  \.{=} T [ i ] }) para o qual a ação \txtla{SendRese} é verdadeira e o guarda
\linebreak \txtla{TaskState [ i ] . res [ Shared . chipCount ] \.{=} i} garante que
a tarefa $T[i]$ tem uma reserva para o \ing{slot} \RS{} deste \ing{chip}. Em
seguida, os valores dos campos \txtla{macTimer} e \txtla{medium} da variável
\txtla{Shared}, os campos \txtla{res}, \txtla{cons} da variável \txtla{TaskState[i]}
e o campo \txtla{rese} da variável \txtla{History}, são atualizados:

\begin{enumerate}
\item O valor $\delta$ é atribuído ao temporizador \txtla{macTimer} para representar
  o tempo durante o qual o meio será ocupado pela transmissão da mensagem de reserva
  enviada.
\item \txtla{medium} armazena a mensagem de reserva enviada, cujo identificador é
  $i$ e o tipo é ``hard''.  No caso das mensagens de reservas, atribui-se o valor
  arbitrário ``\txtla{\{ - 1 \}}'' para o campo $res$. Desta forma, mensagens de
  reserva podem sempre ser diferenciadas de mensagens elementares. Tal utilização do
  campo $res$ não compromete o mecanismo de reserva, pois mensagens de reserva não
  podem reservar \ing{slots}.
\item A lista de reservas da tarefa $T[i]$ é atualizada, redefinindo o valor de 
  \linebreak\txtla{TaskState [ i ] . res [ Shared . chipCount ] } para $-1$, indicando que 
  a tarefa $i$ consumiu a reserva que ela tinha para o \ing{slot} \RS{} deste \ing{chip}.
\item O contador $elem$ é incrementado para indicar que uma mensagem elementar
  foi enviada.
\end{enumerate}

Um situação possível, porém não descrita pela ação \txtla{SendRese}, ocorre quando
nenhuma tarefa tem reserva para o \ing{slot} \RS{} do \ing{chip}. Este cenário, no
qual nenhuma mensagem é enviada durante \RS, é contemplado na ação \txtla{NextTick}
(ver figura \ref{fig:NextTick}).

\act{RecvHard} Esta ação, apresentada na figura \ref{fig:RecvHard}, descreve as
regras que regem a recepção de uma mensagem crítica.

\begin{tlafig}
\begin{tla}
RecvHard( m ) ==
      /\ m.type = "hard"    
      /\ Shared.macTimer = 0
      /\ Shared' = [ Shared EXCEPT !.medium = {} ]
      /\ LET noRecvSet == IF Shared.chipCount = 2 THEN {m.id, 3} ELSE {m.id}
         IN TaskState' =
                [ i \in noRecvSet |-> TaskState[i] ] @@
                [ i \in Task \ noRecvSet |-> [ TaskState[i] EXCEPT
                           !.msg = Append( @, m),                            
                           !.execTimer = IF Len( TaskState[i].msg ) = 0 THEN pi ELSE @,
                           !.cons = IF m.res # {-1} THEN @ + 1 ELSE @,
                           !.res = IF m.res = {-1}
                                   THEN [ j \in Task |-> IF j = m.id THEN -1 ELSE @[j] ]
                                   ELSE [ j \in Task |-> IF j \in m.res THEN m.id ELSE @[j] ] ] ] 
      /\ UNCHANGED << ProcState, History >>
\end{tla}
\begin{tlatex}
\@x{ RecvHard ( m ) \.{\defeq}}%
\@x{\@s{24.59} \.{\land} m . type \.{=}\@w{hard}}%
\@x{\@s{24.59} \.{\land} Shared . macTimer \.{=} 0}%
 \@x{\@s{24.59} \.{\land} Shared \.{'} \.{=} [ Shared {\EXCEPT} ! . medium
 \.{=} \{ \} ]}%
 \@x{\@s{24.59} \.{\land} \.{\LET} noRecvSet \.{\defeq} {\IF} Shared .
 chipCount \.{=} 2 \.{\THEN} \{ m . id ,\, 3 \} \.{\ELSE} \{ m . id \}}%
\@x{\@s{37.93} \.{\IN} TaskState \.{'} \.{=}}%
 \@x{\@s{76.70} [ i \.{\in} noRecvSet \.{\mapsto} TaskState [ i ] ]
 \.{\,@@\,}}%
 \@x{\@s{76.70} [ i \.{\in} Task \.{\,\backslash\,} noRecvSet \.{\mapsto} [
 TaskState [ i ] {\EXCEPT}}%
\@x{\@s{112.86} ! . msg \.{=} Append ( @ ,\, m ) ,\,}%
 \@x{\@s{112.86} ! . execTimer \.{=} {\IF} Len ( TaskState [ i ] . msg ) \.{=}
 0 \.{\THEN} pi \.{\ELSE} @ ,\,}%
 \@x{\@s{112.86} ! . cons \.{=} {\IF} m . res \.{\neq} \{ \.{-} 1 \} \.{\THEN}
 @ \.{+} 1 \.{\ELSE} @ ,\,}%
\@x{\@s{112.86} ! . res \.{=} {\IF} m . res\@s{0.52} \.{=} \{ \.{-} 1 \}}%
 \@x{\@s{150.74} \.{\THEN} [ j \.{\in} Task \.{\mapsto} {\IF} j \.{=} m . id
 \.{\THEN} \.{-} 1 \.{\ELSE} @ [ j ] ]}%
 \@x{\@s{150.74} \.{\ELSE} [ j \.{\in} Task \.{\mapsto} {\IF} j \.{\in} m .
 res \.{\THEN} m . id \.{\ELSE} @ [ j ] ] ] ]}%
 \@x{\@s{24.59} \.{\land} {\UNCHANGED} {\langle} ProcState ,\, History
 {\rangle}}%
\end{tlatex}
\tlacaption{A ação $RecvHard$ \label{fig:RecvHard}}
\end{tlafig} 

É importante lembrar que esta ação só é habilitada se o guarda \txtla{\E\, m \.{\in}
  Shared . medium} for satisfeito assim como foi visto na ação \txtla{Next},
apresentada na figura \ref{fig:Next}.  De fato, a recepção de uma mensagem, quer
seja ela crítica ou não, requer que exista uma mensagem no meio para ser recebida. Os
demais guardas contidos na ação \txtla{RecvHard} garantem que a mensagem seja crítica
(\txtla{m . type \.{=}''\textsf{hard}''}) e que sua transmissão tenha terminado
(\txtla{Shared . macTimer \.{=} 0}).

A construção ``\textsc{except}'' é utilizada para atualizar o estado do meio \linebreak
(\txtla{Shared \.{'} \.{=} [ Shared \EXCEPT ! .  medium \.{=} \{ \}
  ]}). Finalmente, para representar a possibilidade de falhas de omissão,
distingui-se duas possibilidades para a atualização do estado das tarefas.  A
primeira usa a construção ``\txtla{LET \ldots IN}'' para definir o conjunto
$noRecvSet$ das tarefas que não recebem a mensagem $m$. Além da tarefa emissora
($T[m.id]$), tarefas vítimas de falhas de omissão são incluídas neste conjunto. No
exemplo da figura \ref{fig:RecvHard}, é o caso de $T[3]$ no segundo \ing{chip} de
cada ciclo. Na segunda possibilidade, o operador TLA+ \txtla{ \.{\,@@\,}} é
utilizado para construir a tupla \txtla{TaskState'} a partir das duas tuplas
mapeadas pelos conjuntos complementares \txtla{noRecvSet} e \txtla{Task
  \.{\,\backslash\,} noRecvSet}. A primeira destas tuplas corresponde às tarefas que
não recebem $m$ e para quais, portanto, \txtla{TaskState} não é alterado. A segunda
corresponde às tarefas que recebem $m$. Para estas, os campos da variável
\txtla{TaskState[i]} são atualizados da seguinte maneira:

\begin{enumerate}
\item A mensagem $m$ é armazenada na lista $msg$ de mensagens para serem processadas;
\item Se a lista de mensagem $msg$ é vazia, o temporizador \txtla{execTimer}
  é definido para o valor $\pi$ para representar o início do processamento da mensagem
  pela tarefa $i$. Senão, ele é mantido constante.
\item Se $m$ é uma mensagem elementar, (\txtla{m . res \.{\neq} \{ \.{-} 1 \} }), o
  contador \txtla{cons} é incrementado. Este contador é incrementado a cada recepção
  de uma mensagem elementar. A omissão de uma recepção implica, portanto, que
  $cons$ não é incremento. Neste caso, a tarefa é dita inconsistente e sua
  capacidade de reserva é limitada, assim como foi visto na descrição da ação
  \ref{fig:SendElem};
\item Se $m$ é uma mensagem de reserva, a reserva do \ing{slot} \RS{} atual feita pela
  tarefa emissora $T[m.id]$, é cancelada, redefinindo o seu valor para $-1$ (se $m$
  chegou, é porque $T[m.id]$ consumiu sua reserva).  Senão, $m$ é uma mensagem
  elementar. Neste caso, cada lista de reserva é atualizada de acordo com as
  reservas carregadas por $m$.
\end{enumerate}

\subsection{O anel não-crítico}
\label{sec:anelNaoCrit}

No anel não-crítico, a circulação do bastão é organizada em função da comunicação
observada. A cada mensagem não-crítica recebida, um processo $P[j]$ incrementa seu
contador \txtla{token}. Quando sua vez chega, isto é, quando \txtla{ProcState[ j
  ].token \.{=} j}, $P[j]$ transmite uma mensagem, quer seja da sua fila de mensagem
em espera, ou uma mensagem de tamanho mínimo para consumir o bastão.

O anel não-crítico é especificado por duas ações principais \txtla{SendSoft}
e \txtla{RecvSoft}, cujas descrições são objetos desta seção.

\act{SendSoft} Esta ação, apresentada na figura \ref{fig:SendSoft}, descreve as
regras que regem a emissão de uma mensagem não-crítica.

\begin{tlafig}
\begin{tla}
SendSoft(P) ==
      /\ 2 * delta \leq Shared.chipTimer
      /\ Shared.chipTimer \leq deltaChip
      /\ Shared.medium = {}
      /\ LET i == procId(P)
             lenTX == lenMsg(i)
             d == Shared.chipTimer + lenTX
             NoMsg == i \in Failed \/ d > deltaChip
         IN /\ i = ProcState[i].token
            /\ Shared' = [ Shared EXCEPT
                   !.macTimer = IF NoMsg THEN Infinity ELSE lenTX,
                   !.medium = IF NoMsg THEN @ ELSE { [ id |-> i, type |-> "soft" ] } ]
            /\ ProcState' = [ ProcState EXCEPT
                   ![i].token = IF NoMsg THEN @ ELSE ( @  %  nProc) + 1,
                   ![i].count = IF NoMsg THEN @ ELSE @ + 1,
                   ![i].list = IF d > deltaChip \/ @ = << >> THEN @ ELSE Tail(@) ]
            /\ UNCHANGED << TaskState, History >>
\end{tla}
\begin{tlatex}
\@x{ SendSoft ( P ) \.{\defeq}}%
\@x{\@s{24.59} \.{\land} 2 \.{*} delta \.{\leq} Shared . chipTimer}%
\@x{\@s{24.59} \.{\land} Shared . chipTimer \.{\leq} deltaChip}%
\@x{\@s{24.59} \.{\land} Shared . medium \.{=} \{ \}}%
\@x{\@s{24.59} \.{\land} \.{\LET} i \.{\defeq} procId ( P )}%
\@x{\@s{60.30} lenTX \.{\defeq} lenMsg ( i )}%
\@x{\@s{60.30} d \.{\defeq} Shared . chipTimer \.{+} lenTX}%
\@x{\@s{60.30} NoMsg \.{\defeq} i \.{\in} Failed \.{\lor} d \.{>} deltaChip}%
\@x{\@s{37.93} \.{\IN} \.{\land} i \.{=} ProcState [ i ] . token}%
\@x{\@s{60.30} \.{\land} Shared \.{'} \.{=} [ Shared {\EXCEPT}}%
 \@x{\@s{90.03} ! . macTimer \.{=} {\IF} NoMsg \.{\THEN} Infinity \.{\ELSE}
 lenTX ,\,}%
 \@x{\@s{90.03} ! . medium \.{=} {\IF} NoMsg \.{\THEN} @ \.{\ELSE} \{ [ id
 \.{\mapsto} i ,\, type \.{\mapsto}\@w{soft} ] \} ]}%
\@x{\@s{60.30} \.{\land} ProcState \.{'} \.{=} [ ProcState {\EXCEPT}}%
 \@x{\@s{90.03} ! [ i ] . token \.{=} {\IF} NoMsg \.{\THEN} @ \.{\ELSE} ( @
 \@s{4.1} \.{\%}\@s{4.1} nProc ) \.{+} 1 ,\,}%
 \@x{\@s{90.03} ! [ i ] . count \.{=} {\IF} NoMsg \.{\THEN} @ \.{\ELSE} @
 \.{+} 1 ,\,}%
 \@x{\@s{90.03} ! [ i ] . list \.{=} {\IF} d \.{>} deltaChip \.{\lor} @ \.{=}
 {\langle} {\rangle} \.{\THEN} @ \.{\ELSE} Tail ( @ ) ]}%
 \@x{\@s{60.30} \.{\land} {\UNCHANGED} {\langle} TaskState ,\, History
 {\rangle}}%
\end{tlatex}
\tlacaption{A ação $SendSoft$ \label{fig:SendSoft}}
\end{tlafig}

Os dois primeiros guardas da ação \txtla{SendSoft} descrevem a isolamento temporal
entre o anel não-crítico e o anel não crítico pelo TDMA. Ou seja, uma janela \SW{}
só acontece quando \txtla{ 2 \.{*} delta \.{\leq} Shared . chipTimer \.{\leq}
  deltaChip}. O terceiro guarda garante que o meio está livre (\txtla{\; Shared
  .medium \.{=} \{ \}}). Em seguida, a construção ``\txtla{\.{\LET} \ldots\;
  \textsc{in}}'' define várias constantes locais:

\begin{enumerate}
\item $i$ é o índice do processo $p$ (tal que \txtla{ P \.{=} P [ i ] }) para o qual a
  ação é verdadeira;
\item $lenTX$ é o tamanho da mensagem a ser enviada. Se a lista \txtla{ProcState [ i
    ] . list} for vazia, a função \txtla{lenMsg( i )}, apresentada na figura
  \ref{fig:lenMsgFail}, define o tamanho mínimo $delta$ para a mensagem a ser
  enviada. Senão, o tamanho da primeira mensagem na lista é utilizado (\txtla{Head (
    ProcState [ i ] . list ) . txTime}).
\item $d$ é o tempo de transmissão da mensagem.
\item $NoMsg$ é uma disjunção verdadeira se o processo \txtla{P [ i ]} não emite sua
  mensagem. Isto ocorre se \txtla{P [ i ]} está falho (\txtla{ i \.{\in} Failed}) ou
  se não houver tempo suficiente na atual janela \SW{} para que $P[i]$ envie sua
  mensagem (\txtla{ d \.{>} deltaChip}). 
\end{enumerate}


Observa-se que o conjunto $Failed$ dos processos falhos é definido arbitrariamente
de acordo com o cenário de verificação de falhas desejado.  No exemplo da figura
\ref{fig:lenMsgFail}, uma falha acontece no processo 3 nos \ing{chips} 2, 3, 4 e 5,
e no processo 5 nos \ing{chips} 3 e 5.  Lembrar que o modelo de falhas, apresentado
na seção \ref{sec:dorisModel}, considera apenas falhas silenciosas. 

\begin{tlafig}
\begin{tla}
Failed == CASE Shared.chipCount = 2 -> { 3 }
	      []  Shared.chipCount \in {3, 4} -> { 3, 5 }
	      []  Shared.chipCount = 5 -> { 3, 5 }
	      []  Shared.chipCount \in { 1 } \cup 6..nTask -> { }

lenMsg(i) ==
      IF ProcState[i].list # << >> THEN Head(ProcState[i].list).txTime ELSE delta
\end{tla}
\begin{tlatex}
 \@x{ Failed \.{\defeq} {\CASE} Shared . chipCount \.{=} 2 \.{\rightarrow} \{ 3 \}}%
 \@x{\@s{70.26} {\Box}\@s{4.1} Shared . chipCount \.{\in} \{ 3 ,\, 4 \}
 \.{\rightarrow} \{ 3 ,\, 5 \}}%
 \@x{\@s{70.26} {\Box}\@s{4.1} Shared . chipCount \.{=} 5 \.{\rightarrow} \{ 3 ,\, 5 \}}%
 \@x{\@s{70.26} {\Box}\@s{4.1} Shared . chipCount \.{\in} \{ 1 \} \.{\cup} 6
 \.{\dotdot} nTask \.{\rightarrow} \{ \}}%
\par\vspace{8.0pt}%
\@x{ lenMsg ( i ) \.{\defeq}}%
 \@x{\@s{36.76} {\IF} ProcState [ i ] . list \.{\neq} {\langle} {\rangle}
 \.{\THEN} Head ( ProcState [ i ] . list ) . txTime \.{\ELSE} delta}%
\end{tlatex}
\tlacaption{O conjunto $Failed$ e a função $lenMsg ( i )$ \label{fig:lenMsgFail}}
\end{tlafig}

Depois do último guarda \txtla{Shared .chipCount \.{=} i } que garante que $P[i]$
esteja em posse do bastão circulante, as ações envolvendo as variáveis $Shared$ e
$ProcState$ são especificadas. Distingui-se dois casos, C1 e C2 dependendo se $P[i]$
envie sua mensagem ($NoMsg$ é falso), ou não ($NoMsg$ verdadeiro):

\begin{enumerate}
\item
  \begin{itemize}
  \item[] C1: O valor $lenTX$ é atribuído ao temporizador \txtla{macTimer} para
  representar o tempo durante o qual o meio será ocupado pela transmissão da
  mensagem não-crítica.
  \item[] C2:  O temporizador \txtla{macTimer} é desativado (\txtla{ macTimer \.{=}
      Infinity }).
  \end{itemize}
\item 
  \begin{itemize}
  \item[] C1: \txtla{medium} armazena a mensagem não-crítica enviada, cujo
    identificador é $i$ e o tipo é ``soft''.
  \item[] C2: O meio permanece livre.
  \end{itemize}  
\item
  \begin{itemize}
  \item[] C1: O contador $token$ é incrementado, pois $P[i]$ consumiu sua vez.
  \item[] C2: O contador $token$ não é incrementado.
  \end{itemize}
\item 
  \begin{itemize}
  \item[] C1: O contador $count$, utilizado para contabilizar quantas mensagens são enviadas
  durante uma janela \SW, é incrementado.
  \item[] C2:  $count$ não é incrementado.
  \end{itemize}
\end{enumerate}

Finalmente, a lista de mensagem de $P[i]$ é atualizada. Em ambos os casos, seja com
$P[i]$ falho ou enviado uma mensagem, a primeira mensagem da lista, se esta não
estiver vazia, é retirada. Senão, $P[i]$ não enviou sua mensagem porque faltava
tempo na janela \SW{}. Neste caso, a lista permanece a mesma.

Observar que tanto falhas como omissões por falta de tempo são representadas, na
ação \txtla{SendSoft}, pela desativação do temporizador \txtla{macTimer}, 
atribuindo-lhe o valor infinito. Ademais, a ausência de mensagem, até o fim da janela
\SW{}, implica que o bastão permanece com o processo $P[i]$ até a próxima janela
\SW{}.


\act{RecvSoft} Esta ação, apresentada na figura \ref{fig:RecvSoft}, descreve as
regras que regem a recepção de uma mensagem não-crítica.

\begin{tlafig}
\begin{tla}
RecvSoft( m ) ==
      /\ m.type = "soft"
      /\ Shared.macTimer = 0
      /\ Shared' = [ Shared EXCEPT !.medium = {} ]
      /\ ProcState' = [ j \in {m.id} |-> ProcState[j] ] @@
                      [ j \in Proc \ {m.id} |-> [ ProcState[j] EXCEPT
                                                      !.token = ( @ % nProc) + 1,
                                                      !.count = @ + 1 ] ]
      /\ UNCHANGED << TaskState, History >>
\end{tla}
\begin{tlatex}
\@x{ RecvSoft ( m ) \.{\defeq}}%
\@x{\@s{24.59} \.{\land} m . type \.{=}\@w{soft}}%
\@x{\@s{24.59} \.{\land} Shared . macTimer \.{=} 0}%
 \@x{\@s{24.59} \.{\land} Shared \.{'} \.{=} [ Shared {\EXCEPT} ! . medium
 \.{=} \{ \} ]}%
 \@x{\@s{24.59} \.{\land} ProcState \.{'} \.{=} [ j \.{\in} \{ m . id \}
 \.{\mapsto} ProcState [ j ] ] \.{\,@@\,}}%
 \@x{\@s{106.34} [ j \.{\in} Proc \.{\,\backslash\,} \{ m . id \} \.{\mapsto}
 [ ProcState [ j ] {\EXCEPT}}%
\@x{\@s{239.45} ! . token\@s{0.54} \.{=} ( @\@s{4.1} \.{\%}\@s{4.1} nProc ) \.{+} 1 ,\,}%
\@x{\@s{239.45} ! . count \.{=} @ \.{+} 1 ] ]}%
 \@x{\@s{24.59} \.{\land} {\UNCHANGED} {\langle} TaskState ,\, History
 {\rangle}}%
\end{tlatex}
\tlacaption{A ação $RecvSoft$ \label{fig:RecvSoft}}
\end{tlafig} 

Assim como para a ação \txtla{RecvHard} (ver figura \ref{fig:RecvHard}), o primeiro
guarda desta ação, \linebreak\txtla{\E\, m \.{\in} Shared . medium}, aparece na
formulação da ação \txtla{Next} (ver figura \ref{fig:Next}). Os dois demais guardas
da ação \txtla{RecvSoft} garantem que a mensagem a ser é recebida é não-crítica
(\txtla{m . type \.{=}''\textsf{soft}''}) e que sua transmissão já tenha terminado
(\txtla{Shared . macTimer \.{=} 0}).  Em seguida, o estado do meio é atualizado
(\txtla{Shared \.{'} \.{=} [ Shared {\EXCEPT} ! .  medium \.{=} \{ \} ]}) e a
variável \txtla{ProcState} é atualizada, distinguindo dois casos. Se a mensagem foi
enviada pelo próprio processo (\txtla{ j \.{\in} \{ m . id \}}), $ProcState[j]$ não
é alterado. Senão, os campos $token$ e $count$ são incrementados, indicando que o
bastão deve ir para o próximo processo do anel não-crítico e que mais uma mensagem
não-crítica foi recebida.

\subsection{A representação temporal}
\label{sec:AcaoTick}

A ação \emph{Tick} organiza o progresso do protocolo e é composta de duas ações
principais: \txtla{NextTick}, que incrementa o tempo por passos discretos, e
\txtla{NextChip}, que define a transição entre \ing{chips} consecutivos.

\act{NextTick} Esta ação, apresentada na figura \ref{fig:NextTick}, organiza o fluxo
linear do tempo durante a janela temporal de um \ing{chip}.

\begin{tlafig}
\begin{tla}
\begin{tla}
NextTick ==
      LET noRese == /\ Shared.medium = {}
                    /\ Shared.chipTimer = delta
                    /\ \A i \in Task : TaskState[i].res[Shared.chipCount] # i
          tmp == min( { TaskState[i].execTimer : i \in Task } \cup 
                      { deltaChip - Shared.chipTimer } )
          d == IF noRese THEN min( { delta, tmp } ) ELSE min( { Shared.macTimer, tmp } )
      IN /\ d > 0
         /\ Shared' = [ Shared EXCEPT
                !.chipTimer = @ + d,
                !.macTimer = IF noRese 
                             THEN @
                             ELSE IF @ = Infinity THEN Infinity  ELSE @ - d ]
         /\ TaskState' = [ i \in Task |-> [ TaskState[i] EXCEPT
                !.msg = IF TaskState[i].execTimer - d = 0  THEN Tail( @ ) ELSE @,
                !.execTimer = IF @ - d = 0
                              THEN IF Len( TaskState[i].msg ) > 1 THEN pi ELSE Infinity
                              ELSE IF @ = Infinity THEN @ ELSE @ - d ] ]
         /\ UNCHANGED << ProcState, History >>
\end{tla}
\begin{tlatex}
\@x{ NextTick \.{\defeq}}%
 \@x{\@s{24.59} \.{\LET} noRese \.{\defeq} \.{\land} Shared . medium \.{=} \{
 \}}%
\@x{\@s{106.48} \.{\land} Shared . chipTimer \.{=} delta}%
 \@x{\@s{106.48} \.{\land} \A\, i \.{\in} Task \.{:} TaskState [ i ] . res [
 Shared . chipCount ] \.{\neq} i}%
 \@x{\@s{46.96} tmp \.{\defeq} min ( \{ TaskState [ i ] . execTimer \.{:} i
 \.{\in} Task \} \.{\cup}}%
\@x{\@s{114.93} \{ deltaChip \.{-} Shared . chipTimer \} )}%
 \@x{\@s{46.96} d \.{\defeq} {\IF} noRese \.{\THEN} min ( \{ delta ,\, tmp \}
 ) \.{\ELSE} min ( \{ Shared . macTimer ,\, tmp \} )}%
\@x{\@s{24.59} \.{\IN} \.{\land} d \.{>} 0}%
\@x{\@s{46.96} \.{\land} Shared \.{'} \.{=} [ Shared {\EXCEPT}}%
\@x{\@s{76.70} ! . chipTimer \.{=} @ \.{+} d ,\,}%
\@x{\@s{76.70} ! . macTimer \.{=} {\IF} noRese}%
\@x{\@s{153.26} \.{\THEN} @}%
 \@x{\@s{153.26} \.{\ELSE} {\IF} @ \.{=} Infinity \.{\THEN} Infinity\@s{4.1}
 \.{\ELSE} @ \.{-} d ]}%
 \@x{\@s{46.96} \.{\land} TaskState \.{'} \.{=} [ i \.{\in} Task \.{\mapsto} [
 TaskState [ i ] {\EXCEPT}}%
 \@x{\@s{76.70} ! . msg \.{=} {\IF} TaskState [ i ] . execTimer \.{-} d \.{=}
 0\@s{4.1} \.{\THEN} Tail ( @ ) \.{\ELSE} @ ,\,}%
\@x{\@s{76.70} ! . execTimer \.{=} {\IF} @ \.{-} d \.{=} 0}%
 \@x{\@s{153.26} \.{\THEN} {\IF} Len ( TaskState [ i ] . msg ) \.{>} 1
 \.{\THEN} pi \.{\ELSE} Infinity}%
 \@x{\@s{153.26} \.{\ELSE} {\IF} @ \.{=} Infinity \.{\THEN} @ \.{\ELSE} @
 \.{-} d ] ]}%
 \@x{\@s{46.96} \.{\land} {\UNCHANGED} {\langle} ProcState ,\, History
 {\rangle}}%
\end{tlatex}
\tlacaption{A ação $NextTick$ \label{fig:NextTick}}
\end{tlafig}

Assim como foi visto nas apresentações do anel crítico e não-crítico, as cinco ações
principais de emissão e recepção de mensagens só podem acontecer se o temporizador
\txtla{ macTimer} for nulo. Nas ações de emissão, esta condição é uma conseqüência
do guarda \txtla{Shared . medium \.{=} \{ \}}, pois, se o meio estiver livre, a
última mensagem presente no meio foi recebida e nenhuma nova mensagem foi
enviada. Se o campo $macTimer$ não for nulo, todas as ações de emissão e recepção
são desabilitadas, assim como a ação principal \txtla{NextChip}, apresentada na
figura \ref{fig:NextChip}, pois esta ação também tem o guarda \txtla{Shared . medium
  \.{=} \{ \}}. Assim, a ação \txtla{NextTick} deve ser habilitada, a não ser que
uma situação de bloqueio tenha sido atingida. Resumidamente, se nenhum temporizador
é nulo, então o tempo deve progredir.

Na ação $NextTick$, o incremento do tempo é definido com base nos valores dos
temporizadores, de tal forma que o progresso temporal ocorra em intervalos de tempo
maiores possíveis.  O valor deste incremento, denotado $d$, corresponde ao
intervalo de tempo necessário para que uma das cinco ações de emissão ou recepção,
ou a ação $NextChip$ seja habilitada.  Para determinar o valor de $d$, distinguem-se
os temporizadores crescentes e os temporizadores decrescentes.

No caso de $chipTimer$, o único temporizador crescente, o guarda associado é
$chipTimer = deltaChip$ da ação $NextChip$ (c.f. figura \ref{fig:NextChip}).  O
valor de $d$ correspondente, que torna este guarda verdadeiro, é portanto
\txtla{deltaChip \.{-} Shared . chipTimer}. Este valor corresponde ao tempo durante
o qual o meio permanece livre, antes de o \ing{chip} terminar.  Para os temporizadores
decrescentes, eles apenas habilitam uma ação quando forem nulos. O incremento de
tempo $d$ correspondente a um temporizador $t$ decrescente, valendo $x$, é portanto
este valor $x$.

Determinar $d$ consiste, portanto, em achar o mínimo entre os temporizadores
decrescentes e o valor \txtla{deltaChip \.{-} Shared . chipTimer}. Isto é realizado
pela construção ``\txtla{\.{\LET} \ldots\; \textsc{in}}'', utilizando a função $min(
S )$ (não mostrada aqui) que acha o valor mínimo num conjunto $S$ de valores. Para
representar a possibilidade que nenhuma mensagem seja enviada num \ing{slot} \RS{}
de um \ing{chip}, a construção ``\txtla{\.{\LET} \ldots\; \textsc{in}}'' também
define o predicado $noRese$. Os dois primeiros guardas deste predicado determinam o
início de \RS{} e o terceiro garante que nenhuma tarefa tenha uma reserva para este
\ing{slot}. Em seguida, a constante temporária $tmp$ é definida para armazenar o
menor valor entre os temporizadores decrescentes \txtla{execTimer} e o tempo
que falta para terminar o \ing{chip}.  Finalmente, a constante $d$ é definida. Se
$noRese$ for verdadeiro, o conjunto de busca do menor valor contém $tmp$ e $delta$ e
não contém $macTimer$ que é nulo. Senão, o conjunto de busca contém $tmp$ e
$macTimer$.

Considere-se, então, o temporizador $t$ cujo valor $d$ foi selecionado como
incremento do tempo.  Quando este incremento é realizado pela ação \txtla{NextTick},
o valor de $t$, se for um temporizador decrescente, é redefinido para ``$0$''. No
caso de $chipTimer$, o seu valor é redefinido para $deltaChip$. Em ambos os casos, a
ação respectiva, cujo guarda é $t = 0$ ou $chipTimer = deltaChip$, é habilitada.  É
importante observar aqui, que, o uso de um valor de $d$ menor que $m$ não permitiria
habilitar nenhuma nova ação, e que apenas a ação \txtla{NextTick} continuaria sendo
habilitada. De fato, depois uma progressão de $d < m$, um temporizador decrescente
teria o valor $m - d > 0$ e $chipTimer$ teria o valor $chipTimer + d <
deltaChip$. Portanto, o mesmo temporizador continuaria sendo a cota para o
incremento do tempo, e um novo passo \txtla{NextTick} teria que acontecer, até que,
em algum momento futuro, $t$ chegasse ao valor ``$0$'' ou $chipTimer$ chegasse ao
valor $deltaChip$.

Depois de ter determinado o valor do incremento do tempo $d$, o único guarda desta
ação (\txtla{ d \.{>} 0 }) garante que, se algum temporizador for nulo, a ação
associada deve acontecer antes que o tempo seja incrementado. Em seguida, todos os
temporizadores da especificação são atualizados.

Dois casos são distinguidos na atualização de $macTimer$. Se $noRese$ é verdadeiro, \linebreak
$macTimer$ não é alterado. Senão, $macTimer$ (se não for infinito) é decrementado de
$d$.  Por fim, se o valor de $d$ não é associado ao fim do processamento de uma
mensagem, $execTimer$ (se não for infinito) é decrementado de $d$. Senão, o valor de
$d$ corresponde ao fim de processamento de uma mensagem crítica por uma tarefa
$T[i]$. Neste caso, esta mensagem deve ser retirada da lista \txtla{TaskState[i].msg} e o
temporizador $execTimer$ associado deve ser redefinido para o valor $pi$ se houver
mais alguma mensagem para ser processada. Caso contrário, este temporizador deve ser
desabilitado.

\act{NextChip} Esta ação, apresentada na figura \ref{fig:NextChip}, organiza a transição
de um \ing{chip} para o próximo, assim como o fluxo circular do tempo.

\begin{tlafig}
\begin{tla}
NextChip ==
      /\ Shared.medium = {}
      /\ Shared.chipTimer = deltaChip
      /\ LET Overflow == \E j \in Proc : Len( ProcState[j].list ) > 14
             NextCycle == Shared.chipCount' = 1
         IN  /\ Shared' = [ Shared EXCEPT
                    !.macTimer = 0, 
                    !.chipCount = (@  % nTask) + 1,
                    !.chipTimer = IF Overflow THEN -1 ELSE 0 ]
             /\ ProcState' = [ j \in Proc |-> [ ProcState[j] EXCEPT 
                    !.token = IF ProcState[j].count = 0 THEN  (@ % nProc ) + 1 ELSE @,
                    !.count = 0,
                    !.list = IF NextCycle THEN @ \o list(j) ELSE @ ] ]
             /\ IF NextCycle
                THEN History' = [ elem |-> 0, rese |-> 0 ]
                ELSE UNCHANGED History
      /\ UNCHANGED TaskState
\end{tla}
\begin{tlatex}
\@x{ NextChip \.{\defeq}}%
\@x{\@s{24.59} \.{\land}\@s{10.21} Shared . medium \.{=} \{ \}}%
\@x{\@s{24.59} \.{\land}\@s{10.21} Shared . chipTimer \.{=} deltaChip}%
 \@x{\@s{24.59} \.{\land}\@s{10.21} \.{\LET} Overflow \.{\defeq} \E\, j
 \.{\in} Proc \.{:} Len ( ProcState [ j ] . list ) \.{>} 14}%
\@x{\@s{70.51} NextCycle \.{\defeq} Shared . chipCount \.{'} \.{=} 1}%
 \@x{\@s{48.14} \.{\IN}\@s{4.1} \.{\land} Shared \.{'} \.{=} [ Shared
 {\EXCEPT}}%
\@x{\@s{104.34} ! . macTimer \.{=} 0 ,\,}%
 \@x{\@s{104.34} ! . chipCount\@s{0.89} \.{=} ( @\@s{4.1} \.{\%}\@s{4.1} nTask ) \.{+}
 1 ,\,}%
 \@x{\@s{104.34} ! . chipTimer \.{=} {\IF} Overflow \.{\THEN} \.{-} 1
 \.{\ELSE} 0 ]}%
 \@x{\@s{74.61} \.{\land} ProcState \.{'} \.{=} [ j \.{\in} Proc \.{\mapsto} [
 ProcState [ j ] {\EXCEPT}}%
 \@x{\@s{104.34} ! . token\@s{0.54} \.{=} {\IF} ProcState [ j ] . count \.{=}
 0 \.{\THEN}\@s{4.1} ( @\@s{4.1} \.{\%}\@s{4.1} nProc ) \.{+} 1 \.{\ELSE} @ ,\,}%
\@x{\@s{104.34} ! . count \.{=} 0 ,\,}%
 \@x{\@s{104.34} ! . list \.{=} {\IF} NextCycle \.{\THEN} @ \.{\circ} list ( j
 ) \.{\ELSE} @ ] ]}%
\@x{\@s{74.61} \.{\land} {\IF} NextCycle}%
 \@x{\@s{87.94} \.{\THEN} History \.{'} \.{=} [ elem \.{\mapsto} 0 ,\, rese
 \.{\mapsto} 0 ]}%
\@x{\@s{87.94} \.{\ELSE} {\UNCHANGED} History}%
\@x{\@s{24.59} \.{\land}\@s{10.21} {\UNCHANGED} TaskState}%
\end{tlatex}
\tlacaption{A ação $NextChip$ \label{fig:NextChip}}
\end{tlafig} 

Os dois guardas desta ação garantem que o meio está livre (\txtla{Shared . medium
  \.{=} \{ \}}) e que o \ing{chip} terminou (\txtla{Shared . chipTimer \.{=}
  deltaChip}). Após isso, a construção ``\txtla{\,\LET} $\ldots\;$ \textsc{in }''
define os predicados $Overflow$ e $NextCycle$. O primeiro é utilizado para detectar
se a lista de mensagens de algum processo ultrapassa um valor limite arbitrário,
definido aqui como 14. O segundo, $NextCycle$, é utilizado para caracterizar
uma mudança de ciclo de \doris.

Em seguida, as ações envolvendo as variáveis $Shared$ e $ProcState$ são
especificadas:

\begin{enumerate}
\item O valor ``$0$'' é atribuído ao temporizador \txtla{macTimer} para habilitá-lo
  novamente.
\item O contador \txtla{chipCount} é incrementado (módulo \txtla{nTask}).
\item Caso o predicado $Overflow$ seja verdadeiro, a lista de algum processo cresceu
  acima do valor limite tolerado e o valor arbitrário $-1$ é atribuído ao
  temporizador $chipTimer$ de forma a permitir a detecção do erro, como será vista
  na seção \ref{sec:verifAuto}. Caso contrário, o valor ``$0$'' é atribuído ao
  temporizador \txtla{chipTimer}, pois um novo \ing{chip} irá iniciar.
\item Se nenhuma mensagem não-crítica foi recebida durante \SW{} deste \ing{chip} 
  \linebreak (\txtla{ProcState [ i ] . count \.{=} 0}), o processo em posse do bastão
  está falho. Neste caso, o contador \txtla{token} é incrementado. Senão, seu valor é mantido
  inalterado.
\item O contador de mensagens não-críticas recebidas durante a última janela \SW{} é
  redefinido para ``$0$'', pois um novo \ing{chip} vai começar.
\item Se um novo ciclo tiver começando, o campo $list$ é redefinido para o valor \txtla{@
  \.{\circ} list ( j )}, isto é a concatenação da lista de mensagens atuais com a lista
  arbitrária $list(j)$, já utilizada na definição de $Init$ (ver figura
  \ref{fig:listFunc}). Senão, seu valor é mantido inalterado.
\end{enumerate}

Finalmente, se houver mudança de ciclo, os dois contadores $elem$ e $rese$ da
variável $History$ são redefinidos para ``$0$''.

Duas observações devem ser ressaltadas aqui. Em primeiro lugar, o valor arbitrário $-1$,
atribuído ao temporizador $chipTimer$, quando uma lista de mensagem cresce
indevidamente, permite desabilitar todas as ações da especificação. Desta forma,
garante-se a detecção imediata do erro pelo verificador de modelo TLC,  como
será visto na seção \ref{sec:verifAuto}. 

Em segundo lugar, a circularidade temporal da especificação é obtida pela
redefinição de $chipTimer$ para ``$0$'' a cada fim de \ing{chip}, juntamente com a
utilização do módulo $nTask$ no incremento de $chipCount$,  responsável pela
mudança de ciclo.

\section{Verificação automática} %Model checking}
\label{sec:verifAuto}

Para poder verificar alguns modelos finitos do sistema com o verificador de modelo
TLC \cite{Yu99}, um arquivo de configuração é utilizado. Este arquivo contém o valor
de todas as constantes do conjunto \txtla{\CONSTANTS} e a lista de propriedades
temporais a serem verificadas. Como foi visto na seção \ref{sec:consVar}, um
conjunto de valores utilizado para verificar \doriss foi, por exemplo: $nTask = 8,
nProc = 7, deltaChip = 300, delta = 6, pi = 111, maxTxTime = 122$. Os tempos de
execução para tal modelo foram bastante razoáveis, porém nenhum estudo comparativo
foi realizado com outras ferramentas.  Por exemplo, para um modelo com 17 tarefas e
14 processos, e usando cenários de falhas e de comunicação não-crítica, similares
àqueles apresentados na seção \ref{sec:dorisSpec}, TLC verificou a especificação de
\doriss e da suas propriedades temporais em menos de um minuto num processador Intel
Core Duo 2 Ghz usando a máquina virtual java com uma pilha de 512M. O código
completo da especificação e do arquivo de configuração utilizados para este teste
estão apresentados no apêndice~\ref{ap:dorisSpec}.

Após a detecção de erros de sintaxe, TLC busca possíveis situações de bloqueio
(\ing{deadlock}). Em seguida, TLC verifica se a especificação implica nas fórmulas
temporais que são listadas no arquivo de configuração. Sempre que ele detecta a
violação de uma propriedade, TLC produz um comportamento, que é um contra-exemplo
para esta propriedade, gerando uma seqüência de estados com os valores de todas as
variáveis para cada estado. A análise destes dados, chamados de rastro, é uma
ferramenta valiosa para identificar a causa do erro e corrigir o protocolo (ou a sua
especificação). O que se segue é a descrição de algumas fórmulas utilizadas para
verificar propriedades relevantes de \doris.

\act{TypeInvariance} Esta propriedade, apresentada na figura
\ref{fig:TypeInvariance}, permite verificar a invariância de tipo das variáveis, ou
seja, que uma variável permanece no domínio do seu tipo durante um comportamento que
satisfaz a especificação. Tal verificação, para cada variável da especificação,
assegura a detecção de erros óbvios. 

\begin{tlafig}
\begin{tla}
HardMsg == Seq( [ id: Task, type: {"hard"}, res: SUBSET( {-1} \cup Task ) ] )

MediumMsg == { m: m \in [ id: Proc, type: {"soft"} ] \cup
                        [ id: Task, type: {"hard"}, res: SUBSET( {-1} \cup Task ) ] }

TypeInvariance ==
      /\ Shared.chipCount \in Task
      /\ Shared.chipTimer \in 0..deltaChip
      /\ Shared.macTimer \in 0..maxTxTime \cup {Infinity}
      /\ \A m \in Shared.medium : m \in MediumMsg
      /\ ProcState \in [ Proc -> [ token : Proc, count : 0..50,
              list : {<< >>} \cup Seq( [ txTime : 0..maxTxTime ] ) ] ]
      /\ TaskState \in [ Task -> [ msg : {<< >>} \cup HardMsg, res : [ Task -> {-1} \cup Task  ], 
                                   execTimer : 0..pi \cup {Infinity}, cons :Task ] ]
\end{tla}
\begin{tlatex}
 \@x{ HardMsg \.{\defeq} Seq ( [ id \.{:} Task ,\, type \.{:} \{\@w{hard} \}
 ,\, res \.{:} {\SUBSET} ( \{ \.{-} 1 \} \.{\cup} Task ) ] )}%
\par\vspace{8.0pt}%
 \@x{ MediumMsg \.{\defeq} \{ m \.{:} m \.{\in} [ id \.{:} Proc ,\,
 type\@s{1.18} \.{:} \{\@w{soft} \} ] \.{\cup}}%
 \@x{\@s{137.77} [ id \.{:} Task ,\, type \.{:} \{\@w{hard} \} ,\, res \.{:}
 {\SUBSET} ( \{ \.{-} 1 \} \.{\cup} Task ) ] \}}%
\par\vspace{8.0pt}%
\@x{ TypeInvariance \.{\defeq}}%
\@x{\@s{24.59} \.{\land} Shared . chipCount\@s{0.89} \.{\in} Task}%
\@x{\@s{24.59} \.{\land} Shared . chipTimer \.{\in} 0 \.{\dotdot} deltaChip}%
 \@x{\@s{24.59} \.{\land} Shared . macTimer \.{\in} 0 \.{\dotdot} maxTxTime
 \.{\cup} \{ Infinity \}}%
 \@x{\@s{24.59} \.{\land} \A\, m \.{\in} Shared . medium \.{:} m \.{\in}
 MediumMsg}%
 \@x{\@s{24.59} \.{\land} ProcState \.{\in} [ Proc \.{\rightarrow} [ token
 \.{:} Proc ,\, count \.{:} 0 \.{\dotdot} 50 ,\,}%
 \@x{\@s{58.43} list \.{:} \{ {\langle} {\rangle} \} \.{\cup} Seq ( [ txTime
 \.{:} 0 \.{\dotdot} maxTxTime ] ) ] ]}%
 \@x{\@s{24.59} \.{\land} TaskState \.{\in} [ Task \.{\rightarrow} [ msg \.{:}
 \{ {\langle} {\rangle} \} \.{\cup} HardMsg ,\, res \.{:} [ Task
 \.{\rightarrow} \{ \.{-} 1 \} \.{\cup} Task\@s{4.1} ] ,\,}%
 \@x{\@s{154.30} execTimer \.{:} 0 \.{\dotdot} pi \.{\cup} \{ Infinity \} ,\,
 cons \.{:} Task ] ]}%
\end{tlatex}
\tlacaption{A propriedade $TypeInvariant$ \label{fig:TypeInvariance}}
\end{tlafig} 

Para construir os domínios de tipo das variáveis, a definição deste invariante
utiliza duas construções de TLA+, ainda não explicadas. A primeira é o uso da construção
``$[ \ldots \,:\, \ldots ]$'', para definir conjuntos. Por exemplo, \txtla{[ id \.{:} Task ]} é o
conjunto de tuplas da forma $[ id \.{\mapsto} i ]$ com $i \in Task$, ou seja, \txtla{[ id
  \.{:} Task ] == \{ [ id \.{\mapsto} i ] : i \.{\in} Task \} }, expressão na qual o símbolo ``$\,:\,$''
tem agora o significado ``tal que'' usual em matemática. A segunda é o uso do símbolo
$\rightarrow$ para definir conjuntos de funções. Por exemplo, \txtla{[ A
  \rightarrow B ]} é o conjunto das funções cujo domínio é $A$ e a imagem é $B$.

Uma vez especificados os conjuntos de variação para cada variável, o invariante
\linebreak $TypeInvariance$ verifica que, em cada estado, cada variável pertence a este
conjunto.  Estas fórmulas, apesar de longas e complexas, não representam
propriedades alguma do sistema. Portanto, não serão descritas em mais detalhes
aqui. No entanto, a verificação deste invariante é recomendada, pois permite a
detecção dos erros mais óbvios da especificação. A seguir, propriedades mais relacionadas
ao protocolo \doriss são apresentadas.

\act{CollisionAvoidance} Esta fórmula temporal, apresentada na figura
\ref{fig:CollisionAvoidance}, permite verificar que em nenhum comportamento,
emissões de mensagens podem acontecer simultaneamente. Ou seja, se uma ação de
emissão é habilitada num estado, então nenhuma outra ação de emissão é habilitada no
mesmo estado.

\begin{tlafig} 
\begin{tla}
Send(Q) == \/ /\ Q \in TaskSet 
              /\ ( ENABLED SendElem(Q) \/ ENABLED SendRese(Q) )
           \/ /\ Q \in ProcSet
              /\ ENABLED SendSoft(Q)

CollisionAvoidance ==
      \A P, Q \in TaskSet \cup ProcSet: [] ( ENABLED ( Send(P) /\ Send(Q) ) => ( P = Q ) ) 
\end{tla}
\begin{tlatex}
\@x{ Send ( Q ) \.{\defeq} \.{\lor} \.{\land} Q \.{\in} TaskSet}%
 \@x{\@s{77.23} \.{\land} ( {\ENABLED} SendElem ( Q ) \.{\lor} {\ENABLED}
 SendRese ( Q ) )}%
\@x{\@s{63.90} \.{\lor} \.{\land} Q \.{\in} ProcSet}%
\@x{\@s{77.23} \.{\land} {\ENABLED} SendSoft ( Q )}%
\par\vspace{8.0pt}%
\@x{ CollisionAvoidance \.{\defeq}}%
 \@x{\@s{24.59} \A\, P ,\, Q \.{\in} TaskSet \.{\cup} ProcSet \.{:} {\Box} (
 {\ENABLED} ( Send ( P ) \.{\land} Send ( Q ) ) \.{\implies} ( P \.{=} Q ) )}%
\end{tlatex}
\tlacaption{A propriedade $CollisionAvoidance$ \label{fig:CollisionAvoidance}}
\end{tlafig} 

Vale a pena mencionar que, a fim de produzir rastros dos comportamentos verificados
para cada propriedade, a verificação realizada por TLC sempre deve ser executada
duas vezes para cada propriedade. Primeiro, verifica-se a propriedade e, em seguida,
a sua contraposição. Desta forma, pode-se verificar que TLC detecta a violação da
propriedade, ou da sua contra-posição, numa das duas execuções, e apenas numa. A
análise do comportamento produzido como contra-exemplo permite assim conferir que a
propriedade especificada expressa realmente o que era desejado verificar.

Por exemplo, $NoCollisionAvoidance$ é a contraposição do predicado
$CollisionAvoidance$ que ilustra o uso de tal metodologia. Os dois rastros produzidos
por TLC, numa execução com apenas uma tarefa e um processo, são comentados no
apêndice \ref{ap:traces}.

\vspace{0.3cm}  \setstretch{1}
\begin{tla}
NoCollisionAvoidance ==
      \E P, Q \in TaskSet \cup ProcSet: <> ( ( P # Q ) /\ ENABLED ( Send(P) /\ Send(Q) ) )
\end{tla}
\begin{tlatex}
\@x{ NoCollisionAvoidance \.{\defeq}}%
 \@x{\@s{24.59} \E\, P ,\, Q \.{\in} TaskSet \.{\cup} ProcSet \.{:} {\Diamond}
 ( ( P \.{\neq} Q ) \.{\land} {\ENABLED} ( Send ( P ) \.{\land} Send ( Q ) )
 )}%
\end{tlatex}
\par \vspace{0.2cm}  \setstretch{1.4}


\act{HardRingCorrectnesss} Nesta fórmula, apresentada na figura
\ref{fig:HardRingCorrectnesss}, algumas propriedades do anel crítico são
verificadas.

\begin{tlafig}
\begin{tla}
HardRingCorrectness ==
      /\ \A T \in TaskSet : [] ( Len( TaskState[taskId(T)].msg ) \leq 3 )
      /\ [] ( ENABLED NextChip => History.elem = Shared.chipCount )
\end{tla}
\begin{tlatex}
\@x{ HardRingCorrectness \.{\defeq}}%
 \@x{\@s{24.59} \.{\land} \A\, T \.{\in} TaskSet \.{:} {\Box} ( Len
 ( TaskState [ taskId ( T ) ] . msg ) \.{\leq} 3 )}%
 \@x{\@s{24.59} \.{\land} {\Box} ( {\ENABLED} NextChip \.{\implies} History .
 elem \.{=} Shared . chipCount )}%
\end{tlatex}
\tlacaption{A propriedade $HardRingCorrectness$ \label{fig:HardRingCorrectnesss}}
\end{tlafig} 

Em primeiro lugar, verificou-se que o tamanho da lista de mensagens para serem
processadas permanece abaixo de um certo limite, definido aqui como 3, e que,
portanto, não há possibilidade de esgotamento da memória da placa de rede. Com os valores
das constantes utilizadas nesta verificação, duas mensagens críticas podem ser enviadas em 
cada \ing{chip}.  Estas duas mensagens devem ser processadas antes de um novo \ing{chip} 
começar, portanto, as memórias não devem conter mais de duas mensagens, o que 
explica o valor 3 utilizado aqui. 

Em seguida, a segunda linha verifica que, quando $NextChip$ acontece, a ação
$ElemSlot$ sempre foi executada exatamente $nTask$ vezes. Vale a pena observar que,
para especificar esta propriedade, foi necessário utilizar o observador
$History$, cujo campo $elemSlot$ é utilizado para contabilizar as mensagens
elementares enviadas em cada ciclo. Este contador, redefinido para ``$0$'' no início
de cada ciclo, é incrementado quando $ElemSlot$ é verdadeira. Assim, no final de
cada ciclo, $History.elemSlot $ deve ser igual a $nTask$ se todas as tarefas enviaram
suas mensagens elementares. Em outras palavras, a ação $ElemSlot$ é regularmente
habilitada. O fato que esta ação seja regularmente realizada é assegurada pelo
guarda $ i = ChipCount$, presente na fórmula da ação $SendElem$ (ver figura
\ref{fig:SendElem}).

Lembrar que falhas de omissão foram especificadas na ação de recepção de mensagens
críticas (ver figura \ref{fig:RecvHard}).  Isto implica que falhas de envio de
mensagens e falhas de paradas também foram modeladas. Por exemplo, uma falha de
omissão na emissão de uma mensagem pode ser vista como um conjunto de falhas de
omissões na recepção, em todos as estações, e uma falha de parada de uma estação
corresponde a uma falha permanente de omissão de emissão. Portanto, não foi necessário
verificar cenários específicos de falhas de emissão, nem de falhas de paradas de
tarefas.


\act{ReservationSafety} Esta propriedade, apresentada na figura
\ref{fig:ReservationSafety}, garante que, se uma tarefa $j$ pode enviar uma mensagem
num \ing{slot} \RS{} de um \ing{chip}, então, neste \ing{chip}: (i) a tarefa $j$ tem
uma reserva para \RS, e (ii) cada uma das demais tarefas estão cientes desta reserva,
ou não tem reserva nenhuma para aquele \ing{slot}.

\begin{tlafig}
\begin{tla}
ReservationSafety ==
      []  \A chip, j \in Task : /\ ENABLED SendRese(T[j])
                                /\ Shared.chipCount = chip
          => /\ TaskState[j].res[chip] = j
             /\ \A i \in Task\{j}: TaskState[i].res[chip] \in { j, -1 }
\end{tla}
\begin{tlatex}
\@x{ ReservationSafety \.{\defeq}}%
 \@x{\@s{24.59} {\Box}\@s{4.1} \A\, chip ,\, j \.{\in} Task \.{:} \.{\land}
 {\ENABLED} SendRese ( T [ j ] )}%
\@x{\@s{131.36} \.{\land} Shared . chipCount \.{=} chip}%
\@x{\@s{37.66} \.{\implies} \.{\land} TaskState [ j ] . res [ chip ] \.{=} j}%
 \@x{\@s{70.13} \.{\land} \A\, i \.{\in} Task \.{\,\backslash\,} \{ j \} \.{:}
 TaskState [ i ] . res [ chip ] \.{\in} \{ j ,\, \.{-} 1 \}}%
\end{tlatex}
\tlacaption{A propriedade $ReservationSafety$ \label{fig:ReservationSafety}}
\end{tlafig} 

Em particular, esta fórmula implica que duas tarefas não podem ter reservas para
o mesmo \ing{slot} \RS. Juntamente com o guarda $Reser[i][ChipCount] = i$ 
da ação $SendRese$ (ver figura \ref{fig:SendRese}), a especificação implica 
também que uma tarefa $T[i]$ só pode enviar uma mensagem de reserva num 
\ing{slot} que ela reservou anteriormente.

\pagebreak
\act{SoftRingFairness} Esta propriedade, apresentada na figura
\ref{fig:SoftRingFairness},  permite verificar que todos os processos receberão
o bastão circulante em algum momento futuro e que todas as listas de mensagens
de processos não falhos serão esgotados.

\begin{tlafig}
\begin{tla}
SoftRingFairness == 
      /\ \A i \in Proc : []<> ( i = ProcState[i].token )
      /\ []<> ( \A i \in Proc \ Failed : Len(ProcState[i].list) = 0 )
\end{tla}
\begin{tlatex}
\@x{ SoftRingFairness \.{\defeq}}%
 \@x{\@s{24.59} \.{\land} \A\, i \.{\in} Proc \.{:} {\Box} {\Diamond} ( i
 \.{=} ProcState [ i ] . token )}%
 \@x{\@s{24.59} \.{\land} {\Box} {\Diamond} ( \A\, i \.{\in} Proc
 \.{\,\backslash\,} Failed \.{:} Len ( ProcState [ i ] . list ) \.{=} 0 )}%
\end{tlatex}
\tlacaption{A propriedade $ReservationSafety$ \label{fig:SoftRingFairness}}
\end{tlafig} 

É importante observar que a segunda linha desta fórmula não é detectada como falsa
por TLC em comportamentos nos quais a lista de mensagem dos processos crescem
indefinidamente. Em tais comportamentos, TLC não consegue parar de criar novos
estados, e portanto, não pode verificar, se, no futuro, um destes estados satisfará
a condição. No entanto, tais comportamentos são detectados na ação $NextChip$, pelo
predicado $Overflow$, assim como foi explicado na descrição da figura
\ref{fig:NextChip}.

% Other verification can be carried out such as the existence of fault scenarios or
% other ,

% We invite the interested reader to refer to \cite{DoRiS07} for the complete set of
% these temporal formulas.

% -------------------------------------------------------------------------
\section{Conclusão}
\label{sec:dorisConc}

Neste capítulo, a descrição de \doris, um protocolo de comunicação baseado em
Ethernet, e da sua especificação e verificação em TLA+, foram apresentados.  \doriss
foi projetado para os sistemas de tempo real modernos, que exigem previsibilidade,
tolerância a falha e flexibilidade.  Para tal trabalho, a linguagem TLA+ mostrou
ter uma capacidade de expressão poderosa, mantendo um nível de abstração elevado.

Como pôde ser visto, foi possível verificar propriedades interessantes do protocolo
\doris. Em resumo, a verificação automática permitiu garantir que: (i) o protocolo
provê isolamento das comunicações críticas e não-críticas, evitando colisões; (ii)
cada tarefa elementar sempre envia uma mensagem por ciclo e a capacidade das
memórias locais nunca é esgotada, (iii) o mecanismo de reservas é seguro e correto;
(iv) a comunicação não-crítica satisfaz critérios de justiça; e (v) tolerância a
falhas é garantida.

Do ponto de vista do desenvolvimento de \ing{software}, a abordagem utilizada para
conceber \doris{} mostrou o benefício que o uso de métodos formais pôde trazer. De
fato, a utilização de TLA+ e das suas ferramentas permitiu uma metodologia de
desenvolvimento interativa, na qual especificação e verificação foram realizados
durante a fase de concepção das funcionalidades do protocolo.

Por exemplo, a impossibilidade de obter placas de rede que possam informar o estado
do meio com tempo de respostas da ordem do micro-segundos resultou numa modificação
necessária do mecanismo de controle do bastão circulante. No entanto, as
modificações subseqüentes da especificação formal foram simples de escrever, devido
ao aspecto modular de TLA+.

O produto final deste capítulo concretizou-se num expressivo aumento da maturidade
e confiança dos desenvolvedores no comportamento do protocolo. Por conseguinte, o trabalho 
de implementação apresentado no próximo capítulo foi significativamente facilitado.




\begin{comment}

\section{Uma ilustração gráfica}

\parspace
A Figura~\ref{fig:dorisScenar}, inspirada da ilustração usada em ~\cite{Pritty95}, é
uma representação da circulação do bastão circulante e das mensagens emitidas pelas
diferentes estações num barramento \doris{}. O eixo $x$ representa o tempo e o eixo
$y$ a localização espacial das estações.  As escalas temporais da Figura estão
distorcidas.  Em particular, a inclinação correspondendo a velocidade de propagação
na rede deveria ser menor de pelo menos um fator 4. As cores mais escuras
correspondem às mensagens de tamanho maior, e portanto a intervalos de tempos
maiores.

Este exemplo apresenta um \ing{chip} de \doris{} com o seguinte cenário:
\par - $T_1$ emite uma mensagem elementar;
\par - $T_7$ emite uma mensagem crítica sob reserva;
\par - Na janela $\SW$, o bastão circulante começa pelo processo $P_1$ que não tem nada
para transmitir;
\par - $P_2$ tem uma mensagem de 512 bytes para transmitir;
\par - $P_3$ e $P_4$ não tem nada para transmitir, portanto dois intervalos de
tempos $d_r$ passam antes do bastão circulante chegar a $P_5$;
\par - $P_5$ tem uma mensagem de 1024 bytes para transmitir;
\par - $P_6$ não tem nada para transmitir;
\par - $P_7$ tem uma mensagem de 512 bytes para transmitir, mas o tempo restante na
janela $\SW$ não é suficiente, portanto $P_7$ emite uma mensagem STOP antes do fim
do \emph{slot} não-crítico.

\begin{figure}[!ht]
  \index{figuras!dorisScenar}%
  % \setlength{\abovecaptionskip}{14pt}
  \centering
  % \includegraphics[scale=0.8]{xfig/dorisScenar}
  \input{fig/dorisScenar.pstex_t}
  \caption{Um exemplo de chip \label{fig:dorisScenar}}
\end{figure}


\section{Composição dos aneis}

\subsection{Modelo}

Para gerar dinamicamente a composição dos dois anéis $\RTS$ e $\SOS$, é preciso
utilizar mecanismos específicos baseados no modelo de falhas adotado
\cite{Lamport84,Cristian95a}.

Neste trabalho, assume-se que os números máximos de tarefas e processos são
conhecidos antes de inicializar o protocolo \doris{} num segmento.  Denota-se
respectivamente $N^{max}_S$ e $N^{max}_H$ estes números.  Considera-se também que as
tarefas e os processos admissíveis nos aneis tem um identificador absoluto único.
Este identificador, denotado $id$, é geralmente diferente do indice da tarefa ou
processo no conjunto $\RTS$ e $\SOS$.

Em relação ao modelo de falha, assume-se que mensagens podem ser corrompidas ou não
emitidas por uma estação (omissão), mas que a função de sensoriamento do meio pelas
estações não falha, isto é, o sensoriamento é confiável. Isto implica que se uma
mensagem é transmitida no meio físico, todas as estações, inclusive a estação
emissora daquela mensagem, percebem a transmissão desta mensagem, mesmo que elas não
consigam a processar corretamente.

Podemos expressar este modelo através das seguintes propriedades:

\begin{itemize}
\item Uma tarefa ou um processo sempre detecta a sua própria falha
  (``self-awareness''),
\item Uma tarefa sempre detecta corretamente a falha de uma outra tarefa.
\end{itemize}

Esta segunda propriedade decorre da periodicidade das mensagens elementares.  Já que
a falha eventual de uma tarefa causa a ausência da mensagem elementar desta tarefa
no seu devido chip, todas as outras tarefas detectam a ausência de mensagem (estado
do meio ``idle'') e inferem a falha da tarefa correspondente.

No caso dos processos, a ausência de uma mensagem pode ser devida a uma falha ou a
ausência de mensagem para ser transmitido por aquele processo. Portanto, outros
processos não podem deduzir nada da ausência, mesmo continuamente repetida, de
mensagens de um certo processo.

Esta propriedade do protocolo \doris{} carateriza a independência entre os dois
anéis, isto é: uma tarefa de $\RTS$ só conhece a composição do anel $\RTS$, mas não
conhece a composição do anel $\SOS$. Da mesma forma, os processos de $\SOS$ não
conhecem a composição de $\RTS$.


\subsection{Mecanismo}

O mecanismo de admissão de tarefas nos aneis $\RTS$ e $\SOS$ utiliza um \emph{round}
de admissão. A sucessão de seqüências de rotação entre dois \emph{round} de admissão
é chamada de ciclo de communicação.  Num ciclo de comunicação, o conjunto de tarefas
membros de

Durante um \emph{round} de admissão, cada tarefa admissível disponha de um slot,
determinado de maneira única atravês do seu identificador absoluto, para transmitir
sua intençao de pertencer ao próximo grupo de comunicação. Se uma tarefa $T_{id}$
emite uma mensagem durante o seu slot de admissão, a propriedade de sensoriamento
confiável implica que todas as tarefas percebem esta mensagem, inclusive a própria
tarefa $T_{id}$. Portanto, todas as tarefas concordam para incluir $T_{id}$ no
próximo grupo de comunicação constituindo $\RTS$.  Se um slot permanece vazio
durante o \emph{round} de admissão, isto signica que a tarefa correspondente não
pertencerá ao próximo grupo de comunicação.  Este mecanismo aproveita ao máximo da
sincronização temporal das estações, interpretando a omissão de uma mensagem num
determinado slot como a ausência da estação correspondente para o próximo ciclo de
communicação.

Para não alterar as propriedades

O seqüenciamento dos slots de admissões baseia-se no sincronismo da


No entanto, uma tarefa que deixa de emitir duas mensagens elementares em seguida é
removida do anel pelas outras tarefas.  Pela propriedade de sensoriamento confiável,
se uma mensagem não é transmitida no meio, por exemplo porque uma falha de omissão
occoreu, a estação que falhou percebe que o seu slot elementar de emissão ficou
vazio, portanto ela ``percebe'' a suas proprias falhas e pode se remover do anel de
forma consistente com as demais estações.


\section{Conclusão}

Uma observação deve ser colocada a respeito do nosso modelo determinístico. Usando
temporizadores, o protocolo de circulação do bastão circulante virtual poderia permitir
que uma tarefa de $\RTS$ se omitisse quando ela não tiver nada para transmitir e que
o bastão circulante passasse logo para a próxima estação, sem espera nenhuma. No entanto,
esta melhoria em termos de eficiência (\emph{throughput}) da comunicação,
introduziria uma variabilidade no tamanho dos chips, sem melhorar o pior caso para
as tarefas com requisitos temporais críticos. Além disso, a detecção de falhas seria
dificultada. Por esta razão, o protocolo \doris{} não implementa esta opção. Ou
seja, para garantir a periodicidade exata dos \emph{slots} de comunicação, o tamanho
$\DDC = \DHW + \DSW$ dos chips é suposto constante. O determinismo introduzido desta
forma facilita a detecção eficiente das falhas de processos; dado que cada chip de
\doris{} contém uma mensagem elementar, a periodicidade do nosso modelo permite
determinar exatamente quando uma mensagem elementar deve ser observada. Portanto, se
no instante previsto, o meio está livre, isto significa que uma falha de omissão ou
de parada ocorreu.  A conseqüência do determinismo assim introduzido é um
\textit{overhead} máximo de $2 \, \delta$ por chip de \doris{}, isto é
aproximadamente 4,6\% da banda.

O protocolo \doris{} precisa que haja pelo menos uma estação crítica atíva no anel
$\RTS$ para funcionar.

Em relação a tolerância a falhas dos canais de comunicação, a redundância do
barramento físico deverá ser considerada ~\cite{Kopetz05,Avizienis04}.


\end{comment}