\chapter{\doris: Especificação e verificação}
\label{cap:doris}

\section{Introdução}
\label{sec:intro}

Neste capítulo,  um novo protocolo de comunicação de tempo real, baseado em  Ethernet
compartilhado, é apresentado através das sua especificação formal na linguagem TLA+
\cite{Lamport02a}.

O protocolo \doris, cujo significado em inglês é \emph{An Ethernet
  \underline{Do}uble \underline{Ri}ng \underline{S}ervice for Real -Time Systems},
teve como fontes de inspiração principais os protocolos VTPE \cite{Carreiro03} e
TEMPRA \cite{Pritty95}, apresentados no capítulo \ref{cap:motivacao}.  \doriss foi
concebido para dar suporte a sistemas híbridos nos quais dispositivos industriais
como sensores, atuadores e controladores compartilham a mesma rede de comunicação
com aplicações ou serviços não-críticos. Lembrar que a velocidade de processamento e
as características da comunicação das aplicações de tempo real críticas e das
aplicações com requisitos temporais não-críticos são bastante diferentes. De fato, a
maioria dos dispositivos de pratileira disponíveis tem capacidade de processamento
pequena em relação à largura da banda Ethernet.  Por exemplo, vimos na seção
\ref{sec:sisHibrid}, que Carreiro et al \cite{Carreiro03} utilizaram
micro-controladores que podem gastar até $111 \, \mu s$ para processar uma mensagem
de 64B. Já que o tempo de transmissão de tal mensagem numa rede 100Mbps é $\delta =
5,76 \, \mu s$, isso permite somente cerca de $5,2\%$ de utilização do barramento
para a comunicação com requisitos temporais críticos. Por outro lado, aplicações
não-críticas têm geralmente capacidades de processamento maiores e podem, portanto,
utilizar taxas de transmissão mais elevadas.  Considerando estas características dos
sistemas híbridos, este trabalho propõe \doris, um protocolo novo que combina as
abordagens de bastão circulante e \emph{Time Division Multiple Access} (TDMA) para:
\begin{enumerate}
\item prover previsibilidade num segmento Ethernet compartilhado;
\item oferecer garantias temporais às tarefas de tempo real;
\item disponibilizar a largura de banda não aproveitada pela comunicação
crítica para a comunicação não-crítica. 
\end{enumerate}

A concepção e implementação de um novo protocolo tal que \doriss envolve tomadas de
decisão cautelosa. Neste processo, a especificação formal do protocolo e sua
verificação automática permitem adquirir confiança no projeto elaborado. De fato,
especificar formalmente um sistema e verificar a sua correção de maneira automática
aumenta significativamente a compreensão do seus comportamentos e pode ajudar a
detectar erros ou defeitos de concepção numa fase inicial do desenvolvimento do
\ing{software} \cite{Auslander96, Clarke99}. Tal abordagem, apesar de não ser tão
freqüente na comunidade de pesquisa de rede, já foi utilizado em vários domínios de
aplicação \cite{Barboza06, Johnson04, Hanssen06}.

Na últimas três décadas, várias linguagens formais e ferramentas de verificação foram
desenvolvidas baseadas em lógica temporal \cite{Pnueli79,  Larsen97, Henzinger91}. Por 
exemplo, Esterel \cite{Berry92} é uma linguagem síncrona bastante adequada para especificar 
componentes de \ing{hardware} e para expressar propriedades complexas de circuitos ou 
sistemas síncronos mais amplos.
% However, it is mainly devoted to programming control-dominated software or
% hardware reactive systems.
A linguagem de Especificação e Descrição (SDL) e o padrão Estelle foram recentemente
estendidos para permitir a especificação de Sistemas de Tempo Real \cite{Fischer96,
  Sinnott04}. No entanto, SDL e Estelle são dedicados a descrição formal e a geração
automática de código na fase inicial do projeto e ambas não permitem a verificação
automática do modelo. Várias outras ferramentas são baseadas em automata temporais
tal que Kronos \cite{Daws96} and HyTech \cite{Alur96}.  Promela é agora dotada de
uma extensão de tempo real que fornece uma semântica para a especificação e a
verificação de propriedades temporais \cite{Tripakis96}.  Uma outra ferramenta
bastante utilizada para especificar e verificar sistemas de tempo real é UPPALL
\cite{Larsen97}. Por exemplo, num trabalho recente \cite{Hanssen06}, o protocolo
RTnet, de tempo real baseado em Ethernet, foi especificado e suas propriedades
temporais foram verificadas com UPPAAL.

Uma outra alternativa possível para especificar Sistemas de Tempo Real
\cite{Abadi94,Lamport05} é a linguagem de especificação formal TLA+ (\ing{Temporal
  Logic of Actions}) \cite{Lamport02a}, junto com o seu verificador de modelo
associado TLC (\ing{Temporal Logic Checker}) \cite{Yu99}.  Baseada na teoria dos
conjuntos de Zermelo-Fraenkel e na lógica temporal ~\cite{Pnueli79}, a linguagem
TLA+ foi especialmente concebida para expressar propriedades temporais de sistemas
concorrentes e distribuídos ~\cite{Johnson04}.  A escolha de TLA+ para especificar e
verificar \doriss se deu pelas razões principais seguintes. 
\begin{enumerate}
\item TLA+ tem uma estrutura modular permitindo um processo de escrita por incrementos
  sucessivos, de acordo com o grau de abstração ou de detalhe desejado;
\item Uma especificação em TLA+ é bastante parecida com código de programas, e
  portanto, oferece uma base sólida para a implementação de \doris.
\item O verificadores de modelo TLC permite verificar automaticamente a especificação, 
  assim como as propriedades temporais associadas.
\item Tantos os documentos de definição da linguagem TLA+ como a ferramenta TLC e
  vários exemplos são disponíveis livremente na Internet \cite{TLA}.
\end{enumerate}

Após introduzir alguns termos e considerações sobre o sistema considerado, a seção
\ref{sec:dorisProt} apresentará uma visão geral do protocolo \doris. Em seguida, as
hipóteses de modelagem e uma breve introdução a linguagem TLA+ darão o início da
seção \ref{sec:dorisSpec}, que se prosseguirá com a descrição detalhada da
especificação formal de \doriss. Finalmente, a seção \ref{sec:dorisProp} será
dedicada a discussão das propriedades temporais verificadas. A seção
\ref{sec:dorisConc} concluíra este capítulo.


\section{\doris: o protocolo}
\label{sec:dorisProt}

O protocolo \doriss atua como um filtro lógico, localizado entre as camadas de rede
e física da pilha Ethernet, que elimina as colisões inerentes à camada de controle
de acesso ao meio do protocolo CSMA/CD \cite{CSMA/CD01}.  \doriss é concebido para
dar suporte à sistemas híbridos, nos quais sensores industriais, atuadores e
controladores compartilham a rede de comunicação com as demais aplicações com
requisitos temporais não-críticos. Dispositivos industriais (micro-controladores,
sensores, etc.) são chamados de ``estações lentas'', pois a velocidade de
processamento de tais dispositivo é relativamente baixas em comparação a dos
micro-computadores, chamados de ``estações rápidos''.

\subsection{Sistema, modelo e terminologia}
\label{sec:dorisModel}

O conjunto de estações (lentas e rápidas) interligadas num barramento Ethernet
compartilhado constituem um segmento \doris. Embora vários segmentos \doriss possam
ser inter-conectados por \ing{switches} ou roteadores, a especificação e verificação
de \doris se restringe a um segmento isolado. Em tal segmento, cada estação executa
um servidor \doris, que é responsável pela execução das funcionalidades de \doris.
Uma estação rápida pode hospedar tanto tarefas críticas como também processos com
requisitos temporais não-críticos. Para fins de sobriedade das notações, as
primeiras serão simplesmente chamados de tarefas e os segundos de
processos. Assume-se que uma estação lenta só pode hospedar tarefas.

Define-se $nTask$ e $nProc$ os números respectivos de tarefas e de processos e $Task
= \{T_1, T_2, \ldots, T_{nTask} \}$ e $Proc = \{P_1, P_2, \ldots, P_{nProc} \}$, os
conjuntos dos seus identificadores únicos. Estes conjuntos definem os dois anéis
lógicos de um segmento \doris, nos quais um único bastão circulante circula.

Mensagens enviadas pelas estações lentas são curtas, usualmente periódicas, e têm
requisitos de tempo real críticos.  Assume-se que tais mensagem, chamadas de
``mensagens críticas'', têm um tamanho constante de 64B e que, conseqüentemente, são
transmitidas no barramento no tempo de transmissão $\delta$. Denota-se $\pi$ o tempo
de processamento, no pior caso, da estação mais lenta do segmento \doris.  Assume-se
que $\delta \ll \pi$ e que a recepção e o processamento das mensagens são duas
operações independentes que podem ser realizada simultaneamente.  A primeira
suposição reflete a existência de estações lentas no segmento, enquanto a segunda
corresponde a realidade dos dispositivos de hardware modernos dotadas de memórias
tampões e de capacidade de DMA (\ing{Direct Memory Access}). A segunda suposição
implica, notadamente, que duas ou mais mensagens críticas podem ser enviadas em
seguida. Observa-se que se tiver somente estações lentas presentes no segmento
\doris, a taxa máxima de utilização do barramento é de $\frac{\delta}{\pi +
  \delta}$.  No entanto, se tiver também estações rápidas, a fração da banda não
utilizada pode ser aproveitada pelos processos. É desta constatação que surgiu a
proposta de \doris.

Assim como os protocolos VTPE e TEMPRA (cf seção \ref{sec:TempraVTPE}), \doris{}
utiliza o modelo de comunicação \ing{publish-subscribe} \cite{Dolejs04}, de acordo
com o qual, quando uma aplicação quer enviar uma mensagem, ela utiliza o endereço
Ethernet de comunicação um-para-todos padrão (\cod{FF:FF:FF:FF:FF:FF}).
% Porém, várias aplicações podem ser hospedadas numa mesma estação. Para identificar
% as mensagens de cada aplicação, usa-se o \ing{type field} do quadro Ethernet
% \ref{fig:ethernetFrame}.
Quando um servidor \doris recebe uma mensagem, ele determina, de acordo com a
identidade do seu emissor, se tiver alguma aplicação interessada naquela
mensagem. Caso positivo, ele entrega a mensagem. Senão, ele a descarta.  A
princípio, as tarefas não precisam completar o processamento de todas as mensagens
críticas. No entanto, para simplificar o modelo, assume-se aqui que todas as
mensagens críticas são inteiramente processadas por todas as tarefas.

Em relação ao modelo temporal, assume-se um sistema distribuído síncrono. Isto significa
que as operações efetuadas pelas estações podem ser sincronizado uma com a outra. 
Esta suposição se baseia no esquema de divisão temporal de \doris, que como será vista, 
tem pontos de sincronização regulares e previsíveis, que ocorre dentro de uma janela
de tempo curta comparada com o desvio dos relógios locais. Isto implica que
os relógios locais das estações são sincronizados.

Por fim, assume-se que as estações podem falhar por \ing{crash}, ou seja, parar
qualquer tipo de atividade \cite{Schlichting83}, e voltar a funcionar normalmente
depois de um tempo arbitrário. Mensagens enviadas podem eventualmente ser perdidas,
porém, estações rápidas devem imperativamente perceber a interrupção associada a
recepção de uma mensagem, mesmo que o conteúdo da mensagem seja perdido. Como será
visto, este requisitos é necessário para controlar a circulação do bastão circulante
entre os processos.  De acordo com as necessidades das aplicações críticas, esta
restrição não se aplica às estações lentas, pois têm capacidades de processamento
menores.


\subsection{O esquema de Controle de Acesso ao Meio}
\label{sec:dorisMAC}

A comunicação num barramento \doriss é temporalmente dividida em uma alternância de
fases (\ing{rounds}) de comunicação (\emph{C-Rd}) e fases (\ing{rounds}) de
configuração dos membros (\emph{M-Rd}), assim como ilustrado na figura
\ref{fig:dorisStruct}. Durante a fase de configuração, o algoritmo de controle da
composição do segmento \doriss é responsável por estabelecer uma visão única da
composição do grupo de participantes do segmento \doris, compartilhada por todos os
membros deste segmento. O problema do estabelecimento de tal visão, conhecido também
como o problema do consenso, é assuntos de vários trabalhos \cite{Cristian88,
  Chandra96, Lamport98}.  No contexto desta dissertação, considerou-se que os grupos
de tarefas e processos eram definidos em tempo de projeto ($nProc$ e $nTask$), e
especificou-se somente a fase de comunicação do protocolo \doris.

\begin{figure}[tb]
  \centering
  \input{fig/dorisStruct.pstex_t}
  \caption{O esquema de Divisão Temporal de \doris}
  \label{fig:dorisStruct}
\end{figure}

Usando TDMA, cada fase de comunicação (\emph{C-Rd}) é definida como um número
arbitrário, porém fixo, de ciclos periódicos, os quais são subdivididos em
exatamente $nTask$ \ing{chips} (ver figura \ref{fig:dorisStruct}). Um mapeamento dos
naturais sobre o conjunto dos \ing{chips} associa um inteiro positivo módulo $nTask$
a um \ing{chip}. Este contador é denotado $chipCount$. Cada chip é, por sua vez,
dividido em duas janelas, críticas e não-críticas, denotadas \HW e \SW, e
associadas, respectivamente, as comunicações de tempo real críticas e
não-críticas. As tarefas só transmitem mensagens durante as janelas \HW, enquanto
os processos apenas utilizam \SW para transmitir as suas. Os tamanhos destas duas
janelas são respectivamente denotados por \DHW e \DSW e o tamanho de um chip é
definido por $\DDC = \DHW + \DSW$. Para permitir um certa flexibilidade e a
definição de políticas de escalonamento das mensagens, a janela \HW é também
subdividida em dois \ing{slots}: o \ing{slot} elementar (\ES) e o \ing{slot} de
reserva (\RS).  As mensagens transmitidas nos \ing{slots} \ES e \RS são mensagens
críticas, chamadas respectivamente de mensagem elementar e de reserva. Uma vez por
ciclo, cada tarefa envia uma mensagem elementar dentro de \ES enquanto \RS é
utilizada para oferecer um mecanismo de reserva. De forma a tolerar falhas por
\ing{crash} e prover confiabilidade do sistema inteiro, tarefas não falidas são
obrigadas a enviar uma única mensagem elementar por ciclo.

Observa-se que, com o objetivo de facilitar a apresentação e a especificação de
\doris, assume-se que cada tarefa pode enviar uma única mensagem elementar por
ciclo. No entanto, esta suposição poderia ser levada, de acordo com o algoritmo
utilizado na fase de configuração, alocando um número arbitrário de \ing{chip} por
ciclo a cada servidor.  Caberia então a cada servidor alocar seus \ing{chips} às tarefas
sob sua responsabilidade. 

O mecanismo de reserva funciona da seguinte maneira. Cada mensagem elementar enviada
por uma tarefa $i$ carrega uma lista de inteiros (módulo $nTask$) que especifica os
identificadores dos \ing{slots} que $i$ pretende usar para enviar mensagens
adicionais. Esta lista é um subconjunto do conjunto dos $nTask$ \ing{chips} seguindo
o \ing{chip} no qual $i$ envia sua mensagem. A tarefa $i$ só pode reservar um
\ing{slot} que ainda não foi reservado por uma outra tarefa. Para este efeito, cada
servidor mantém uma estrutura de dados, denotada $res$, na qual ele armazena as
reservas especificadas em cada mensagem elementar recebida. A consistência da
estrutura $res$ pode eventualmente ser comprometida por falhas de omissão de
mensagens elementares. Efetivamente, quando um servidor não recebe uma mensagem
elementar, ele deixa de atualizar a estrutura $res$ e alguma tarefa pode tentar
reservar algum \ing{slot} previamente reservado. Para evitar tal cenário que poderia
levar a uma colisão, uma tarefa $T_i$ só pode reservar um \ing{slot}, se a estrutura
$res$ do seu servidor estiver em estado consistente, isto é, se o servidor de $T_i$
tiver recebido as $nTask$ mensagens elementares precedendo o \ing{chip} de emissão
de $T_i$. Desta forma, a alocação dinâmica de \ing{slots} de reserva é tolerante à
falhas de omissão. Este mecanismo de reserva é uma inovação do protocolo \doriss que
permite a implementação de alguma política de escalonamento. Efetivamente, uma 
tarefa dispõe de um \ing{slot} elementar por ciclo e pode usar até $nTask$ outros
\ing{slots}. No entanto, a discussão de tal política foge do escopo desta dissertação. 

O controle de acesso ao meio de \doriss é organizada por um bastão circulante 
virtual, que circula nos anéis críticos e não-críticos (ver seção \ref{sec:dorisModel}).
O bastão circulante é dito virtual porque sua transmissão é associada à regras temporais
e lógicas baseadas na observação da comunicação acontecendo. A isolação dos dois 
anéis de \doriss é garantida pelo uso do mecanismo de TDMA. Em relação ao anel
não-crítico, o bastão virtual circula durante a janela \SW a cada vez que uma interrupção é
gerada pela placa de rede. Quando um processo não tem nenhuma mensagem à transmitir,
o servidor envia uma mensagem de tamanho mínimo para passar o bastão circulante ao
próximo processo do anel não-crítico.
 
Observa-se que numa fase inicial de concepção do protocolo \doris, pensou-se em
utilizar a capacidade de sensoriamento do meio para organizar a transmissão do
bastão utilizando o mecanismo TPR do protocolo Tempra \ref{sec:TempraVTPE}. No
entanto, em frente a dificuldade de conseguir placas de rede que permitam o acesso ao
estado do meio (\ing{idle} ou ocupado), esta possibilidade foi descartada. 


\section{A especificação formal de \doris }
\label{sec:dorisSpec}

A metodologia descritiva para apresentar a especificação de \doriss segue uma
abordagem indo de cima para baixo. Antes de entrar na descrição completa da
especificação, a seção \label{sec:modelHipot} descreve o conjunto das hipóteses de
modelagem adotadas para especificar o protocolo. Em seguida, a seção \ref{sec:basicTLA}
introduz alguns conceitos básicos de TLA+. As demais seções apresentam as diferentes
formulas que compõe a especificação formal de \doris.

\subsection{Hipóteses de modelagem}
\label{sec:modelHipot}

Características importantes do sistema devem ser incluídas na especificação de modo
que se possa verificar propriedades interessantes. No entanto, é preciso ter cuidado
para não especificar muitos detalhes devido ao problema da explosão de estados
durante a verificação automática do modelo. As suposições feitas nesta seção tem por
finalidade contornar este problema sem comprometer a descrição o protocolo e sua
verificação.

Em primeiro lugar, como o nosso principal objetivo aqui é fornecer uma descrição
formal do protocolo \doris, a fim de verificar a sua correção, suponha-se que cada
estação hospeda apenas uma tarefa ou processo. Desta forma, evita-se a necessidade
de especificar os servidores \doris.

Em segundo lugar, representa-se o tempo por uma variável inteira. Embora tal
representação discreta do tempo possa comprometer a precisão do modelo no caso de
sistemas assíncronos em geral \cite{Clarke99}, ela é aceitável para protocolos síncronos
baseados em troca de mensagens \cite{Lamport05}.

Em terceiro lugar, considera-se que, sempre que uma ação especificada for habilitadas,
ela acontece sem demora ou é desabilitada imediatamente. Isto significa
que os temporizadores são especificados sem desvios.

Finalmente, considera-se que todas as estações compartilham um relógio comum global,
pois assume-se um modelo síncrono para evitar a especificação de detalhes de
sincronização. Observa-se que na prática todos as estações podem sincronizar os seus
relógios locais com precisão, pois as mensagens elementares são obrigatórias e
periódicas.  Detalhes de tal procedimento serão abordados na fase de implementação
descrita no capítulo \ref{cap:implemetacao}.

É importante notar que as considerações sobre o desvio nulo dos relógios e sobre a
sincronia do sistema permite a definição de temporizadores global na especificação,
o que reduz consideravelmente os problemas de explosão de estados.

\subsection{Conceitos de TLA+}
\label{sec:basicTLA}

A Lógica Temporal de Ações (TLA) e sua linguagem formal associada (TLA +) combina a
Lógica Temporal de TLA \cite{Lamport02a} com a expressividade da lógica dos
predicados e a teoria dos conjuntos de Zermelo-Fraenkel. Dotado do verificador de
modelo TLC \cite{Yu99}, TLA+ permite a especificação e a verificação tanto de
protocolos de \ing{hardware} quanto de sistemas distribuídos. Esta seção apresenta
algumas sintaxes básicas de TLA +. Quando necessário, informações complementares
sobre TLA + serão dada ao longo da descrição da especificação de \doris.  Leitores
interessados numa descrição ampla de TLA + podem se referir a publicação de Lamport
\cite{Lamport02a}.

Numa especificação em TLA+, uma computação de um sistema é representada por um
seqüência de estados, também chamada de comportamento. Por sua vez, um
\textbf{estado} do sistema é definido pela atribuição de valores às variáveis da
especificação. Um pare de estados consecutivos, suponha $i$ e $f$ em referência 
a inicial e final, é chamada de \textbf{passo} e é denotado $i \rightarrow f$. O operador
linha ($~'$) é utilizado para distinguir os valores de variáveis num passo. Considerando
um certo passo $P: i \rightarrow f$ e uma variável $v$, a ocorrência de $v$ sem linha ($v$) faz
referência ao valor de $v$ em $i$, enquanto a ocorrência de $v$ com linha ($v'$) faz
referência ao valor de $v$ em $f$.

Um predicado de estado é um expressão booleana na qual só variáveis sem linhas
aparecem e uma função de transição é uma expressão na qual aparecem variáveis sem
linhas e com linhas. Portanto, denotando $\mathcal{P}$ o conjunto dos passos de um
sistema, uma função de transição $F$ é um mapeamento de $\mathcal{P}$ sobre
$F(\mathcal{P})$. Por exemplo, seja um passo $P:i \rightarrow f$ e $v$ uma variável,
tal que $v = 0$ no estado $i$ e $v = 1$ no estado $f$, e seja $F$ a função de
transição definida por $F(P) = v' - v$. Esta função, denotada $[v' -v ]$ em TLA+, é
tal que $F(P) = 1$.

Finalmente, uma \textbf{ação} é, por definição, uma função de transição a valores
booleana. Portanto, uma ação é um mapeamento de $\mathcal{P}$ sobre $\{ V, F \}$,
onde $V$ e $F$ correspondem aos valores de verdade e falso da lógica dos
predicados. No exemplo apresentado acima, a ação $\mathcal{A}$ definida por 
 $\mathcal{A}: v' = v + 1$ é verdadeira no passo $P$.  Em TLA+, esta ação é 
simplesmente denotada $[ v' = v + 1 ]$. Para um dado passo $P$, a relação de
sucessão do estado $i$ para o estado $f$, usualmente chamada de função de 
transição de estado no formalismo das Máquinas de Estado Finitos, é definida pelo
conjunto de ações definidas sobre o passo $P$. Este conjunto também é uma ação,
pois uma ação pode ser composta de várias ações.

As formulas temporais de TLA+, como por exemplo, a relação de transição entre
estados, são asserções booleanas sobre comportamentos.  Diz-se que um comportamento
satisfaz uma formula $\mathcal{F}$ se $\mathcal{F}$ é uma asserção verdadeira deste
comportamento.  O operador da lógica temporal $\Box$ é utilizado para escrever as
formulas temporal. A semântica do operador $\Box$ é definida da seguinte maneira:
para algum comportamento $\Sigma$ a alguma ação $\mathcal{A}$, a formula temporal
$Spec = \Box [ \mathcal{A} ]_{vars}$ é verdadeira - ou simplesmente ``$\Sigma$
satisfaz $Spec$'' - se e somente se, para qualquer passo $P:i \rightarrow f$ de
$\Sigma$ que altera o conjunto $vars$ de todas as variáveis, $A$ é verdadeira sobre
$P$.

\subsection{A formula principal \emph{Spec}}

A formula principal de \doris{} é definida por

\iniTLA
\begin{notla}
  Spec == Init /\ [] [ Next \/ Tick ]_vars /\ Liveness
\end{notla}
\begin{tlatex}
  \@x{\@s{8.2} Spec\@s{4.1} \.{\defeq}\@s{4.1} Init \.{\land} {\Box} [ Next\@s{4.1}
    \.{\lor} Tick ]_{ vars} \.{\land} Liveness}%
\end{tlatex}
% \vspace{0.3cm}
\finTLA

Esta formula descreve os comportamentos do sistema, definindo o conjunto dos estados
iniciais, denotados \emph{Init}, a relação de sucessão, aqui composta da disjunção
das duas ações \emph{Next} ou \emph{Tick}, e uma condição de evolução do
sistema. \emph{Next} e \emph{Tick} são os conjuntos de ações que podem ser verdadeira
num certo passo de um comportamento. Um comportamento $\Sigma$ satisfaz \emph{Spec} 
se e somente se o primeiro estado de $\Sigma$ é um elemento de \emph{Init} 
e se todos os passos de $\Sigma$ satisfazem \emph{Next} ou \emph{Tick}
e a condição \emph{Liveness}.  

Observa que em conseqüência da estrutura temporal de \doris, vista na seção
\ref{sec:dorisMAC}, a maioria das ações de \doris{} são regidas por condições
exclusivas. Portanto, o operador ``$\lor$'' é exclusivo em quase todas as suas
ocorrências.

\iniTLA
\begin{tla}
Init ==  /\ Shared = [ macTimer |-> 0, chipTimer |-> 0, chipCount |-> 1, medium |-> {} ]
             /\ TaskState = [ i \in Task |-> 
                          [ msg |-> << >>, res |-> [ j \in Task |-> -1 ], cons |-> nTask - i + 1 ] ] 
             /\ ProcState = [ j \in Proc |-> [ token |-> 1, list |-> list(j), count |-> 0 ] ]
             /\ History = [ elemSlot |-> 0, reseSlot |-> 0 ]
\end{tla}
\finTLA



\begin{comment}
\subsection{Os \emph{slots} elementares $\ES$}

As tarefas são logicamente organizadas em um anel no qual um único bastão circulante
implícito circula. O bastão circulante é usado para fornecer o direitos de acesso ao meio
de acordo com regras temporais e lógicas.

Para expressar as condições de rotação do bastão circulante no anel crítico $\RTS$,
utiliza-se a função $Id$ definida por: $Id: \mathbb{N}^* \rightarrow \{1, \ldots ,
N_H\}$ que associa a cada chip $\DS_k$ o identificador $Id(k) = (k-1) \, mod(N_H) +
1$.

A circulação regular do bastão circulante é garantido pelo seguinte mecanismo. No fim de
cada $\DS_k$, cada tarefa $i$ do barramento \doris{} incrementa (periodicamente) de
1 seu contador local $K_{T_i}$.  Portanto, o protocolo garante o seguinte
\textbf{invariante}:

\[
\forall \, \DS_k \, (k \in \mathbb{N}^*),\; \forall \, T_i,\; K_{T_i} = Id(k)
\]

Seja $i = Id(k)$, diz-se que $T_i$ adquire o bastão circulante em $\ES_k$ se o seu
contador local $K_{T_i}$ for igual a $i$ e se o seu temporizador $t_{T_i}$ for igual
a $0$ no instante que $\ES_k$ inicia. Por exemplo, considerando $N_H = 4$, $T_3$
adquire o bastão circulante durante $\ES_3$, $\ES_7$, $\ES_{11}$ e assim adiante. O
predicado seguinte formaliza estas condições:

\iniTabSpc
\begin{tabular}{ l l l}
  $ElemHolder(i)$ & $\triangleq$ & $ (t_{T_i} = 0) \;
  \wedge \; (K_{T_i} = i)$
\end{tabular}
\fimTabSpc

Sempre que $ElemHolder(i)$ se torna verdadeiro, $T_i$ emite uma mensagem elementar
no modo um-para-todos.  Esta operação é denotada $sendElemMsg(i)$ e sua execução
pela tarefa $i$ consiste em transmitir seu contador local $K_{T_i}$, sua lista de
reserva $R_i$ (ver na próxima seção) e seus dados ($Data$) se existir
algum. Denota-se $m(E)[info]$ uma mensagem transmitida por um elemento de $E$ e
carregando a informação $info$. Assim, temos:

\iniTabSpc
\begin{tabular}{ l l l }
  $sendElemMsg(i)$ &  $\triangleq$
  & Transmitir $m(\RTS)[K_{T_i}, R_i, Data]$\\
\end{tabular}
\fimTabSpc

Para facilitar a implementação de detectores de falhas e garantir regularidade na
comunicação, obriga-se as tarefas a emitir mensagens elementares em todos os chips
de \doris.

Observa-se que cada $\DS_k$ contém uma mensagem elementar.  Portanto, as tarefas
podem se sincronizar usando a interrupção do EOF de cada mensagem elementar
um-para-todos. Na ausência de falha, cada tarefa pode sincronizar o seu temporizador
uma vez por chip de tamanho $\DDC$.

Se uma mensagem elementar sofre uma falha de omissão, a progressão dos contadores
locais não é comprometida, já que ela depende exclusivamente dos temporizadores
locais.  No entanto, a ocorrência de $n$ falhas consecutivas provoca o aumento dos
desvios dos temporizadores.  Para garantir a confiabilidade do protocolo, o desvio
máximo dos temporizadores deve ser limitado de accordo com o número $n$ de falhas
que o modelo assume tolerar. Estamos ainda estudando estes aspectos do protocolo, e
protanto, estes não serão apresentado neste trabalho.

\subsection{Os \emph{slots} de reserva $\RS$}
\label{sec:reservation}

O mecanismo de reserva disponibiliza uma largura da banda extra para as tarefas,
introduzindo um novo tipo de mensagens transmitidas nos \emph{slots} de reserva.
Para poder ter acesso a estes \emph{slots}, cada tarefa $T_i$ manda uma lista de
reserva quando executa a operação $sendElemMsg(i)$, como foi descrito na seção
anterior.  Esta lista é um subconjunto, possivelmente vazio, de $\{1, 2, \ldots,
N_H\} - \{i\}$ que indica os \emph{slots} da seqüência $RS_k$ que $T_i$ utilizará
para transmitir dados suplementares.  Por exemplo, para $N_H = 4$, a lista de
reserva $\{3,1\}$ mandada por $T_2$ no \emph{slot} $\ES_6$ significa que $T_2$
requer $\RS_7$ e $\RS_9$ em $RS_6$. Se $T_i$ manda uma lista vazia, isto significa
que $T_i$ não efetua nenhuma reserva.

Quando uma tarefa $T_i$ recebe uma lista de reserva emitida no \emph{slot} $\ES_k$,
ela atualiza um vetor booleano de dimensão $N_H$, denotado $\Gamma_i$. Se a entrada
de $\Gamma_i[j=Id(k')]$ é verdade, $\RS_{k'}$ é reservado. Caso contrário,
$\RS_{k'}$ está livre. O valor de $\Gamma_i[j]$ vale para todos os chips da
seqüência $RS_k$ correspondente. Isto significa que $\Gamma_i[j]$ é zerado no fim de
$\DS_{k+N_H-1}$.

Observa-se que a seguinte propriedade é sempre verdadeira: {\em Pelo menos um slot
  de reserva está garantido para cada tarefa $T_i$ numa seqüência $RS_k$ ($k =
  1,2,\ldots$)}.  De fato, $T_i$ ($i = Id(k)$) é a primeira tarefa que pode requerer
uma reserva para o \emph{slot} $\RS_{k+N_H-1}$.

Para que uma tarefa $T_i$ possa transmitir uma mensagem num \emph{slot} que ela
reservou anteriormente, $T_i$ deve ter certeza que a sua reserva deste \emph{slot}
foi realizada com sucesso e que aquele \emph{slot} não está reservado por uma outra
tarefa.  Por exemplo, uma falha por omissão de mensagens elementares poderia deixar
$\Gamma_i$ inconsistente. O protocolo atende a este requisito utilizando uma
condição lógica para efetuar reservas. Para que $T_i$ possa emitir uma lista de
reserva não vazia no \emph{slot} $\ES_k$ , $T_i$ deve estar em estado consistente,
isto é, $T_i$ deve ter recebido todas as mensagens elementares da seqüência de
rotação anterior.  Esta condição é formalizada pelo seguinte predicado para $k >
N_H$:

\iniTabSpc
\begin{tabular}{ l l p{8cm} }
  $Consistency(i, k)$
  & $\triangleq$
  & $T_i$ \textit{recebeu todas as mensagens 
    \newline elementares mandadas em} $RS_{k - N_H}$\\
\end{tabular}
\fimTabSpc

Para $k \leqslant N_H$, $T_i$ é consistente se $T_i$ recebeu todas as mensagens
elementares desde $DS_1$.

Seja $\DES=\delta + IPG$ o tamanho de $\ES$. Uma tarefa $T_i$ adquire o bastão circulante
em $\RS_k$ se ela tem uma reserva para $\RS_k$ e se o seu temporizador $t_{T_i}$ é
igual a $\DES$.  Formalmente,

\iniTabSpc
\begin{tabular}{ l l p{8cm} }
  $ReseHolder(i,k)$ & $\defeq$ & $(t_{T_i} = \DES)$
  $\;\; \wedge \quad (\Gamma_i[K_{T_i} = Id(k)] = true)$\\
\end{tabular}
\fimTabSpc

Como pode ser notado, a dimensão máxima da lista de reserva é $N_H-1$. Portanto,
esta lista pode ser implementada pelo meio de um vetor de bits. Um alternativa
(implícita) mais eficiente consiste em reduzir esta lista ao número de \emph{slots}
de reserva requisitado. Neste caso, uma requisição de $n > 0$ mandada pela tarefa
$T_i$ em $\DS_k$ significa que os próximos $n$ \emph{slots} livres dentro de $RS_k$
devem ser reservados para $T_i$.  Esta implementação precisaria usar $\lceil \log_2
(N_H-1) \rceil$ bits para representar a lista implícita ao invés de $N_H-1$ bits.
No entanto, deve-ser considerado um meio termo entre o tamanho da lista de reserva e
o número máximo de \emph{slots} que cada tarefa pode reservar.  Consideramos aqui o
tamanho da lista como um detalhe de implementação e por isso, não colocamos nenhuma
restrição no seu valor.

Outras propriedades interessantes podem ser observadas.
% \singlespacing
\begin{itemize}
\item Como foi visto, as reservas são efetuadas com confiabilidade, mesmo se falhas
  eventuais de omissão de mensagens forem consideradas.
\item Existem três tipos implícitos de mensagens: as que usam apenas os \emph{slots}
  elementares; as que usam o \emph{slot} de reserva garantido e aquelas que usam os
  \emph{slots} de reserva, eventualmente deixados livres pelas outras tarefas.
  Estes tipos de mensagens agregam flexibilidade ao protocolo em comparação a
  abordagem TDMA.
\item O tempo de rotação do bastão circulante é constante e é igual a $N_t \, \DDC$, o
  que garante regularidade na comunicação para as tarefas.
\end{itemize}
% \onehalfspacing

\section{O anel não-crítico}

Da mesma maneira que no anel crítico, os processos usam os seus temporizadores
locais para controlar a passagem do bastão circulante no anel não-crítico. As mensagens
elementares emitidas pelas tarefas, por ter períodos e tamanhos constantes, servem
de referencial temporal para os processos.  Em breve, o EOF de cada mensagem
elementar serve de pulso que permite deduzir quando o \emph{slot} não-crítico
começa.  Já que o tempo entre o EOF de uma mensagem elementar $m(\ES_k)$ e o início
de uma janela não-crítica (\emph{soft}) $\SW$ é constante, a observação deste EOF
permite determinar o instante de início de $\SW$ dentro de $\DS_k$.  Inspirado no
protocolo VTPE \cite{Carreiro03}, esta idéia de pulso descentralizado constitui uma
melhoria do mecanismo \emph{Timed Packet Release} (TPR) de \cite{Pritty95}
(cf. \ref{sec:protocolos}), já que nenhuma estação ou processo assume o papel
central de emitir periodicamente o \emph{slot pulse}.

Diferentemente do anel crítico, os processos não são obrigados a emitir mensagens
periodicamente. O bastão circulante circula de acordo com o mecanismo de sensoriamento do
meio proporcionado por Ethernet.  Definimos $d_r$ um parâmetro temporal do protocolo
utilizado para definir o mecanismo TPR. As estações monitoram o meio de forma
contínua.  A partir do instante de início de cada janela $\SW$, para cada intervalo
de tempo $d_r$ que o meio permanece livre, o processo $P_i$ incrementa o seu
contador local $K_{P_i}$ de 1.  Se o meio estiver ocupado,isto significa que algum
processo está transmitindo. Neste caso, cada processo espera pelo EOF associado à
transmissão e apenas depois incrementa o seu contador, voltando a monitorar o meio
em seguida.  O valor do parâmetro $d_r$ escolhido é $1 \, \mu s$ (numa rede
100Mbps).  Este valor garante uma detecção sem ambigüidade do início da transmissão
de um quadro por uma outra estação do barramento \doris{} \cite{Pritty95}.

Sintetizando, um processo $P_i$ adquire o acesso ao meio quando o seguinte predicado
acontece:

\iniTabSpc
\begin{tabular}{ l l p{9cm} }
  $SoftHolder(i)$ & $\defeq$ & ($\DHW \leqslant t_{P_i} < \DHW + \DSW) \; 
  \wedge \;$ meio livre $\; \wedge \;(K_{P_i} = i)$\\
\end{tabular}
\fimTabSpc

Enquanto o bastão circulante circula, o tempo restante na janela $\SW_k$
diminui. Portanto, um processo $P_i$ pode receber o bastão circulante quando o tempo
ainda disponível em $\SW_k$ não é suficiente para transmitir sua mensagem. Como este
cenário poderia se repetir um número arbitrário de vezes, $P_i$ poderia se ver
indefinidamente impedido de transmitir sua mensagem.  Para resolver este problema,
definimos uma mensagem ``STOP'' como uma mensagem não-crítica especial de 64B que
para o mecanismo de circulação do bastão circulante nesta janela $\SW_k$.  Quando
$SoftHolder(i)$ é verdadeiro e que $P_i$ não tem tempo para transmitir a sua
mensagem inteira antes do fim de $\SW_k$, $P_i$ emite uma mensagem STOP. Esta
mensagem permite distinguir um processo que não tem tempo suficiente para transmitir
sua mensagem de um que não tem mensagem para transmitir.

Quando $P_i$ manda uma mensagem STOP durante $\SW_k$, ele garante que ele será o
primeiro a receber o bastão circulante na próxima janela $\SW_{k+1}$. Para garantir que
qualquer processo que queira mandar uma mensagem STOP possa enviá-la, introduz-se a
seguinte restrição.  Uma janela $\SW_k$ termina quando o tempo restante nela é igual
a $\delta$. Desta forma, um processo que recebe o bastão circulante sempre tem tempo
suficiente para mandar uma mensagem STOP.

Considerando cenário de falhas, um processo $P_i$ pode sofrer \emph{crash} e depois
voltar a funcionar.  Neste caso, seu contador local $K_{P_i}$ pode estar
desatualizado quando $P_i$ retorna para um estado ativo novamente.  Dois cenários
devem ser tratados.

% \singlespacing
\begin{itemize}
\item Quando uma janela $\SW_k$ está vazia, considera-se que o processo com o menor
  identificador recebe o bastão circulante primeiro na próxima janela $\SW_{k+1}$. Isto é
  feito pela reinicialização dos contadores $K_{P_i}$ a 1 por todos os processos.
\item Se $P_i$ observa a transmissão de uma mensagem não-crítica, ele identifica a
  estação emissor desta mensagem usando o endereço de origem e o \emph{type
    field}. Ele então deduz a posição do bastão circulante usando o valor do instante de
  início do chip $\DS_k$ e o instante de início da transmissão da mensagem obtido a
  partir do seu \emph{Start-Of-Frame}.
\end{itemize}
% \onehalfspacing

Como pode ser observado, o protocolo é confiável em ambos cenários.

No pior caso, se tiver só um processo que queira transmitir, ele pode sofrer um
atraso máximo de $N_H \, d_r$.  Se todos os processos querem transmitir mensagens de
tamanho máximo, o último a receber o bastão circulante espera no maior tempo de rotação
do bastão circulante de \mbox{$(N_H - 1) \, \DDC$}.

Em relação a divisão da largura de banda entre os diferentes tipos de comunicação,
os tamanhos das janelas devem ser escolhidos de forma adequada. Já que duas
mensagens críticas podem ser transmitidas dentro de cada $\DS_k$, cada estação lenta
precisa de $2 \pi$ para processá-las. Portanto, já que existem memórias internas nas
interfaces de rede, a relação $\DSW \geqslant 2 \pi - \DHW$ deve ser verificada.  A
alocação da banda para mensagens críticas é maximizada quando se escolha $\DSW = 2
\pi - \DHW$. Portanto a taxa da banda utilizada para a comunicação crítica é $B_h =
2 \delta / \DDC$.  Pois $\DDC = \DHW + \DSW$, isto implica que $B_h = \delta / \pi$.
Considerando velocidades de processamentos do hardware similares às utilizadas por
\cite{Carreiro03}, podemos utilizar o valor $\pi = 111\mu s$. Deduz-se assim que
$B_h = 4.6\%$.

O resto da banda (95,4\%) é disponível para o anel não-crítico.

O protocolo \doris{} pode ser utilizando com redes baseadas em switch-Ethernet,
utilizando switchs (inverso de \emph{hub}) para implementar a rede física. Neste
caso, o parâmetro $d_r$ do mecanismo TPR precisa ser significativamente maior,
devido aos prazos de roteamento (da ordem de $10 \mu s$ \cite{Wang02}) nos switchs.
Em relação ao valor possível de $d_r = 1 \, \mu s$ em Ethernet compartilhada
(\emph{hub}), a utilização de switchs terá então por conseqüência uma queda
significativa da eficiência da rede.

\section{Uma ilustração gráfica}

\parspace
A Figura~\ref{fig:dorisScenar}, inspirada da ilustração usada em ~\cite{Pritty95}, é
uma representação da circulação do bastão circulante e das mensagens emitidas pelas
diferentes estações num barramento \doris{}. O eixo $x$ representa o tempo e o eixo
$y$ a localização espacial das estações.  As escalas temporais da Figura estão
distorcidas.  Em particular, a inclinação correspondendo a velocidade de propagação
na rede deveria ser menor de pelo menos um fator 4. As cores mais escuras
correspondem às mensagens de tamanho maior, e portanto a intervalos de tempos
maiores.

Este exemplo apresenta um chip de \doris{} com o seguinte cenário:
\par - $T_1$ emite uma mensagem elementar;
\par - $T_7$ emite uma mensagem crítica sob reserva;
\par - Na janela $\SW$, o bastão circulante começa pelo processo $P_1$ que não tem nada
para transmitir;
\par - $P_2$ tem uma mensagem de 512 bytes para transmitir;
\par - $P_3$ e $P_4$ não tem nada para transmitir, portanto dois intervalos de
tempos $d_r$ passam antes do bastão circulante chegar a $P_5$;
\par - $P_5$ tem uma mensagem de 1024 bytes para transmitir;
\par - $P_6$ não tem nada para transmitir;
\par - $P_7$ tem uma mensagem de 512 bytes para transmitir, mas o tempo restante na
janela $\SW$ não é suficiente, portanto $P_7$ emite uma mensagem STOP antes do fim
do \emph{slot} não-crítico.

\begin{figure}[!ht]
  \index{figuras!dorisScenar}%
  % \setlength{\abovecaptionskip}{14pt}
  \centering
  % \includegraphics[scale=0.8]{xfig/dorisScenar}
  \input{fig/dorisScenar.pstex_t}
  \caption{Um exemplo de chip \label{fig:dorisScenar}}
\end{figure}


\section{Composição dos aneis}

\subsection{Modelo}

Para gerar dinamicamente a composição dos dois anéis $\RTS$ e $\SOS$, é preciso
utilizar mecanismos específicos baseados no modelo de falhas adotado
\cite{Lamport84,Cristian95a}.

Neste trabalho, assume-se que os números máximos de tarefas e processos são
conhecidos antes de inicializar o protocolo \doris{} num segmento.  Denota-se
respectivamente $N^{max}_S$ e $N^{max}_H$ estes números.  Considera-se também que as
tarefas e os processos admissíveis nos aneis tem um identificador absoluto único.
Este identificador, denotado $id$, é geralmente diferente do indice da tarefa ou
processo no conjunto $\RTS$ e $\SOS$.

Em relação ao modelo de falha, assume-se que mensagens podem ser corrompidas ou não
emitidas por uma estação (omissão), mas que a função de sensoriamento do meio pelas
estações não falha, isto é, o sensoriamento é confiável. Isto implica que se uma
mensagem é transmitida no meio físico, todas as estações, inclusive a estação
emissora daquela mensagem, percebem a transmissão desta mensagem, mesmo que elas não
consigam a processar corretamente.

Podemos expressar este modelo através das seguintes propriedades:

\begin{itemize}
\item Uma tarefa ou um processo sempre detecta a sua própria falha
  (``self-awareness''),
\item Uma tarefa sempre detecta corretamente a falha de uma outra tarefa.
\end{itemize}

Esta segunda propriedade decorre da periodicidade das mensagens elementares.  Já que
a falha eventual de uma tarefa causa a ausência da mensagem elementar desta tarefa
no seu devido chip, todas as outras tarefas detectam a ausência de mensagem (estado
do meio ``idle'') e inferem a falha da tarefa correspondente.

No caso dos processos, a ausência de uma mensagem pode ser devida a uma falha ou a
ausência de mensagem para ser transmitido por aquele processo. Portanto, outros
processos não podem deduzir nada da ausência, mesmo continuamente repetida, de
mensagens de um certo processo.

Esta propriedade do protocolo \doris{} carateriza a independência entre os dois
anéis, isto é: uma tarefa de $\RTS$ só conhece a composição do anel $\RTS$, mas não
conhece a composição do anel $\SOS$. Da mesma forma, os processos de $\SOS$ não
conhecem a composição de $\RTS$.


\subsection{Mecanismo}

O mecanismo de admissão de tarefas nos aneis $\RTS$ e $\SOS$ utiliza um \emph{round}
de admissão. A sucessão de seqüências de rotação entre dois \emph{round} de admissão
é chamada de ciclo de communicação.  Num ciclo de comunicação, o conjunto de tarefas
membros de

Durante um \emph{round} de admissão, cada tarefa admissível disponha de um slot,
determinado de maneira única atravês do seu identificador absoluto, para transmitir
sua intençao de pertencer ao próximo grupo de comunicação. Se uma tarefa $T_{id}$
emite uma mensagem durante o seu slot de admissão, a propriedade de sensoriamento
confiável implica que todas as tarefas percebem esta mensagem, inclusive a própria
tarefa $T_{id}$. Portanto, todas as tarefas concordam para incluir $T_{id}$ no
próximo grupo de comunicação constituindo $\RTS$.  Se um slot permanece vazio
durante o \emph{round} de admissão, isto signica que a tarefa correspondente não
pertencerá ao próximo grupo de comunicação.  Este mecanismo aproveita ao máximo da
sincronização temporal das estações, interpretando a omissão de uma mensagem num
determinado slot como a ausência da estação correspondente para o próximo ciclo de
communicação.

Para não alterar as propriedades

O seqüenciamento dos slots de admissões baseia-se no sincronismo da


No entanto, uma tarefa que deixa de emitir duas mensagens elementares em seguida é
removida do anel pelas outras tarefas.  Pela propriedade de sensoriamento confiável,
se uma mensagem não é transmitida no meio, por exemplo porque uma falha de omissão
occoreu, a estação que falhou percebe que o seu slot elementar de emissão ficou
vazio, portanto ela ``percebe'' a suas proprias falhas e pode se remover do anel de
forma consistente com as demais estações.


\section{Observações finais}

Uma observação deve ser colocada a respeito do nosso modelo determinístico. Usando
temporizadores, o protocolo de circulação do bastão circulante virtual poderia permitir
que uma tarefa de $\RTS$ se omitisse quando ela não tiver nada para transmitir e que
o bastão circulante passasse logo para a próxima estação, sem espera nenhuma. No entanto,
esta melhoria em termos de eficiência (\emph{throughput}) da comunicação,
introduziria uma variabilidade no tamanho dos chips, sem melhorar o pior caso para
as tarefas com requisitos temporais críticos. Além disso, a detecção de falhas seria
dificultada. Por esta razão, o protocolo \doris{} não implementa esta opção. Ou
seja, para garantir a periodicidade exata dos \emph{slots} de comunicação, o tamanho
$\DDC = \DHW + \DSW$ dos chips é suposto constante. O determinismo introduzido desta
forma facilita a detecção eficiente das falhas de processos; dado que cada chip de
\doris{} contém uma mensagem elementar, a periodicidade do nosso modelo permite
determinar exatamente quando uma mensagem elementar deve ser observada. Portanto, se
no instante previsto, o meio está livre, isto significa que uma falha de omissão ou
de parada ocorreu.  A conseqüência do determinismo assim introduzido é um
\textit{overhead} máximo de $2 \, \delta$ por chip de \doris{}, isto é
aproximadamente 4,6\% da banda.

O protocolo \doris{} precisa que haja pelo menos uma estação crítica atíva no anel
$\RTS$ para funcionar.

Em relação a tolerância a falhas dos canais de comunicação, a redundância do
barramento físico deverá ser considerada ~\cite{Kopetz05,Avizienis04}.


\end{comment}
