\chapter{\doris: Especificação e verificação}
\label{cap:doris}

\section{Introdução}
\label{sec:intro}

Neste capítulo,  um novo protocolo de comunicação de tempo real, baseado em  Ethernet
compartilhado, é apresentado através das sua especificação formal na linguagem TLA+
\cite{Lamport02a}.

O protocolo \doris, cujo significado em inglês é \emph{An Ethernet
  \underline{Do}uble \underline{Ri}ng \underline{S}ervice for Real -Time Systems},
teve como fontes de inspiração principais os protocolos VTPE \cite{Carreiro03} e
TEMPRA \cite{Pritty95}, apresentados no capítulo \ref{cap:motivacao}.  \doriss foi
concebido para dar suporte a sistemas híbridos nos quais dispositivos industriais
como sensores, atuadores e controladores compartilham a mesma rede de comunicação
com aplicações ou serviços não-críticos. Lembrar que a velocidade de processamento e
as características da comunicação das aplicações de tempo real críticas e das
aplicações com requisitos temporais não-críticos são bastante diferentes. De fato, a
maioria dos dispositivos de pratileira disponíveis tem capacidade de processamento
pequena em relação à largura da banda Ethernet.  Por exemplo, vimos na seção
\ref{sec:sisHibrid}, que Carreiro et al \cite{Carreiro03} utilizaram
micro-controladores que podem gastar até $111 \, \mu s$ para processar uma mensagem
de 64B. Já que o tempo de transmissão de tal mensagem numa rede 100Mbps é $\delta =
5,76 \, \mu s$, isso permite somente cerca de $5,2\%$ de utilização do barramento
para a comunicação com requisitos temporais críticos. Por outro lado, aplicações
não-críticas têm geralmente capacidades de processamento maiores e podem, portanto,
utilizar taxas de transmissão mais elevadas.  Considerando estas características dos
sistemas híbridos, este trabalho propõe \doris, um protocolo novo que combina as
abordagens de bastão circulante e \emph{Time Division Multiple Access} (TDMA) para:
\begin{enumerate}
\item prover previsibilidade num segmento Ethernet compartilhado;
\item oferecer garantias temporais às tarefas de tempo real;
\item disponibilizar a largura de banda não aproveitada pela comunicação
crítica para a comunicação não-crítica. 
\end{enumerate}

A concepção e implementação de um novo protocolo tal que \doriss envolve tomadas de
decisão cautelosa. Neste processo, a especificação formal do protocolo e sua
verificação automática permitem adquirir confiança no projeto elaborado. De fato,
especificar formalmente um sistema e verificar a sua correção de maneira automática
aumenta significativamente a compreensão do seus comportamentos e pode ajudar a
detectar erros ou defeitos de concepção numa fase inicial do desenvolvimento do
\ing{software} \cite{Auslander96, Clarke99}. Tal abordagem, apesar de não ser tão
freqüente na comunidade de pesquisa de rede, já foi utilizado em vários domínios de
aplicação \cite{Barboza06, Johnson04, Hanssen06}.

Na últimas três décadas, várias linguagens formais e ferramentas de verificação foram
desenvolvidas baseadas em lógica temporal \cite{Pnueli79,  Larsen97, Henzinger91}. Por 
exemplo, Esterel \cite{Berry92} é uma linguagem síncrona bastante adequada para especificar 
componentes de \ing{hardware} e para expressar propriedades complexas de circuitos ou 
sistemas síncronos mais amplos.
% However, it is mainly devoted to programming control-dominated software or
% hardware reactive systems.
A linguagem de Especificação e Descrição (SDL) e o padrão Estelle foram recentemente
estendidos para permitir a especificação de Sistemas de Tempo Real \cite{Fischer96,
  Sinnott04}. No entanto, SDL e Estelle são dedicados a descrição formal e a geração
automática de código na fase inicial do projeto e ambas não permitem a verificação
automática do modelo. Várias outras ferramentas são baseadas em automata temporais
tal que Kronos \cite{Daws96} and HyTech \cite{Alur96}.  Promela é agora dotada de
uma extensão de tempo real que fornece uma semântica para a especificação e a
verificação de propriedades temporais \cite{Tripakis96}.  Uma outra ferramenta
bastante utilizada para especificar e verificar sistemas de tempo real é UPPALL
\cite{Larsen97}. Por exemplo, num trabalho recente \cite{Hanssen06}, o protocolo
RTnet, de tempo real baseado em Ethernet, foi especificado e suas propriedades
temporais foram verificadas com UPPAAL.

Uma outra alternativa possível para especificar Sistemas de Tempo Real
\cite{Abadi94,Lamport05} é a linguagem de especificação formal TLA+ (\ing{Temporal
  Logic of Actions}) \cite{Lamport02a}, junto com o seu verificador de modelo
associado TLC (\ing{Temporal Logic Checker}) \cite{Yu99}.  Baseada na teoria dos
conjuntos de Zermelo-Fraenkel e na lógica temporal ~\cite{Pnueli79}, a linguagem
TLA+ foi especialmente concebida para expressar propriedades temporais de sistemas
concorrentes e distribuídos ~\cite{Johnson04}.  A escolha de TLA+ para especificar e
verificar \doriss se deu pelas razões principais seguintes. 
\begin{enumerate}
\item TLA+ tem uma estrutura modular permitindo um processo de escrita por incrementos
  sucessivos, de acordo com o grau de abstração ou de detalhe desejado;
\item Uma especificação em TLA+ é bastante parecida com código de programas, e
  portanto, oferece uma base sólida para a implementação de \doris.
\item O verificadores de modelo TLC permite verificar automaticamente a especificação, 
  assim como as propriedades temporais associadas.
\item Tantos os documentos de definição da linguagem TLA+ como a ferramenta TLC e
  vários exemplos são disponíveis livremente na Internet \cite{TLA}.
\end{enumerate}

Após introduzir alguns termos e considerações sobre o sistema considerado, a seção
\ref{sec:dorisProt} apresentará uma visão geral do protocolo \doris. Em seguida, as
hipóteses de modelagem e uma breve introdução a linguagem TLA+ darão o início da
seção \ref{sec:dorisSpec}, que se prosseguirá com a descrição detalhada da
especificação formal de \doriss. Finalmente, a seção \ref{sec:verifAuto} será
dedicada a discussão da verificação automática da especificação e das suas
propriedades temporais. A seção \ref{sec:dorisConc} concluíra este
capítulo.


\section{\doris: o protocolo}
\label{sec:dorisProt}

O protocolo \doriss atua como um filtro lógico, localizado entre as camadas de rede
e física da pilha Ethernet, que elimina as colisões inerentes à camada de controle
de acesso ao meio do protocolo CSMA/CD \cite{CSMA/CD01}.  \doriss é concebido para
dar suporte à sistemas híbridos, nos quais sensores industriais, atuadores e
controladores compartilham a rede de comunicação com as demais aplicações com
requisitos temporais não-críticos. Dispositivos industriais (micro-controladores,
sensores, etc.) são chamados de ``estações lentas'', pois a velocidade de
processamento de tais dispositivo é relativamente baixas em comparação a dos
micro-computadores, chamados de ``estações rápidos''.

\subsection{Sistema, modelo e terminologia}
\label{sec:dorisModel}

O conjunto de estações (lentas e rápidas) interligadas num barramento Ethernet
compartilhado constituem um segmento \doris. Embora vários segmentos \doriss possam
ser inter-conectados por \ing{switches} ou roteadores, a especificação e verificação
de \doris se restringe a um segmento isolado. Em tal segmento, cada estação executa
um servidor \doris, que é responsável pela execução das funcionalidades de \doris.
Uma estação rápida pode hospedar tanto tarefas críticas como também processos com
requisitos temporais não-críticos. Para fins de sobriedade das notações, as
primeiras serão simplesmente chamados de tarefas e os segundos de processos.  Os
dois conjuntos de tarefas e de processos, denotados respectivamente \txtla{TaskSet}
e \txtla{ProcSet}, definem os dois anéis lógicos de um segmento \doris, nos quais um
único bastão circulante circula.

Mensagens enviadas pelas estações lentas são curtas, usualmente periódicas, e têm
requisitos de tempo real críticos.  Assume-se que tais mensagem, chamadas de
``mensagens críticas'', têm um tamanho constante de 64B e que, conseqüentemente, são
transmitidas no barramento no tempo de transmissão $\delta$. Denota-se $\pi$ o tempo
de processamento, no pior caso, da estação mais lenta do segmento \doris.  Assume-se
que $\delta \ll \pi$ e que a recepção e o processamento das mensagens são duas
operações independentes que podem ser realizada simultaneamente.  A primeira
suposição reflete a existência de estações lentas no segmento, enquanto a segunda
corresponde a realidade dos dispositivos de hardware modernos dotadas de memórias
tampões e de capacidade de DMA (\ing{Direct Memory Access}). A segunda suposição
implica, notadamente, que duas ou mais mensagens críticas podem ser enviadas em
seguida. Observa-se que se tiver somente estações lentas presentes no segmento
\doris, a taxa máxima de utilização do barramento é de $\frac{\delta}{\pi +
  \delta}$.  No entanto, se tiver também estações rápidas, a fração da banda não
utilizada pode ser aproveitada pelos processos. É desta constatação que surgiu a
proposta de \doris.

Assim como os protocolos VTPE e TEMPRA (cf seção \ref{sec:TempraVTPE}), \doris{}
utiliza o modelo de comunicação \ing{publish-subscribe} \cite{Dolejs04}, de acordo
com o qual, quando uma aplicação quer enviar uma mensagem, ela utiliza o endereço
Ethernet de comunicação um-para-todos padrão (\cod{FF:FF:FF:FF:FF:FF}).
% Porém, várias aplicações podem ser hospedadas numa mesma estação. Para identificar
% as mensagens de cada aplicação, usa-se o \ing{type field} do quadro Ethernet
% \ref{fig:ethernetFrame}.
Quando um servidor \doris recebe uma mensagem, ele determina, de acordo com a
identidade do seu emissor, se tiver alguma aplicação interessada naquela
mensagem. Caso positivo, ele entrega a mensagem. Senão, ele a descarta.  A
princípio, as tarefas não precisam completar o processamento de todas as mensagens
críticas. No entanto, para simplificar o modelo, assume-se aqui que todas as
mensagens críticas são inteiramente processadas por todas as tarefas.

Em relação ao modelo temporal, assume-se um sistema distribuído síncrono. Isto significa
que as operações efetuadas pelas estações podem ser sincronizado uma com a outra. 
Esta suposição se baseia no esquema de divisão temporal de \doris, que como será vista, 
tem pontos de sincronização regulares e previsíveis, que ocorre dentro de uma janela
de tempo curta comparada com o desvio dos relógios locais. Isto implica que
os relógios locais das estações são sincronizados.

Por fim, assume-se que as estações podem falhar por \ing{crash}, ou seja, parar
qualquer tipo de atividade \cite{Schlichting83}, e voltar a funcionar normalmente
depois de um tempo arbitrário. Mensagens enviadas podem eventualmente ser perdidas,
porém, estações rápidas devem imperativamente perceber a interrupção associada a
recepção de uma mensagem, mesmo que o conteúdo da mensagem seja perdido. Como será
visto, este requisitos é necessário para controlar a circulação do bastão circulante
entre os processos.  De acordo com as necessidades das aplicações críticas, esta
restrição não se aplica às estações lentas, pois têm capacidades de processamento
menores.


\subsection{O esquema de Controle de Acesso ao Meio}
\label{sec:dorisMAC}

A comunicação num barramento \doriss é temporalmente dividida em uma alternância de
fases (\ing{rounds}) de comunicação (\emph{C-Rd}) e fases (\ing{rounds}) de
configuração dos membros (\emph{M-Rd}), assim como ilustrado na figura
\ref{fig:dorisStruct}. Durante a fase de configuração, o algoritmo de controle da
composição do segmento \doriss é responsável por estabelecer uma visão única da
composição do grupo de participantes do segmento \doris, compartilhada por todos os
membros deste segmento. O problema do estabelecimento de tal visão, conhecido também
como o problema do consenso, é assuntos de vários trabalhos \cite{Cristian88,
  Chandra96, Lamport98}.  No contexto desta dissertação, considera-se que os grupos
de tarefas \cmtla{TaskSet} e processos \cmtla{ProcSet} são definidos em tempo de
projeto e especifica-se somente a fase de comunicação do protocolo
\doriss. Denota-se $nTask$ e $nProc$ os cardinais destes dois conjuntos.

\begin{figure}[tb]
  \centering
  \input{fig/dorisStruct.pstex_t}
  \caption{O esquema de Divisão Temporal de \doris}
  \label{fig:dorisStruct}
\end{figure}

Usando TDMA, cada fase de comunicação (\emph{C-Rd}) é definida como um número
arbitrário, porém fixo, de ciclos periódicos, os quais são subdivididos em
exatamente $nTask$ \ing{chips} (ver figura \ref{fig:dorisStruct}). Um mapeamento dos
naturais sobre o conjunto dos \ing{chips} associa um inteiro positivo módulo $nTask$
a um \ing{chip}. Este contador é denotado $chipCount$. Cada chip é, por sua vez,
dividido em duas janelas, críticas e não-críticas, denotadas \HW e \SW, e
associadas, respectivamente, as comunicações de tempo real críticas e
não-críticas. As tarefas só transmitem mensagens durante as janelas \HW, enquanto
os processos apenas utilizam \SW{} para transmitir as suas. Os tamanhos destas duas
janelas são respectivamente denotados por \DHW e \DSW e o tamanho de um chip é
definido por $\DDC = \DHW + \DSW$. Para permitir um certa flexibilidade e a
definição de políticas de escalonamento das mensagens, a janela \HW é também
subdividida em dois \ing{slots}: o \ing{slot} elementar (\ES) e o \ing{slot} de
reserva (\RS).  As mensagens transmitidas nos \ing{slots} \ES{} e \RS{} são mensagens
críticas, chamadas respectivamente de mensagem elementar e de reserva. Uma vez por
ciclo, cada tarefa envia uma mensagem elementar dentro de \ES{} enquanto \RS{} é
utilizada para oferecer um mecanismo de reserva. De forma a tolerar falhas por
\ing{crash} e prover confiabilidade do sistema inteiro, tarefas não falidas são
obrigadas a enviar uma única mensagem elementar por ciclo.

Observa-se que, com o objetivo de facilitar a apresentação e a especificação de
\doris, assume-se que cada tarefa pode enviar uma única mensagem elementar por
ciclo. No entanto, esta suposição poderia ser levada, de acordo com o algoritmo
utilizado na fase de configuração, alocando um número arbitrário de \ing{chip} por
ciclo a cada servidor.  Caberia então a cada servidor alocar seus \ing{chips} às tarefas
sob sua responsabilidade. 

O mecanismo de reserva funciona da seguinte maneira. Cada mensagem elementar enviada
por uma tarefa $i$ carrega uma lista de inteiros (módulo $nTask$) que especifica os
identificadores dos \ing{slots} que $i$ pretende usar para enviar mensagens
adicionais. Esta lista é um subconjunto do conjunto dos $nTask$ \ing{chips} seguindo
o \ing{chip} no qual $i$ envia sua mensagem. A tarefa $i$ só pode reservar um
\ing{slot} que ainda não foi reservado por uma outra tarefa. Para este efeito, cada
servidor mantém uma vetor de reservas, denotada $res$, na qual ele armazena as
reservas especificadas em cada mensagem elementar recebida. A consistência do vetor
$res$ pode eventualmente ser comprometida por falhas de omissão de mensagens
elementares. Efetivamente, quando um servidor não recebe uma mensagem elementar, ele
deixa de atualizar $res$ e alguma tarefa pode tentar reservar algum
\ing{slot} previamente reservado. Para evitar tal cenário que poderia levar a uma
colisão, uma tarefa $T_i$ só pode reservar um \ing{slot}, se o vetor $res$ do
seu servidor estiver em estado consistente, isto é, se o servidor de $T_i$ tiver
recebido as $nTask$ mensagens elementares precedendo o \ing{chip} de emissão de
$T_i$. Desta forma, a alocação dinâmica de \ing{slots} de reserva é tolerante à
falhas de omissão. Este mecanismo de reserva é uma inovação do protocolo \doriss que
permite a implementação de alguma política de escalonamento. Efetivamente, uma
tarefa dispõe de um \ing{slot} elementar por ciclo e pode usar até $nTask$ outros
\ing{slots}. No entanto, a discussão de tal política foge do escopo desta
dissertação.

O controle de acesso ao meio de \doriss é organizada por um bastão circulante 
virtual, que circula nos anéis críticos e não-críticos (ver seção \ref{sec:dorisModel}).
O bastão circulante é dito virtual porque sua transmissão é associada à regras temporais
e lógicas baseadas na observação da comunicação acontecendo. A isolação dos dois 
anéis de \doriss é garantida pelo uso do mecanismo de TDMA. Em relação ao anel
não-crítico, o bastão virtual circula durante a janela \SW{} a cada vez que uma interrupção é
gerada pela placa de rede. Quando um processo não tem nenhuma mensagem à transmitir,
o servidor envia uma mensagem de tamanho mínimo para passar o bastão circulante ao
próximo processo do anel não-crítico.
 
Observa-se que numa fase inicial de concepção do protocolo \doris, pensou-se em
utilizar a capacidade de sensoriamento do meio para organizar a transmissão do
bastão utilizando o mecanismo TPR do protocolo Tempra \ref{sec:TempraVTPE}. No
entanto, em frente a dificuldade de conseguir placas de rede que permitam o acesso ao
estado do meio (\ing{idle} ou ocupado), esta possibilidade foi descartada. 


\section{A especificação formal de \doris }
\label{sec:dorisSpec}

A metodologia descritiva para apresentar a especificação de \doriss segue uma
abordagem indo de cima para baixo. Antes de entrar na descrição dos detalhes da
especificação, a seção \ref{sec:modelHipot} descreve o conjunto das hipóteses de
modelagem adotadas para especificar o protocolo. Em seguida, a seção
\ref{sec:basicTLA} introduz alguns conceitos básicos de TLA+. As demais seções
apresentam as principais fórmulas que compõe a especificação formal de \doris. No
âmbito de focalizar a descrição da especificação no protocolo \doris e na
verificação das suas propriedades, algumas fórmulas foram omitidas. No entanto, a
especificação completa está sendo anexada no final desta dissertação no apêndice
\ref{ap:dorisSpec}.

\subsection{Hipóteses de modelagem}
\label{sec:modelHipot}

Características importantes do sistema devem ser incluídas na especificação de modo
que se possa verificar propriedades interessantes. No entanto, é preciso ter cuidado
para não especificar muitos detalhes devido ao problema da explosão de estados
durante a verificação automática do modelo. As suposições feitas nesta seção tem por
finalidade contornar este problema sem comprometer a descrição o protocolo e sua
verificação.

Em primeiro lugar, como o nosso principal objetivo aqui é fornecer uma descrição
formal do protocolo \doris, a fim de verificar a sua correção, suponha-se que cada
estação hospeda apenas uma tarefa ou processo. Desta forma, evita-se a necessidade
de especificar os servidores \doris.

Em segundo lugar, representa-se o tempo por uma variável inteira. Embora tal
representação discreta do tempo possa comprometer a precisão do modelo no caso de
sistemas assíncronos em geral \cite{Clarke99}, ela é aceitável para protocolos síncronos
baseados em troca de mensagens \cite{Lamport05}.

Em terceiro lugar, considera-se que, sempre que uma ação especificada for habilitadas,
ela acontece sem demora ou é desabilitada imediatamente. Isto significa
que os temporizadores são especificados sem desvios.

Finalmente, considera-se que todas as estações compartilham um relógio comum global,
pois assume-se um modelo síncrono para evitar a especificação de detalhes de
sincronização. Observa-se que na prática todos as estações podem sincronizar os seus
relógios locais com precisão, pois as mensagens elementares são obrigatórias e
periódicas.  Detalhes de tal procedimento serão abordados na fase de implementação
descrita no capítulo \ref{cap:implementacao}.

É importante notar que as considerações sobre o desvio nulo dos relógios e sobre a
sincronia do sistema permite a definição de temporizadores global na especificação,
o que reduz consideravelmente os problemas de explosão de estados.

\subsection{Conceitos de TLA+}
\label{sec:basicTLA}

A Lógica Temporal de Ações (TLA) e sua linguagem formal associada (TLA +) combina a
Lógica Temporal de TLA \cite{Lamport94a} com a expressividade da lógica dos
predicados e a teoria dos conjuntos de Zermelo-Fraenkel. Dotado do verificador de
modelo TLC \cite{Yu99}, TLA+ permite a especificação e a verificação tanto de
protocolos de \ing{hardware} quanto de sistemas distribuídos. Esta seção apresenta
algumas sintaxes básicas de TLA +. Quando necessário, informações complementares
sobre TLA + serão dada ao longo da descrição da especificação de \doris.  Leitores
interessados numa descrição ampla de TLA + podem se referir a publicação de Lamport
\cite{Lamport02a}.

Numa especificação em TLA+, uma computação de um sistema é representada por um
seqüência de estados, também chamada de comportamento. Para caracterizar os estados
do sistema, uma especificação define o conjunto de variáveis (\textsc{variables})
utilizado para descrever o sistema e o conjunto de constantes (\textsc{constants}),
que são utilizadas para definir os valores eventualmente atribuídos às variáveis.
Um \textbf{estado} do sistema é portanto definido pela atribuição de valores
constantes, às variáveis da especificação.

Um pare de estados consecutivos, suponha $i$ e $f$ em referência a inicial e final,
é chamada de \textbf{passo} e é denotado \txtla{i \.{\rightarrow} f}. O operador
linha ``\txtla{\,'\,}'' é utilizado para distinguir os valores de variáveis num
passo. Considerando um certo passo \txtla{P: i \.{\rightarrow} f} e uma variável
$v$, a ocorrência de $v$ sem linha ($v$) faz referência ao valor de $v$ em $i$,
enquanto a ocorrência de $v$ com linha ($v'$) faz referência ao valor de $v$ em $f$.

Uma \textbf{função de estado} é um expressão na qual aparecem somente variáveis sem
linhas. Tal função associa valores constantes aos estados de um comportamento.  As
funções de estado a valores booleanas são simplesmente chamados de \textbf{predicados} de
estado. 

Uma \textbf{função de transição} é uma expressão na qual aparecem variáveis sem
linhas e com linhas. Portanto, denotando $\mathcal{P}$ o conjunto dos passos de um
sistema, uma função de transição $F$ é um mapeamento de $\mathcal{P}$ sobre
$F(\mathcal{P})$. Por exemplo, seja um passo \txtla{P: i \.{\rightarrow} f} e $v$
uma variável, tal que $v = 0$ no estado $i$ e $v = 1$ no estado $f$, e seja $F$ a
função de transição definida por $F(P) = v' - v$, tem-se $F(P) = 1$.

Finalmente, uma \textbf{ação} é, por definição, uma função de transição a valores
booleana. Portanto, uma ação é um mapeamento de $\mathcal{P}$ sobre $\{ V, F \}$,
onde $V$ e $F$ correspondem aos valores de verdade e falso da lógica dos
predicados. Considerando o exemplo apresentado acima, a ação $\mathcal{A}$, definida
pela expressão \txtla{\mathcal{A} \defeq v' = v + 1}, na qual o símbolo TLA+ significa
 ``igual, por definição'', é verdadeira no passo $P$.
%Observa-se aqui que o significado do símbolo TLA+ ``\txtla{\defeq}'' é: ``igual, por definição''.  
Para um dado passo $P$, a relação de sucessão do estado
$i$ para o estado $f$, usualmente chamada de função de transição de estado no
formalismo das Máquinas de Estado Finitos, é definida pelo conjunto de ações
definidas sobre o passo $P$. Este conjunto também é uma ação, pois uma ação pode ser
composta de várias ações.

As fórmulas temporais de TLA+, como por exemplo, a relação de transição entre
estados, são asserções booleanas sobre comportamentos.  Diz-se que um comportamento
satisfaz uma fórmula $\mathcal{F}$ se $\mathcal{F}$ é uma asserção verdadeira deste
comportamento.  O operador da lógica temporal $\Box$ é utilizado para escrever as
fórmulas temporais. A semântica do operador $\Box$ é definida da seguinte maneira.
Para algum comportamento $\Sigma$, e alguma ação $\mathcal{A}$, a fórmula temporal
$\mathcal{F} = \Box [ \mathcal{A} ]_{vars}$ é verdadeira -- ou simplesmente ``$\, \Sigma$
satisfaz $\mathcal{F} \,$'' -- se e somente se, para qualquer passo  \txtla{P: i \.{\rightarrow} f} de
$\Sigma$ que altera o conjunto $vars$ de todas as variáveis, $A$ é verdadeira em
$P$.

\subsection{Constantes e variáveis}
\label{sec:consVar}

\begin{table}[t!b]
  \begin{center}
    \begin{tabular}{ | c |  p{12cm} | }
      \hline  \hline 
      \textbf{Constantes}
      & \textbf{Descrição}    \rule{0pt}{6.mm}  \\[1.4mm]
      \hline
      \txtla{nTask} \vbar     
      & Número de tarefas participando do segmento \doris. \vspc
      \hline
      \txtla{nProc} \vbar     
      & Número de processos participando do segmento \doris.  \vspc 
      \hline
      \txtla{deltaChip} \vbar     
      & Duração ($\Delta_C$) de um \ing{chip}.  \vspc 
      \hline
      \txtla{delta} \vbar     
      & Tempo de transmissão ($\delta$) de um quadro Ethernet de tamanho mínimo.  \vspc 
      \hline
      \txtla{pi} \vbar     
      & Tempo de processamento ($\pi$) de uma mensagem crítica pelo dispositivo
      mais lento.  \vspc 
      \hline
      \txtla{maxTxTime} \vbar     
      & Tempo de transmissão de um quadro Ethernet de tamanho máximo.  \vspc 
      \hline \hline
    \end{tabular}
    \caption{O conjunto \textsc{constants} da especificação de \doris}
    \label{tab:specCons}
  \end{center}
\end{table}

As constantes da especificação de \doriss são definidas na tabela
\ref{tab:specCons}. Um conjunto de valores possível para verificar \doris é, por
exemplo: $nTask = 8, nProc = 7, deltaChip = 300, delta = 6, pi = 111, maxTxTime =
122$. Os valores de $nTask$ e $nProc$ são escolhidos arbitrariamente. Porém, valores
muito grandes provocam uma explosão do número de estados do sistema.  Os valores de
delta ($\delta$) e $maxTxTime$ correspondem aos tempos de transmissão em $\mu s$ de
mensagens de 72 bytes e 1524 bytes num barramento Ethernet de 100Mbps (ver seção
\ref{sec:sisHibrid}).  $pi$ ($\pi$) é o tempo utilizado por \cite{Carreiro03}. Finalmente,
$\Delta_C$ deve ser maior que $2 \pi$, para garantir que as duas mensagens críticas
enviadas num \ing{chip} sejam processadas antes do início do próximo \ing{chip}.

\newcommand{\loclenA}{18.5mm}
\newcommand{\loclenB}{98.mm}
\newcommand{\loclenR}{2.5mm}
%\bigskip
\begin{table}[htb!]
  \begin{center}
    \begin{tabular}{ | p{20.5mm} | @{} p{125mm} @{} |}
      \hline  \hline 
      \textbf{Variável}
      &
      \begin{tabular}{  p{\loclenA} | p{\loclenB} }
        \textbf{Campo}  & \textbf{Descrição} \rule{0pt}{6.mm}  \\[1.4mm]
      \end{tabular}\\

      \hline
      \parbox{20.5mm}{\txtla{Shared} (global)}
      &
      \begin{tabular}{  p{\loclenA} | p{\loclenB} }
        \raisebox{-\loclenR}{\txtla{chipTimer}} 
        & \vbar é um temporizador crescente, que varia de 0 a $\Delta_C$,  e representa
        o fluxo do tempo durante um \ing{chip}. %\newline (\txtla{deltaChip}). 
         \vspc \hline

        \txtla{chipCount}
        & \vbar é um contador que identifica os \ing{chips} módulo $nTask$. 
         \vspc \hline 
        
        \raisebox{-5mm}{\txtla{medium}}\vbar
        & representa o estado do meio.  Na ausência de transmissão, \txtla{medium} vale
        \txtla{\{ \}}. Senão, \txtla{medium} contem uma mensagem em fase de transmissão. 
        \vspc \hline     

        \raisebox{-5mm}{\txtla{macTimer}}\vbar
        & é um temporizador decrescente que indica o tempo faltando para
        completar a transmissão de uma mensagem. Em particular, 
        \txtla{\; macTimer \.{=} 0 \; \.{\implies} \;  medium \.{=} \{ \}}. \vspc 
      \end{tabular}\\

      \hline
      \parbox{20.5mm}{\txtla{TaskState} (vetor local)}
      &
      \begin{tabular}{  p{\loclenA} | p{\loclenB} }
        \raisebox{-\loclenR}{\txtla{msg}}\vbar
        & representa a lista de mensagens críticas armazenadas na memória tampão (DMA)
        após recepção na placa de rede. \vspc  \hline

        \raisebox{-5mm}{\txtla{execTimer}}\vbar
        & é um temporizador decrescente que indica o tempo de execução faltando para
        completar o processamento de uma mensagem crítica. \vspc \hline

        \raisebox{-\loclenR}{\txtla{res}}\vbar
        & é a lista de \txtla{nTask} reservas existentes para os \txtla{nTask}
        próximos \ing{slots}. \vspc \hline

        \raisebox{-5mm}{\txtla{cons}}\vbar
        & é um contador que contabiliza o número de mensagens elementares recebidas
        entre duas emissões consecutivas de mensagens elementares. \vspc
      \end{tabular}\\

      \hline
      \parbox{20.5mm}{\txtla{ProcState} (vetor local)}
      &
      \begin{tabular}{  p{\loclenA} | p{\loclenB} }
        \raisebox{-\loclenR}{\txtla{token}}\vbar
        & é o contador associado ao bastão circulante utilizado nas janelas \SW.  \vspc  \hline

        \raisebox{-\loclenR}{\txtla{list}}\vbar
        & é a lista das mensagem não-críticas esperando para ser enviadas.  \vspc  \hline

        \raisebox{-\loclenR}{\txtla{count}}\vbar
        & é um contador que contabiliza o número de mensagens não-críticas recebidas
        durante uma janela \SW.  \vspc
      \end{tabular}\\

      \hline
      \parbox{20.5mm}{\txtla{History} (observador global)}
      &
      \begin{tabular}{  p{\loclenA} | p{\loclenB} }
        \raisebox{-\loclenR}{\txtla{elem}}\vbar
        & é um contador que contabiliza o número de mensagens elementares enviadas
        num ciclo. \vspc \hline
      
        \raisebox{-\loclenR}{\txtla{rese}}\vbar
        & é um contador que contabiliza o número de mensagens de reservas enviadas
        num ciclo.  \vspc 
      \end{tabular}\\
      \hline \hline
    \end{tabular}
    \caption{O conjunto \textsc{variables} da especificação de \doris}
    \label{tab:specVars}
  \end{center}
\end{table}

%\clearpage

Outras constantes podem ser definidas no decorrer da especificação, utilizando o
símbolo ``\txtla{\defeq}'' (cujo significado é: ``igual, por definição'').  Por
exemplo, definem-se \txtla{ Task \.{\defeq} 1 \.{\dotdot} nTask} e \txtla{ Proc
  \.{\defeq} 1 \.{\dotdot} nProc}, os dois conjuntos de inteiros respectivamente
isomorfos a \txtla{TaskSet} e \txtla{ProcSet}.  Nestas definições, a definição do
símbolo ``\txtla{\,{..}}'' é: para dois inteiros $i$, $j$ tal que $i < j$, \txtla{ i
  \.{\dotdot} j \.{\defeq} \{ i ,\, i \.{+} 1 , \.{\ldots} ,\, j \}}. Outros
exemplos são as definições subseqüente dos conjuntos: \txtla{TaskSet \.{\defeq} \{ T
  [ i ] \.{:} i \.{\in} Task \}} e \txtla{ProcSet \.{\defeq} \{ P [ j ] \.{:} j
  \.{\in} Proc \}}.

Em relação as variáveis da especificação, apresentadas na tabela \ref{tab:specVars},
agrupou-se elas em quatro estruturas chamadas $Shared$, $TaskState$, $ProcState$ e
$History$ de acordo com as suas características. A variável $Shared$ é uma tupla com
quatro campos, utilizada para armazenar a visão distribuída compartilhada por
todos. As duas outras variáveis, $TaskState$ e $ProcState$, são vetores de dimensão
respectivas $nTask$ e $nProc$, que armazenam em tuplas de 4 e 3 campos, as
informações locais de cada tarefa e processo.  Finalmente, a variável $History$ é
uma tupla com 2 campos, utilizada para especificar propriedades temporais. Esta
variável é apenas um ``observador'' que não interfere na especificação do
protocolo. O detalhe da definição dos diferentes campos destas quatro variáveis é
apresentado na tabela \ref{tab:specVars}.


\subsection{A fórmula principal de \doris}
\label{sec:formPrinc}

\act{Spec} A fórmula \txtla{Spec}, fórmula principal da especificação de \doris{}, é apresentada na
figura \ref{fig:formPrinc2}.

\begin{tlafig}
\begin{tla}
  Spec == Init /\ [] [ Next \/ Tick ]_vars /\ Liveness
\end{tla}
\begin{tlatex}
 \@x{ \@s{94} Spec \.{\defeq} Init \.{\land} {\Box} [ Next \.{\lor} Tick ]_{
 vars} \.{\land} Liveness}%
\end{tlatex}
\tlacaption{A fórmula Spec \label{fig:formPrinc2}}
\end{tlafig}

\txtla{\quad \; Init} é o conjunto dos estados iniciais, \txtla{{\Box} [ Next \.{\lor} Tick
  ]_{ vars}} é a relação de sucessão, aqui composta da disjunção das duas ações
\txtla{Next} ou \txtla{Tick}, e \txtla{Liveness} é uma condição de evolução do
sistema.  \txtla{Next} e \txtla{Tick} são os conjuntos de ações que podem ser
verdadeira num certo passo de um comportamento. Conseqüentemente, um comportamento
$\Sigma$ satisfaz \txtla{Spec} se e somente se o primeiro estado de $\Sigma$ é um
elemento de \txtla{Init} e se todos os passos de $\Sigma$ satisfazem \txtla{Next} ou
\txtla{Tick} e a condição \txtla{Liveness}.

Observa-se que em conseqüência da estrutura temporal de \doris, vista na seção
\ref{sec:dorisMAC}, a maioria das ações de \doris{} são regidas por condições
exclusivas. Portanto, o operador ``\txtla{\lor}'' é exclusivo em quase todas as suas
ocorrências.

\act{Init} A fórmula \txtla{Init}, apresentada na figura \ref{fig:Init}, descreve o
conjunto dos estados iniciais do sistema, ou seja, \txtla{Init} é a definição dos
conjuntos de valores inicias possíveis para cada variável da especificação. Aqui,
cada conjunto tem um elemento só, pois considera-se um estado inicial único do
sistema.

\begin{tlafig} 
\begin{tla}
Init ==
      /\ Shared = [ chipTimer |-> 0, chipCount |-> 1, macTimer |-> 0, medium |-> {} ]
      /\ TaskState = [ i \in Task |-> [ msg |-> << >>, execTimer |-> Infinity, 
                                        res |-> [ j \in Task |-> -1 ], cons |-> nTask - i + 1 ] ] 
      /\ ProcState = [ j \in Proc |-> [ token |-> 1, list |-> list(j), count |-> 0 ] ]
      /\ History = [ elem |-> 0, rese |-> 0 ]
\end{tla}
\begin{tlatex}
\@x{ Init \.{\defeq}}%
 \@x{\@s{23.85} \.{\land} Shared \.{=} [ chipTimer \.{\mapsto} 0 ,\, chipCount
 \.{\mapsto} 1 ,\, macTimer \.{\mapsto} 0 ,\, medium \.{\mapsto} \{ \} ]}%
 \@x{\@s{23.85} \.{\land} TaskState \.{=} [ i\@s{0.51} \.{\in} Task
 \.{\mapsto} [ msg \.{\mapsto} {\langle} {\rangle} ,\, execTimer \.{\mapsto}
 Infinity ,\,}%
 \@x{\@s{174.68} res\@s{5.30} \.{\mapsto} [ j \.{\in} Task \.{\mapsto} \.{-} 1
 ] ,\, cons \.{\mapsto} nTask \.{-} i \.{+} 1 ] ]}%
 \@x{\@s{23.85} \.{\land} ProcState\@s{0.58} \.{=} [ j \.{\in} Proc\@s{1.18}
 \.{\mapsto} [ token\@s{8.52} \.{\mapsto} 1 ,\, list \.{\mapsto} list ( j )
 ,\, count \.{\mapsto} 0 ] ]}%
 \@x{\@s{23.85} \.{\land} History \.{=} [ elem \.{\mapsto} 0 ,\, rese
 \.{\mapsto} 0 ]}%
\end{tlatex}
\tlacaption{A fórmula $Init$ \label{fig:Init}}
\end{tlafig} 

É importante esclarecer aqui duas particularidades de TLA+. Em primeiro lugar, em
TLA+, a indentação das formulas é utilizada, em combinação com as conjunções e os
operadores lógicos, para limitar o uso de parênteses.  Em segundo lugar, uma
expressão tal que, por exemplo, \txtla{[ j \.{\in} Task \.{\mapsto} \.{-} 1 ]},
representa o vetor de dimensão $nTask$ cujo as coordenadas são $-1$. O símbolo
$\mapsto$ é utilizado aqui para assinar valores as entradas do vetores.  Isto
implica, neste caso, que, no estado inicial: \begin{tlatex} \@xx{ \A\, i ,\, j
    \.{\in} Task \.{:}\@s{4.1} TaskState [ i ] . res [ j ] \.{=} \.{-}
    1} \end{tlatex}. Lembrar da seção \ref{sec:dorisMAC} que $res$ é o vetor que
armazena as reservas recebidas por uma tarefa. O valor arbitrário $-1$ é utilizado
aqui, para indicar que não há reserva para o \ing{slot} correspondente.

Voltando à descrição da fórmula \txtla{Init}, os valores definidos para os quatro
campos da variável global \txtla{Shared} indicam que o \ing{chip}~$1$
\cmtla{chipCount \.{\mapsto} 1} está iniciando \cmtla{chipTimer \.{\mapsto} 0}, que
o meio está vazio \cmtla{medium \.{\mapsto} \{ \}} e que \txtla{macTimer}
é nulo, pois nenhuma mensagem está sendo transmitida.

No caso das variáveis locais, \txtla{TaskState} e \txtla{ProcState}, as fórmulas têm
o seguinte significado. Cada tarefa $i$ do conjunto \txtla{Task} assume que:

\begin{itemize}
\item A sua lista de mensagens críticas para ser processadas está vazia \cmtla{msg
    \.{\mapsto} {\langle} {\rangle}}
\item Conseqüentemente, o temporizador \txtla{execTimer}, utilizado para representar
  o tempo de execução faltando para processar um mensagem crítica, é desabilitado
  (\txtla{execTimer \.{\mapsto} Infinity });
\item A sua lista de reservas está vazia, ou seja, todas os campos do vetor
  \txtla{res} valem $-1$ \cmtla{res \.{\mapsto} [ j \.{\in} Task \.{\mapsto} \.{-} 1
    ]};
\item Ela esta num estado consistente \cmtla{cons \.{\mapsto} nTask \.{-} i \.{+} 1
  }. Lembrar que uma tarefa está num estado consistente se ela recebeu todas as
  mensagens elementares desde o último \ES{} no qual ela enviou uma mensagem (ver
  seção \ref{sec:dorisMAC}).
\end{itemize}

Cada processo $j$ do conjunto \txtla{Proc}:
\begin{itemize}
\item Assume que o processo $1$ está em posse do bastão circulante \cmtla{token
    \.{\mapsto} 1};
\item Utiliza a função de estado \txtla{list} (ver figura \ref{fig:listFunc}), para definir a
  lista da suas mensagens não-críticas. 
\item Assume que ele ainda não recebeu nenhuma mensagem não-crítica \cmtla{count
    \.{\mapsto} 0}.
\end{itemize}

Finalmente, os dois contadores de mensagens elementares e de reservas da variável de
observação \txtla{History} são inicializados a ``$0$'' \cmtla{elem \.{\mapsto} 0 ,\, rese
 \.{\mapsto} 0}. 

\act{list} A função \txtla{ list }, apresentada na figura \ref{fig:listFunc}, define a lista
de mensagem à ser enviadas por cada processo durante um ciclo de \doris. Esta função
é escolhida arbitrariamente de acordo com o cenário de verificação desejado.

\begin{tlafig} 
\begin{tla}
list(j) == CASE j \in { 1 } -> [ i \in 1..4 |-> [ txTime |-> maxTxTime ] ]
           []   j \in { 2 } -> << >>
           []   j \in Proc \ { 1, 2 } -> 1 :> [ txTime |-> maxTxTime ]
\end{tla}
\begin{tlatex}
 \@x{ list ( j ) \.{\defeq} {\CASE} j \.{\in} \{ 1 \} \.{\rightarrow} [ i
 \.{\in} 1 \.{\dotdot} 4 \.{\mapsto} [ txTime \.{\mapsto} maxTxTime ] ]}%
 \@x{\@s{70.26} {\Box}\@s{4.1} j \.{\in} \{ 2 \} \.{\rightarrow}
 {\langle} {\rangle}}%
 \@x{\@s{70.26} {\Box}\@s{4.1} j \.{\in} Proc \.{\,\backslash\,} \{
 1 ,\, 2 \} \.{\rightarrow} 1 \.{\colongt} [ txTime \.{\mapsto} maxTxTime ]}%
\end{tlatex}
\tlacaption{A função $list$ \label{fig:listFunc}}
\end{tlafig} 

Aqui, a função $list$ utiliza a construção TLA+ ``\textsc{CASE}, \txtla{\.{\Box}},
\txtla{\.{\rightarrow}}'' para diferenciar as tuplas de acordo com o valor de
$j$. Em tal construção, o símbolo \txtla{\.{\Box}} é utilizada para listar todos os
casos do \textsc{CASE}, e o símbolo \txtla{\.{\rightarrow}} indica o valor para ser
adotado em cada caso. Neste exemplo, as tuplas de mensagens definidas para cada
processo são: $list(1)$ de $P[1]$ contem 4 mensagens, cada uma com o tempo de
processamento ($txTime$) de uma mensagem Ethernet de tamanho máximo ($maxTxTime$);
$list(2)$ de $P[2]$ está vazia; para os demais processos, $list(j)$ contem apenas uma
mensagem de tamanho máximo.

\act{Next} Esta ação, apresentada na figura \ref{fig:Next}, descreve as
funcionalidades do protocolo que acontecem instantaneamente, ou seja, as ações que
não decrementam os temporizadores, pois suas durações são muito curtas,
comparativamente com os tempos de transmissões das mensagens.  Isto é o caso aqui,
das operações de emissão e recepção de mensagens.  Lembrar que, para as tarefas,
receber não significa processar, mas somente colocar na memória tampão da placa de
rede.

\begin{tlafig} 
\begin{notla}
Next  ==  \/ \E t \in TaskSet : SendElem(t) \/ SendRese(t)
          \/ \E p \in ProcSet : SendSoft(p)
          \/ \E msg \in Shared.medium : RecvHard(msg) \/ RecvSoft(msg)
\end{notla}
\begin{tlatex}
 \@x{ Next\@s{4.1} \.{\defeq}\@s{4.1} \.{\lor} \E\, t\@s{1.69} \.{\in} TaskSet
 \.{:} SendElem ( t ) \.{\lor} SendRese ( t )}%
\@x{\@s{55.22} \.{\lor} \E\, p \.{\in} ProcSet\@s{0.58} \.{:} SendSoft ( p )}%
 \@x{\@s{55.22} \.{\lor} \E\, msg \.{\in} Shared . medium \.{:} RecvHard ( msg
 ) \.{\lor} RecvSoft ( msg )}%
\end{tlatex}
\tlacaption{A ação $Next$ \label{fig:Next}}
\end{tlafig} 

Como pode ser observado, a ação \txtla{Next} é uma disjunção de cinco ações,
correspondendo à emissão e recepção de mensagens. O uso do operador \txtla{\E}
permite expressar a dependência de uma ação no seu argumento. Por exemplo, a ação
\txtla{SendElem} só pode satisfazer um passo $P$ se existir uma tarefa $t$ tal que
\txtla{SendElem ( t )} seja verdadeira em P.  A primeira linha da ação \txtla{Next}
especifica à emissão de uma mensagem por uma tarefa $t$ e a segunda, por um processo
$p$.  As duas ações \txtla{SendElem} e \txtla{SendRese} correspondem às janelas \HW
-- subdividida em \ES{} e \RS{} -- e a ação \txtla{SendSoft} corresponde a janela \SW.
A terceira linha especifica a recepção de uma mensagem presente no meio, de acordo
com o seu tipo.  \txtla{RecvHard} corresponde à recepção de uma mensagem crítica,
enquanto \txtla{RecvSoft} corresponde à recepção de uma mensagem não-crítica.

Assim que será visto nas próximas seções, cada uma destas ações é regida por um conjunto
de predicados, também chamado de condições de realizações ou guardas (\ing{enabling
  conditions}).

Considera-se agora um estado $e$ alcançável da especificação, isto é,
tal que tenha uma seqüência de passos levando de \txtla{i \.{\in} Init} até
$e$. Suponha, ainda, que no estado $e$, pelo menos um dos guardas das cinco ações
sejam falsos. Neste caso, não existe estado $f$ tal que \txtla{Next} satisfaz o passo 
\txtla{e \rightarrow f}. Isto pode acontecer por duas razões. O sistema ficou
numa situação de bloqueio (\ing{deadlock}) por causa de um erro de especificação
 ou de projeto, ou a ação \txtla{Tick} está habilitada.

\act{Tick} Esta ação, definida pela fórmula \txtla{Tick \.{\defeq} NextTick \.{\lor}
  NextChip} especifica o fluxo do tempo. Para permitir a verificação de alguns
modelos finitos do sistema, apesar da natureza sem limite do tempo, utilizou-se uma
representação do tempo circular. Isto foi realizado dividindo a ação \txtla{Tick} na
disjunção de duas ações: \txtla{NextTick}, que incrementa o tempo por passos
discretos, e \txtla{NextChip}, que realiza a transição de um \ing{chip} para o
próximo, incrementando o valor do contador $chipCount$. Se fosse só a ação
\txtla{NextTick}, o temporizador \txtla{chipTimer} ia crescer
indefinidamente. Porém, a cada vez que ela acontece, a ação \txtla{NextChip}
redefine o temporizador \txtla{chipTimer} para o valor ``$0$'' de tal forma
que este temporizador varia de ``$0$'' a $\Delta_C$. Além disso, o contador
$chipCount$ é também redefinido para o seu valor inicial $1$, sempre que ele atínge
o valor $nTask$. Desta forma, a representação do tempo permite verificar
comportamentos do sistema durante um ciclo completo de \doris.

\act{Liveness} Esta restrição, definida pela fórmula \txtla{Liveness
  \.{\defeq} {\Box} {\Diamond} Tick}, (na qual \txtla{ {\Diamond} F
  \.{\defeq} {\neg} {\Box} {\neg} F}) garante que um comportamento que satisfaz
$Spec$ tenha estados em todos os \ing{chips} de um ciclo de \doris. De fato, devido
a representação circular do tempo, \txtla{Liveness} é satisfeita apenas por
comportamentos cíclicos, porém sem bloqueio, permitindo a verificação de modelos
finitos de \doris.

\begin{comment}
  \iniTLA
  \begin{notla}
    Liveness == []<> Tick
  \end{notla}
  \begin{tlatex}
    \@x{ Liveness \.{\defeq} {\Box} {\Diamond} Tick}%
  \end{tlatex}
  \finTLA
\end{comment}

\subsection{Guia de leitura}
\label{sec:guiaLeitura}

Nesta seção, agrupou-se elementos de descrição gerais da especificação, assim como
algumas definição dos operadores de TLA+ mais usados. 

\act{Ações principais}Assim que foi visto na seção anterior, a especificação de
\doriss é constituída por 7 ações principais, as cinco que compõe a fórmula
\txtla{Next}, mais as duas que compõe a fórmula \txtla{Tick}.  O conjunto de fórmula
de cada uma destas ações principais é dividido em dois conjuntos lógicos
diferentes. O primeiro conjunto é constituído pelos guardas, predicados de estados
nos quais figuram constantes e variáveis sem linhas. Este conjunto representa as
condições de realização da ação.  Em seguida, o segundo conjunto é constituído pelas
ações -- nas quais figuram constantes, variáveis sem linhas e com linhas -- que
especificam as operações de \doris.

\act{Tarefas e Processos}Para representar os conjuntos \txtla{TaskSet} e
\txtla{ProcSet}, definiu-se os vetores $T$ e $P$ das tarefas e dos processos:

\begin{tlafor}
\begin{tla}
T == [ i \in Task |-> << "T", i >> ]   /\  P == [ j \in Proc |-> << "P", j >> ]
\end{tla}
\begin{tlatex}
 \@x{ T \.{\defeq} [ i \.{\in} Task \.{\mapsto} {\langle}\@w{T} ,\, i
 {\rangle} ]\@s{8.2} \.{\land}\@s{4.1} P \.{\defeq} [ j \.{\in} Proc
 \.{\mapsto} {\langle}\@w{P} ,\, j {\rangle} ]}%
\end{tlatex}
\end{tlafor}

Utilizando estes dois vetores, as expressões para  \txtla{TaskSet} e
\txtla{ProcSet} são dadas por:

\begin{tlafor}
\begin{tla}
TaskSet == { T[i]: i \in Task }  /\  ProcSet == { P[j]: j \in Proc }
\end{tla}
\begin{tlatex}
 \@x{ TaskSet \.{\defeq} \{ T [ i ] \.{:} i \.{\in} Task \}\@s{4.1}
 \.{\land}\@s{4.1} ProcSet \.{\defeq} \{ P [ j ] \.{:} j \.{\in} Proc \}}%
\end{tlatex}
\end{tlafor}

O símbolo ``$\,:\,$'' tem aqui o sentido ``tal que'' usual em matemática.

\act{O operador ``\txtla{\;@@\;}''} Este operador é utilizado para construir tuplas
a partir de tuplas menores. Considerando, por exemplo, dois conjuntos C e D, tal que
\txtla{D \subset C}, o operador ``\txtla{\;@@\;}'' pode ser definido pela fórmula
seguinte:

\begin{tlafor}
\begin{tla}
[ i \in D |-> << "v", i >> ] @@ [ i \in C \ D |-> << ''v'', i >> ] == [ i \in C |-> << ''v'', i >> ]
\end{tla}
\begin{tlatex}
 \@x{ [ i \.{\in} D \.{\mapsto} {\langle}\@w{v} ,\, i {\rangle} ] \.{\,@@\,} [
 i \.{\in} C \.{\,\backslash\,} D \.{\mapsto} {\langle}\@w{v}
 ,\, i {\rangle} ] \.{\defeq} [ i \.{\in} C \.{\mapsto} {\langle}\@w{v} ,\, i {\rangle} ]}%
\end{tlatex}
\end{tlafor}

\act{O operador ``\txtla{\,\CHOOSE}''} Numa expressão da forma, \txtla{\CHOOSE x
  \.{\in} C : F ( x )}, o operador \txtla{\CHOOSE} escolha um elemento $x$ qualquer do
conjunto $C$ tal que (``$\,:\,$'') a proposição $F(x)$ seja verdadeira. 

Por exemplo, considerando um elemento \txtla{t \.{\in} TaskSet} ou \txtla{p \.{\in}
  ProcSet}, o seu índice é encontrada pelas funções \txtla{taskId } e \txtla{procId}
assim definidas:

\begin{tlafor}
\begin{notla}
taskId(t) == CHOOSE i \in Task : t = T[i]
procId(p) == CHOOSE j \in Proc : p = P[j]
\end{notla}
\begin{tlatex}
\@x{ taskId ( t ) \.{\defeq} {\CHOOSE} i \.{\in} Task \.{:} t \.{=} T [ i ]}%
\@x{ procId ( p ) \.{\defeq} {\CHOOSE} j \.{\in} Proc \.{:} p \.{=} P [ j ]}%
\end{tlatex}
\end{tlafor}

Nestes exemplos, a escolha é única, pois existe um único índice verificando a
proposição especificada em ambos os casos.

\act{A construção ``\txtla{\,\LET} $\ldots\;$ \textsc{in }''} Esta construção
sintática é utilizada para definir constantes locais. O escopo das definições
efetuadas na cláusula do \textsc{\,let\,} é o conjunto de fórmulas da cláusula do
\textsc{\,in}.  Por exemplo, na seguinte expressão

\vspace{3mm}
\setstretch{0.}
\begin{tla}
\E t \in TaskSet : LET i == taskId(t)
                   IN F(i)
\end{tla}
\begin{tlatex}
\@x{ \@s{140}\E\, t \.{\in} TaskSet \.{:} \.{\LET} i \.{\defeq} taskId ( t )}%
\@x{\@s{220.17} \.{\IN} F ( i )}%
\end{tlatex}
\par\setstretch{1.4}

\noindent a constante $i$, definida como o índice da tarefa $t$, é conhecida apenas
na proposição $F(i)$.

\act{A construção ``\txtla{\EXCEPT}, \txtla{\;\.{!}\;} e \txtla{\;\.{@}\,}''} A palavra
\txtla{\EXCEPT}, juntamente com os símbolos \txtla{\;!\;} e \txtla{\;@}, é utilizada para
definir as ações que envolvem tuplas ou variáveis vetoriais. Por exemplo, a ação $A$, definida
por

\begin{tlafor}
\begin{tla}
A == History' = [ History EXCEPT !.elem = @ + 1 ]
\end{tla}
\begin{tlatex}
\@x{ A \.{\defeq} History \.{'} \.{=} [ History {\EXCEPT} ! . elem  \.{=} @ \.{+} 1 ]}%
\end{tlatex} 
\end{tlafor}

\noindent é verdadeira num passo \txtla{i \rightarrow f} se a tupla \txtla{History}
for igual nos dois estados $i$ e $f$, com a exceção do campo \txtla{elem}, cujo
valor no estado $f$ (\txtla{!.elem}) deve ser igual ao seu valor no estado $i$
($@$) incrementado de 1. O símbolo ``$\;!\;$'' é uma abreviação para o sujeito
%nome da variável que figura a esquerda
da palavra \textsc{except}, e o símbolo ``$@$'', por sua vez, representa o valor, no
estado $i$, do campo à ser modificado pela subordinada do %na cláusula
\textsc{except}.  Portanto, uma sintaxe equivalente de $A$, porém menos concisa,
seria:

\begin{tlafor}
\begin{tla}
A == History' = [ History EXCEPT History.elem' = History.elem + 1 ]
\end{tla}
\begin{tlatex}
\@x{ A \.{\defeq} History \.{'} \.{=} [ History {\EXCEPT} History. elem \.{'}
\.{=} History.elem \.{+} 1 ]}%
\end{tlatex} 
\end{tlafor}

\act{A construção ``\txtla{\; \CASE}, \txtla{\;\.{\Box}\;} e \txtla{\;\.{\rightarrow}}''}
O operador \txtla{\CASE} permite a escolha múltipla de valores, baseado no caráter de 
verdade de um conjunto de predicados logicamente exclusivos. Um exemplo de uso
desta construção pode ser visto na definição da função $list$, já apresentada na 
figura \ref{fig:listFunc}. 

\act{Indentação} Deve ser ressaltado que, em TLA+, a indentação é
utilizada preferencialmente no lugar de parênteses. Desta forma, os operadores
\txtla{\.{\land}} e \txtla{\.{\lor}} são utilizados para escrever fórmulas lógicas
complexas sob a forma de listas indentadas.

\act{O operador ``\txtla{\UNCHANGED}''} Finalmente, para otimizar o algoritmo de
verificação automática e garantir que a especificação de alguma ação não seja
esquecida, uma especificação em TLA+ deve imperativamente especificar, para cada uma
das ações principais da relação de transição, as regras de evolução de todas as
variáveis do conjunto $vars$. Se uma variável $v$ não for modificado, a ação
particular \txtla{ v \.{'} = v } é utilizada. Para efeito de concisão, a palavra
\txtla{\UNCHANGED E} é utilizada para definir o conjunto $E$ das variáveis não
modificadas por uma determinada ação. Por exemplo, \txtla{\quad {\UNCHANGED}
  {\langle} v {\rangle} \.{\defeq} v \.{'} \.{=} v}.


\subsection{O anel crítico}
\label{sec:anelCrit}

Assim que foi visto na seção \ref{sec:dorisMAC}, a alternância das janela \HW do
anel crítico e \SW{} do anel não-crítico é definida pelo mecanismo TDMA. Isto é
representado pelo temporizador \txtla{chipTimer}:  o valor ``$0$'' de \txtla{chipTimer}
indica que \HW começa, enquanto o valor $2 \delta$ indica que \SW{} começa.
Dentro da janela \HW, o valor $\delta$ de \txtla{chipTimer} indica que o \ing{slot}
de reserva começa. Além destas condições temporais,  a circulação do bastão 
no anel crítico utiliza condições lógicas baseadas no valor de \txtla{chipCount},
o contador de \ing{chip}. Detalhes desta condições serão dadas durante a descrição
das ações correspondentes.

O anel crítico é especificado pelas três ações principais \txtla{SendElem}, \txtla{SendRese}
e \txtla{RecvHard}, cuja descrição é o objeto desta seção.

% -------------------------------- Action -------------------------------
\act{SendElem} Esta ação, apresentada na figura \ref{fig:SendElem}, descreve as
regras que regem a emissão de uma mensagem elementar.

\begin{tlafig}
\begin{tla}
SendElem(t) ==
      /\ Shared.medium = {}
      /\ Shared.chipTimer = 0
      /\ LET i == taskId(t)
         IN /\ Shared.chipCount = i
            /\ LET resSet == reservation(i) 
               IN /\ Shared' = [ Shared EXCEPT 
                         !.macTimer = delta,
                         !.medium = { [ id |-> i, type |-> "hard", res |-> resSet ] }]
                  /\ TaskState' = [ TaskState EXCEPT
                         ![i].res = [ j \in Task |-> IF j \in resSet THEN i ELSE @[j] ],
                         ![i].cons = 1 ] 
            /\ History' = [ History EXCEPT !.elem = @ + 1 ]
            /\ UNCHANGED ProcState
\end{tla}
\begin{tlatex}
\@x{ SendElem ( t ) \.{\defeq}}%
\@x{\@s{24.59} \.{\land} Shared . medium \.{=} \{ \}}%
\@x{\@s{24.59} \.{\land} Shared . chipTimer \.{=} 0}%
\@x{\@s{24.59} \.{\land} \.{\LET} i \.{\defeq} taskId ( t )}%
\@x{\@s{37.93} \.{\IN} \.{\land} Shared . chipCount \.{=} i}%
\@x{\@s{60.30} \.{\land} \.{\LET} resSet \.{\defeq} reservation ( i )}%
\@x{\@s{73.63} \.{\IN} \.{\land} Shared \.{'} \.{=} [ Shared {\EXCEPT}}%
\@x{\@s{125.73} ! . macTimer \.{=} delta ,\,}%
 \@x{\@s{125.73} ! . medium \.{=} \{ [ id \.{\mapsto} i ,\, type
 \.{\mapsto}\@w{hard} ,\, res \.{\mapsto} resSet ] \} ]}%
\@x{\@s{96.00} \.{\land} TaskState \.{'} \.{=} [ TaskState {\EXCEPT}}%
 \@x{\@s{125.73} ! [ i ] . res \.{=} [ j \.{\in} Task \.{\mapsto} {\IF} j
 \.{\in} resSet \.{\THEN} i \.{\ELSE} @ [ j ] ] ,\,}%
\@x{\@s{125.73} ! [ i ] . cons \.{=} 1 ]}%
 \@x{\@s{60.30} \.{\land} History \.{'} \.{=} [ History {\EXCEPT} ! . elem
 \.{=} @ \.{+} 1 ]}%
\@x{\@s{60.30} \.{\land} {\UNCHANGED} ProcState}%
\end{tlatex}
\tlacaption{A ação $SendElem$ \label{fig:SendElem}}
\end{tlafig}

O mecanismo de rotação do bastão circulante utiliza o contador \txtla{chipCount},
definido módulo \txtla{nTask}, que identifica o \ing{chip} ocorrendo. Assim que será
visto na seção \ref{sec:AcaoTick}, este contador é periodicamente incrementada pela
ação \txtla{NextChip}, quando o temporizador \txtla{chipTimer} expira, no fim de
cada \ing{chip}. O temporizador \txtla{macTimer} especifica o tempo de transmissão
de uma mensagem.  Ele é igual a ``$0$'' quando o meio físico está vazio
(\ing{idle}). Senão, seu valor indica o tempo faltando para completar a transmissão
acontecendo.  Finalmente, o campo \txtla{medium} da variável \txtla{Shared} 
representa o estado do meio. Quando uma mensagem $msg$ é enviada, ela é
armazenada na variável \txtla{medium}. Quando uma transmissão termina,
o meio volta a estar vazio, o que é representado pela fórmula \txtla{\;medium = \{ \}}.

Na ação \txtla{SendElem}, os dois primeiros guardas estabelecem que uma tarefa $t$
pode enviar uma mensagem elementar se: (i) o meio está vazio \txtla{\; Shared
  .medium \.{=} \{ \}}; e (ii) o \ing{chip} está começando \txtla{\; Shared
  .chipTimer \.{=} 0 }. Em seguida, a primeira construção ``\txtla{\.{\LET}
  \ldots\; \textsc{in}}'' define o índice $i$ da tarefa $t$ (tal que \txtla{ t \.{=} T
  [ i ] }) para qual a ação é verdadeira e o guarda \txtla{Shared .chipCount \.{=} i
} garante que esta tarefa esteja em posse do bastão circulante. Desta forma,
assegura-se que uma tarefa só possa mandar uma única mensagem elementar por ciclo de
\doris.

Como pode ser observado na figura \ref{fig:SendElem}, a ação \txtla{SendElem} altera
os valores dos campos \txtla{macTimer} e \txtla{medium} da variável \txtla{Shared} e
\txtla{elem} da variável \txtla{History}.  Estas alterações globais têm o
significado seguinte.

\begin{enumerate}
\item O valor $\delta$ é assinado ao temporizador \txtla{macTimer} para representar
  o tempo durante o qual o meio será ocupado pela transmissão da mensagem elementar
  enviada.
\item A mensagem elementar enviada, cujo identificador é $i$, o tipo é ``hard'' e
  que carrega a lista de reservas \txtla{resSet}, é armazenada no campo
  \txtla{medium}. 
\item O contador $elem$ é incrementado para indicar que uma mensagem elementar
  foi enviada.
\end{enumerate}

Nota-se que a lista de reserva \txtla{resSet} é definida, na cláusula do segundo
\textsc{let}, pela função \txtla{reservation ( i )}. Esta função é apresentada, logo
a seguir,s na figura \ref{fig:reservation}.

Finalmente, para todas as tarefas, os campos \txtla{res} e \txtla{cons} da variável
\txtla{TaskState[i]} são atualizados.

\begin{enumerate}
\item A lista de reservas da tarefa $T[i]$ é atualizada, de acordo com a lista
  de reservas \txtla{resSet} enviadas.
\item O contador \txtla{cons} é redefinido ao valor 1. 
\end{enumerate}

Este contador \txtla{cons} é utilizado para criar um mecanismo de tolerância à
falhas de omissão. Ele contabiliza o número de mensagens críticas recebidas por uma
tarefa $t$ entre duas emissões consecutivas de mensagens elementares por esta
tarefa.  Cada vez que uma mensagem elementar é recebida, \txtla{cons} é
incrementado. Portanto, quando uma tarefa está em posse do bastão circulante num
\ing{slot} \ES, ela pode detectar se uma falha de omissão ocorreu desde seu último
\ES: se \txtla{cons} for menor que \txtla{nTask}, $t$ deixou de receber pelo menos
uma das mensagens elementares eventualmente enviadas nos \txtla{nTask} prévios
\ing{chip}. Neste caso, diz-se que $t$ está inconsistente. Senão \txtla{\;cons \.{=}
  nTask} indica que não houve falhas de omissão e $t$ está consistente.

\begin{tlafig}
\begin{tla}
reservation(i) ==
      IF TaskState[i].cons = nTask
      THEN { j \in Task: TaskState[i].res[j] = -1 }
      ELSE { ( ( (i - 1) + (nTask - 1) ) % nTask ) + 1 }
\end{tla}
\begin{tlatex}
\@x{ reservation ( i ) \.{\defeq}}%
\@x{\@s{24.59} {\IF} TaskState [ i ] . cons \.{=} nTask}%
 \@x{\@s{24.59} \.{\THEN} \{ j \.{\in} Task \.{:} TaskState [ i ] . res [ j ]
 \.{=} \.{-} 1 \}}%
 \@x{\@s{24.59} \.{\ELSE} \{ ( ( ( i \.{-} 1 ) \.{+} ( nTask \.{-} 1 ) )
 \.{\%} nTask ) \.{+} 1 \}}%
\end{tlatex}
\tlacaption{A função $reservation$ \label{fig:reservation}}
\end{tlafig}

A função de reserva \txtla{reservation ( i )}, utilizada para definir
\txtla{resSet}, na ação da figura \ref{fig:SendElem}, é apresentada na figura
\ref{fig:reservation}. Esta função define a lista de reservas realizadas pela tarefa $T[i]$
para os \txtla{nTask} próximos \ing{chips}.  Sua definição depende da
necessidade de cada tarefa em largura de banda extra.  A função utilizada aqui
assume que todas as tarefas em estado consistente querem reservar todos os
\ing{slots} ainda não reservadas. Observa-se que a definição desta lista é diferente
se uma tarefa estiver em estado inconsistente. Nesta caso, é importante ressaltar que
a tarefa $T[i]$ ainda pode reservar o \ing{slot} \RS{} do \ing{chip} $i$ do próximo ciclo,
pois nenhuma outra tarefa pôde ainda ter reservado este \ing{slot}.

A tupla \txtla{TaskState[i].res} armazena a visão das reservas da tarefa
\txtla{T[i]} para os \txtla{nTask} próximos \ing{chips}. Na ação da figura
\ref{fig:SendElem}, a visão de \txtla{T[i]} é atualizada de acordo com as reservas
figurando na lista $resSet$ enviada por $T[i]$.  Se a lista $resSet$ contiver o
elemento $j$, então \txtla{TaskState[i].res[j]} recebe o valor $i$, indicando que
\RS{} do próximo \ing{chip} no qual \txtla{chipCount} valerá $j$ é reservado por
\txtla{T[i]}. Senão, \txtla{TaskState[i].res[j]} conserva o seu valor anterior
(\txtla{@ [ j ]}).

\act{SendRese} Esta ação, apresentada na figura \ref{fig:SendRese}, descreve as
regras que regem a emissão de uma mensagem de reserva.

\begin{tlafig} 
\begin{tla}
SendRese(t) ==
      /\ Shared.medium = {}
      /\ Shared.chipTimer = delta
      /\ LET i == taskId(t)
         IN /\ TaskState[i].res[Shared.chipCount] = i
            /\ Shared' = [ Shared EXCEPT 
                   !.macTimer = delta, 
                   !.medium = { [ id |-> i, type |-> "hard", res |-> {-1} ] } ]
            /\ TaskState' = [ j \in Task |-> [ TaskState[j] EXCEPT 
                   !.res[Shared.chipCount] = -1 ] ]
            /\ History' = [ History EXCEPT !.elem = @ + 1 ]
            /\ UNCHANGED ProcState               
\end{tla}
\begin{tlatex}
\@x{ SendRese ( t ) \.{\defeq}}%
\@x{\@s{24.59} \.{\land} Shared . medium \.{=} \{ \}}%
\@x{\@s{24.59} \.{\land} Shared . chipTimer \.{=} delta}%
\@x{\@s{24.59} \.{\land} \.{\LET} i \.{\defeq} taskId ( t )}%
 \@x{\@s{37.93} \.{\IN} \.{\land} TaskState [ i ] . res [ Shared . chipCount ]
 \.{=} i}%
\@x{\@s{60.30} \.{\land} Shared \.{'} \.{=} [ Shared {\EXCEPT}}%
\@x{\@s{90.03} ! . macTimer \.{=} delta ,\,}%
 \@x{\@s{90.03} ! . medium \.{=} \{ [ id \.{\mapsto} i ,\, type
 \.{\mapsto}\@w{hard} ,\, res \.{\mapsto} \{ \.{-} 1 \} ] \} ]}%
 \@x{\@s{60.30} \.{\land} TaskState \.{'} \.{=} [ j \.{\in} Task \.{\mapsto} [
 TaskState [ j ] {\EXCEPT}}%
\@x{\@s{90.03} ! . res [ Shared . chipCount ] \.{=} \.{-} 1 ] ]}%
 \@x{\@s{60.30} \.{\land} History \.{'} \.{=} [ History {\EXCEPT} ! . rese
 \.{=} @ \.{+} 1 ]}%
 \@x{\@s{60.30} \.{\land} {\UNCHANGED} ProcState }%
\end{tlatex}
\tlacaption{A ação $SendRese$ \label{fig:SendRese}}
\end{tlafig} 

Os dois primeiros guardas estabelecem que uma tarefa $t$ pode enviar uma mensagem \linebreak de
reserva se: (i) o meio está vazio \txtla{\; Shared .medium \.{=} \{ \}}; e (ii) o
\ing{slot} de reserva \RS{} \linebreak está começando \txtla{\; Shared .chipTimer \.{=} delta
}. A construção ``\txtla{\.{\LET} \ldots\; \textsc{in}}'' define  o índice $i$ \linebreak da
tarefa $t$ (tal que \txtla{ t \.{=} T [ i ] }) para qual a ação é verdadeira e o
guarda \linebreak\txtla{TaskState [ i ] . res [ Shared . chipCount ] \.{=} i}
garante que a tarefa $T[i]$ tenha uma reserva para o \ing{slot} \RS{} deste
\ing{chip}. Em seguida, os valores dos campos \txtla{macTimer}e \txtla{medium} da
variável \txtla{Shared}, os campos \txtla{res}, \txtla{cons} da variável
\txtla{TaskState[i]} e o campo \txtla{rese} da variável \txtla{History}, são
atualizados:

\begin{enumerate}
\item O valor $\delta$ é assinado ao temporizador \txtla{macTimer} para representar
  o tempo durante o qual o meio será ocupado pela transmissão da mensagem de reserva
  enviada.
\item \txtla{medium} armazena a mensagem de reserva enviada, cujo identificador é
  $i$ e o tipo é ``hard''.  No caso das mensagens de reservas, atribui-se o valor
  arbitrário ``\txtla{\{ - 1 \}}'' para o campo $res$. Desta forma, mensagens de
  reserva podem sempre ser diferenciadas de mensagens elementares. Tal utilização do
  campo $res$ não compromete o mecanismo de reserva, pois mensagens de reserva não
  podem reservar \ing{slots}.
\item A lista de reservas da tarefa $T[i]$ é atualizada, redefinindo o valor de 
  \linebreak\txtla{TaskState [ i ] . res [ Shared . chipCount ] } para $-1$, indicando que 
  a tarefa $i$ consumiu a reserva que ela tinha para o \ing{slot} \RS{} deste \ing{chip}.
\item O contador $elem$ é incrementado para indicar que uma mensagem elementar
  foi enviada.
\end{enumerate}

Um situação possível, porém não descrita pela ação \txtla{SendRese}, ocorre quando
nenhuma tarefa tem reserva para o \ing{slot} \RS{} do \ing{chip}. Este cenário, no
qual nenhuma mensagem é enviada durante \RS, é contemplado na ação \txtla{NextTick}
(ver figura \ref{fig:NextTick}).

\act{RecvHard} Esta ação, apresentada na figura \ref{fig:RecvHard}, descreve as
regras que regem a recepção de uma mensagem crítica.

\begin{tlafig}
\begin{tla}
RecvHard( m ) ==
      /\ m.type = "hard"    
      /\ Shared.macTimer = 0
      /\ Shared' = [ Shared EXCEPT !.medium = {} ]
      /\ LET noRecvSet == IF Shared.chipCount = 2 THEN {m.id, 3} ELSE {m.id}
         IN TaskState' =
                [ i \in noRecvSet |-> TaskState[i] ] @@
                [ i \in Task \ noRecvSet |-> [ TaskState[i] EXCEPT
                           !.msg = Append( @, m),                            
                           !.execTimer = IF Len( TaskState[i].msg ) = 0 THEN pi ELSE @,
                           !.cons = IF m.res # {-1} THEN @ + 1 ELSE @,
                           !.res = IF m.res = {-1}
                                   THEN [ j \in Task |-> IF j = m.id THEN -1 ELSE @[j] ]
                                   ELSE [ j \in Task |-> IF j \in m.res THEN m.id ELSE @[j] ] ] ] 
      /\ UNCHANGED << ProcState, History >>
\end{tla}
\begin{tlatex}
\@x{ RecvHard ( m ) \.{\defeq}}%
\@x{\@s{24.59} \.{\land} m . type \.{=}\@w{hard}}%
\@x{\@s{24.59} \.{\land} Shared . macTimer \.{=} 0}%
 \@x{\@s{24.59} \.{\land} Shared \.{'} \.{=} [ Shared {\EXCEPT} ! . medium
 \.{=} \{ \} ]}%
 \@x{\@s{24.59} \.{\land} \.{\LET} noRecvSet \.{\defeq} {\IF} Shared .
 chipCount \.{=} 2 \.{\THEN} \{ m . id ,\, 3 \} \.{\ELSE} \{ m . id \}}%
\@x{\@s{37.93} \.{\IN} TaskState \.{'} \.{=}}%
 \@x{\@s{76.70} [ i \.{\in} noRecvSet \.{\mapsto} TaskState [ i ] ]
 \.{\,@@\,}}%
 \@x{\@s{76.70} [ i \.{\in} Task \.{\,\backslash\,} noRecvSet \.{\mapsto} [
 TaskState [ i ] {\EXCEPT}}%
\@x{\@s{112.86} ! . msg \.{=} Append ( @ ,\, m ) ,\,}%
 \@x{\@s{112.86} ! . execTimer \.{=} {\IF} Len ( TaskState [ i ] . msg ) \.{=}
 0 \.{\THEN} pi \.{\ELSE} @ ,\,}%
 \@x{\@s{112.86} ! . cons \.{=} {\IF} m . res \.{\neq} \{ \.{-} 1 \} \.{\THEN}
 @ \.{+} 1 \.{\ELSE} @ ,\,}%
\@x{\@s{112.86} ! . res \.{=} {\IF} m . res\@s{0.52} \.{=} \{ \.{-} 1 \}}%
 \@x{\@s{150.74} \.{\THEN} [ j \.{\in} Task \.{\mapsto} {\IF} j \.{=} m . id
 \.{\THEN} \.{-} 1 \.{\ELSE} @ [ j ] ]}%
 \@x{\@s{150.74} \.{\ELSE} [ j \.{\in} Task \.{\mapsto} {\IF} j \.{\in} m .
 res \.{\THEN} m . id \.{\ELSE} @ [ j ] ] ] ]}%
 \@x{\@s{24.59} \.{\land} {\UNCHANGED} {\langle} ProcState ,\, History
 {\rangle}}%
\end{tlatex}
\tlacaption{A ação $RecvHard$ \label{fig:RecvHard}}
\end{tlafig} 

O primeiro guarda desta ação, \txtla{\E\, m \.{\in} Shared . medium}, aparece na
formulação da ação \txtla{Next} (ver figura \ref{fig:Next}), pois a recepção de uma
mensagem, quer seja crítica ou não, requer que exista uma mensagem no meio para ser
recebida. Os dois demais guardas da ação \txtla{RecvHard} garantem que a mensagem
seja crítica \txtla{m . type \.{=}''\textsf{hard}''} e que sua transmissão tenha terminada
\txtla{Shared . macTimer \.{=} 0}.

Em seguida, a construção ``\textsc{except}'' é utilizada para atualizar o estado do
meio (\txtla{Shared \.{'} \.{=} [ Shared {\EXCEPT} ! .  medium \.{=} \{ \}
  ]}). Finalmente, para representar a possibilidade de falhas de omissão,
distingui-se duas possibilidades para a atualização do estado das tarefas.  Num
primeiro tempo, a construção ``\txtla{LET \ldots IN}'' é utilizada para definir o
conjunto $noRecvSet$ das tarefas que não recebem a mensagem $m$. Além da tarefa
emissora ($T[m.id]$), tarefas vítimas de falhas de omissão são incluídas neste
conjunto. No exemplo da figura \ref{fig:RecvHard}, é o caso de $T[3]$ no segundo
\ing{chip} de cada ciclo. Num segundo tempo, o operador TLA+ \txtla{ \.{\,@@\,}} é
utilizado para construir a tupla \txtla{TaskState'} a partir das duas tuplas
mapeadas pelos conjuntos complementares \txtla{noRecvSet} e \txtla{Task
  \.{\,\backslash\,} noRecvSet}. A primeira destas tuplas corresponde as tarefas que
não recebem $m$ e para quais, portanto, \txtla{TaskState} não é alterado. A segunda
corresponde as tarefas que recebem $m$. Para estas, os campos da variável
\txtla{TaskState[i]} são atualizados da seguinte maneira:

\begin{enumerate}
\item A mensagem $m$ é armazenada na lista $msg$ de mensagens para ser processadas;
\item Se esta lista de mensagem $msg$ ainda era vazia, o temporizador \txtla{execTimer}
  é definido para o valor $\pi$, para representar o início do processamento da mensagem
  pela tarefa $i$. Senão ele é mantido constante.
\item Se $m$ é uma mensagem elementar, (\txtla{m . res \.{\neq}) \{ \.{-} 1 \} }, o
  contador \txtla{cons} é incrementado. Este contador é incrementada a cada recepção
  de uma mensagem elementar. A omissão de uma recepção implique, portanto, que
  $cons$ não seja incrementa. Neste caso, a tarefa é dita inconsistente e sua
  capacidade de reserva é limitada, assim como foi visto na descrição da ação
  \ref{fig:SendElem};
\item Se $m$ é uma mensagem de reserva, a reservas do \ing{slot} \RS{} atual pela
  tarefa emissora $T[m.id]$ é cancelada, redefinido o seu valor para $-1$ (se $m$
  chegou, é porque $T[m.id]$ consumiu sua reserva).  Senão, $m$ é uma mensagem
  elementar. Neste caso, cada lista de reserva é atualizada de acordo com as
  reservas carregadas por $m$.
\end{enumerate}

\subsection{O anel não-crítico}
\label{sec:anelNaoCrit}

No anel não-crítico, a circulação do bastão é organizada em função da comunicação
observada. A cada mensagem não-crítica recebida, um processo $P[j]$ incrementa seu
contador \txtla{token}. Quando sua vez chega, isto é, quando \txtla{ProcState[ j
  ].token \.{=} j}, $P[j]$ transmite uma mensagem, quer seja da sua fila de mensagem
em espera, ou uma mensagem de tamanho mínimo para consumir o bastão.

O anel não-crítico é especificado pelas duas ações principais \txtla{SendSoft}
e \txtla{RecvSoft}, cuja descrição é o objeto desta seção.

\act{SendSoft} Esta ação, apresentada na figura \ref{fig:SendSoft}, descreve as
regras que regem a emissão de uma mensagem não-crítica.

\begin{tlafig}
\begin{tla}
SendSoft(p) ==
      /\ Shared.medium = {}
      /\ 2 * delta \leq Shared.chipTimer
      /\ Shared.chipTimer \leq deltaChip
      /\ LET i == procId(p)
         IN /\ i = ProcState[i].token
            /\ IF i \in Failed
               THEN /\ Shared' = [ Shared EXCEPT !.macTimer = Infinity ] 
                    /\ UNCHANGED ProcState
               ELSE LET lenTX == lenMsg(i)
                        d == Shared.chipTimer + lenTX
                    IN \/ /\ d > deltaChip 
                          /\ Shared' = [ Shared EXCEPT !.macTimer = Infinity ]
                          /\ UNCHANGED ProcState
                       \/ /\ d \leq deltaChip
                          /\ Shared' = [ Shared EXCEPT
                                 !.macTimer = lenTX,
                                 !.medium = { [ id |-> i, type |-> "soft" ] } ]
                          /\ ProcState' = [ ProcState EXCEPT
                                 ![i].token = ( @ % nProc) + 1,
                                 ![i].list = IF @ # << >> THEN Tail(@) ELSE @,
                                 ![i].count = @ + 1 ]
            /\ UNCHANGED << TaskState, History >>
\end{tla}
\begin{tlatex}
\@x{ SendSoft ( p ) \.{\defeq}}%
\@x{\@s{24.59} \.{\land} Shared . medium \.{=} \{ \}}%
\@x{\@s{24.59} \.{\land} 2 \.{*} delta \.{\leq} Shared . chipTimer}%
\@x{\@s{24.59} \.{\land} Shared . chipTimer \.{\leq} deltaChip}%
\@x{\@s{24.59} \.{\land} \.{\LET} i \.{\defeq} procId ( p )}%
\@x{\@s{37.93} \.{\IN} \.{\land} i \.{=} ProcState [ i ] . token}%
\@x{\@s{60.30} \.{\land} {\IF} i \.{\in} Failed}%
 \@x{\@s{73.63} \.{\THEN} \.{\land} Shared \.{'} \.{=} [ Shared {\EXCEPT} ! .
 macTimer \.{=} Infinity ]}%
\@x{\@s{107.59} \.{\land} {\UNCHANGED} ProcState}%
\@x{\@s{73.63} \.{\ELSE} \.{\LET} lenTX \.{\defeq} lenMsg ( i )}%
\@x{\@s{129.96} d \.{\defeq} Shared . chipTimer \.{+} lenTX}%
\@x{\@s{107.59} \.{\IN} \.{\lor} \.{\land} d \.{>} deltaChip}%
 \@x{\@s{143.29} \.{\land} Shared \.{'} \.{=} [ Shared {\EXCEPT} ! . macTimer
 \.{=} Infinity ]}%
\@x{\@s{143.29} \.{\land} {\UNCHANGED} ProcState}%
\@x{\@s{129.96} \.{\lor} \.{\land} d \.{\leq} deltaChip}%
\@x{\@s{143.29} \.{\land} Shared \.{'} \.{=} [ Shared {\EXCEPT}}%
\@x{\@s{173.02} ! . macTimer \.{=} lenTX ,\,}%
 \@x{\@s{173.02} ! . medium \.{=} \{ [ id \.{\mapsto} i ,\, type
 \.{\mapsto}\@w{soft} ] \} ]}%
\@x{\@s{143.29} \.{\land} ProcState \.{'} \.{=} [ ProcState {\EXCEPT}}%
\@x{\@s{173.02} ! [ i ] . token \.{=} ( @ \.{\%} nProc ) \.{+} 1 ,\,}%
 \@x{\@s{173.02} ! [ i ] . list \.{=} {\IF} @ \.{\neq} {\langle} {\rangle}
 \.{\THEN} Tail ( @ ) \.{\ELSE} @ ,\,}%
\@x{\@s{173.02} ! [ i ] . count \.{=} @ \.{+} 1 ]}%
 \@x{\@s{60.30} \.{\land} {\UNCHANGED} {\langle} TaskState ,\, History
 {\rangle}}%
\end{tlatex}
\tlacaption{A ação $SendSoft$ \label{fig:SendSoft}}
\end{tlafig}

Os dois primeiros guardas da ação \txtla{SendSoft} descrevem a isolação temporal
entre o anel não-crítico e o anel não crítico pelo TDMA. Ou seja, uma janela \SW{} só
acontece quando \txtla{ 2 \.{*} delta \.{\leq} Shared . chipTimer \.{\leq}
  deltaChip}. O terceiro guarda estabelece que o meio está vazio \txtla{\; Shared
  .medium \.{=} \{ \}}. Em seguida, a primeira construção ``\txtla{\.{\LET} \ldots\;
  \textsc{in}}'' define o índice $i$ do processo $p$ (tal que \txtla{ p \.{=} P [ i ]
}) para qual a ação é verdadeira e o guarda \txtla{Shared .chipCount \.{=} i }
garante que este processo esteja em posse do bastão circulante.

\begin{tlafig}
\begin{tla}
Failed == CASE Shared.chipCount = 2 -> { 3 }
	      []  Shared.chipCount \in {3, 4} -> { 3, 5 }
	      []  Shared.chipCount = 5 -> { 3, 5 }
	      []  Shared.chipCount \in { 1 } \cup 6..nTask -> { }

lenMsg(i) ==
      IF ProcState[i].list # << >> THEN Head(ProcState[i].list).txTime ELSE delta
\end{tla}
\begin{tlatex}
 \@x{ Failed \.{\defeq} {\CASE} Shared . chipCount \.{=} 2 \.{\rightarrow} \{ 3 \}}%
 \@x{\@s{70.26} {\Box}\@s{4.1} Shared . chipCount \.{\in} \{ 3 ,\, 4 \}
 \.{\rightarrow} \{ 3 ,\, 5 \}}%
 \@x{\@s{70.26} {\Box}\@s{4.1} Shared . chipCount \.{=} 5 \.{\rightarrow} \{ 3 ,\, 5 \}}%
 \@x{\@s{70.26} {\Box}\@s{4.1} Shared . chipCount \.{\in} \{ 1 \} \.{\cup} 6
 \.{\dotdot} nTask \.{\rightarrow} \{ \}}%
\par\vspace{8.0pt}%
\@x{ lenMsg ( i ) \.{\defeq}}%
 \@x{\@s{36.76} {\IF} ProcState [ i ] . list \.{\neq} {\langle} {\rangle}
 \.{\THEN} Head ( ProcState [ i ] . list ) . txTime \.{\ELSE} delta}%
\end{tlatex}
\tlacaption{O conjunto $Failed$ e a função $lenMsg ( i )$ \label{fig:lenMsgFail}}
\end{tlafig}

Distingui-se então dois casos. No primeiro caso, o índice $i$ é elemento do conjunto
$Failed$ e o processo $P[i]$ está falho. Caso contrário, o processo não está
falho. O conjunto $Failed$ é definido arbitrariamente de acordo com o cenário de
verificação de falhas desejado.  No exemplo da figura \ref{fig:lenMsgFail}, uma
falha acontece no processo 3 nos \ing{chips} 2, 3, 4 e 5, e no processo 5 nos
\ing{chips} 3 e 5. Tais falhas são simplesmente representada, na ação
\txtla{SendSoft}, pela desativação do temporizador \txtla{macTimer}, lhe atribuindo
o valor infinito.

Caso o processo não esteja falha, a construção \txtla{\.{\LET} \ldots\; \textsc{in}}
é utilizada novamente para definir duas constantes locais. O tamanho $lenTX$ da
mensagem a ser enviada e $d$, o tempo no qual a transmissão terminará, se ela for
iniciada imediatamente. Se a lista \txtla{ProcState [ i ] . list} for vazia, a
função \txtla{lenMsg( i )}, apresentada na figura \ref{fig:lenMsgFail}, define o
tamanho mínimo $delta$ para a mensagem a ser enviada. Senão, o tamanho da primeira
mensagem na lista é utilizado (\txtla{Head ( ProcState [ i ] . list ) . txTime}).

Finalmente, uma disjunção de dois casos completa esta ação. Se a condição
\txtla{ d \.{>} deltaChip} for verdadeira, não há tempo suficiente na atual janela
\SW{} para que $P[i]$ envia sua mensagem. Neste caso, o temporizador \txtla{macTimer}
é desativado (\txtla{ macTimer \.{=} Infinity }). Senão, \txtla{ d \.{\leq}
  deltaChip} significa que há tempo suficiente para enviar a mensagem de tamanho
$lenTX$. Os diferentes campos das variáveis \txtla{Shared} e \txtla{TaskState [ i ]}
são então atualizados:
\begin{enumerate}
\item O valor $lenTX$ é assinado ao temporizador \txtla{macTimer} para representar
  o tempo durante o qual o meio será ocupado pela transmissão da mensagem não-crítica
  enviada.
\item \txtla{medium} armazena a mensagem não-crítica enviada, cujo identificador é
  $i$ e o tipo é ``soft''.
\item O contador $token$ é incrementado, pois $P[i]$ consumiu sua vez.
\item A lista de mensagem de $P[i]$, se não estiver vazia, é atualizada, tirando o
  primeiro elemento da lista.
\item O contador $count$, utilizado para contabilizar quantas mensagens são enviadas
  durante uma janela \SW, é incrementado.
\end{enumerate}

\act{RecvSoft} Esta ação, apresentada na figura \ref{fig:RecvSoft}, descreve as
regras que regem a recepção de uma mensagem não-crítica.

\begin{tlafig}
\begin{tla}
RecvSoft( m ) ==
      /\ m.type = "soft"
      /\ Shared.macTimer = 0
      /\ Shared' = [ Shared EXCEPT !.medium = {} ]
      /\ ProcState' = [ j \in {m.id} |-> ProcState[j] ] @@
                      [ j \in Proc \ {m.id} |-> [ ProcState[j] EXCEPT
                                                      !.token = ( @ % nProc) + 1,
                                                      !.count = @ + 1 ] ]
      /\ UNCHANGED << TaskState, History >>
\end{tla}
\begin{tlatex}
\@x{ RecvSoft ( m ) \.{\defeq}}%
\@x{\@s{24.59} \.{\land} m . type \.{=}\@w{soft}}%
\@x{\@s{24.59} \.{\land} Shared . macTimer \.{=} 0}%
 \@x{\@s{24.59} \.{\land} Shared \.{'} \.{=} [ Shared {\EXCEPT} ! . medium
 \.{=} \{ \} ]}%
 \@x{\@s{24.59} \.{\land} ProcState \.{'} \.{=} [ j \.{\in} \{ m . id \}
 \.{\mapsto} ProcState [ j ] ] \.{\,@@\,}}%
 \@x{\@s{106.34} [ j \.{\in} Proc \.{\,\backslash\,} \{ m . id \} \.{\mapsto}
 [ ProcState [ j ] {\EXCEPT}}%
\@x{\@s{239.45} ! . token\@s{0.54} \.{=} ( @ \.{\%} nProc ) \.{+} 1 ,\,}%
\@x{\@s{239.45} ! . count \.{=} @ \.{+} 1 ] ]}%
 \@x{\@s{24.59} \.{\land} {\UNCHANGED} {\langle} TaskState ,\, History
 {\rangle}}%
\end{tlatex}
\tlacaption{A ação $RecvSoft$ \label{fig:RecvSoft}}
\end{tlafig} 

Assim como para a ação \txtla{RecvHard} (ver figura \ref{fig:RecvHard}), o primeiro
guarda desta ação, \linebreak\txtla{\E\, m \.{\in} Shared . medium}, aparece na formulação da
ação \txtla{Next} (ver figura \ref{fig:Next}). Os dois demais guardas da ação
\txtla{RecvHard} garantem que a mensagem seja não-crítica (\txtla{m . type
  \.{=}''\textsf{soft}''}) e que sua transmissão tenha terminada (\txtla{Shared
  . macTimer \.{=} 0}).

Em seguida, o estado do meio é atualizado (\txtla{Shared \.{'} \.{=} [ Shared
  {\EXCEPT} ! .  medium \.{=} \{ \} ]}) e a variável \txtla{ProcState} é atualizado,
distinguindo dois casos. Se a mensagem foi enviada pelo próprio processo (\txtla{ j
  \.{\in} \{ m . id \}}), $ProcState[j]$ não é alterado. Senão, os campos $token$
e $count$ são incrementados, indicando que o bastão deve ir para o próximo 
processo do anal não-crítico e que mais uma mensagem não-crítica foi recebida.

\subsection{A representação temporal}
\label{sec:AcaoTick}

A ação \emph{Tick} organiza o progresso do protocolo e é composta de das duas ações
principais \txtla{NextTick}, que incrementa o tempo por passos discretos, e
\txtla{NextChip}, que organiza a circularidade temporal da especificação.

\act{NextTick} Esta ação, apresentada na figura \ref{fig:NextTick}, organiza o fluxo
linear do tempo durante a janela temporal de um \ing{chip}.

\begin{tlafig}
\begin{tla}
\end{tla}
\begin{tlatex}
\@x{ NextTick \.{\defeq}}%
 \@x{\@s{24.59} \.{\LET} noRese \.{\defeq} \.{\land} Shared . medium \.{=}
 \{ \}}%
\@x{\@s{117.23} \.{\land} Shared . chipTimer \.{=} delta}%
 \@x{\@s{117.23} \.{\land} \A\, i \.{\in} Task \.{:} TaskState [ i ] . res [
 Shared . chipCount ] \.{\neq} i}%
 \@x{\@s{46.96} tmp \.{\defeq} min ( \{ TaskState [ i ] . execTimer \.{:} i
 \.{\in} Task \} \.{\cup}}%
\@x{\@s{114.93} \{ deltaChip \.{-} Shared . chipTimer \} )}%
 \@x{\@s{46.96} d \.{\defeq} {\IF} noRese \.{\THEN} min ( \{ delta ,\, tmp
 \} ) \.{\ELSE} min ( \{ Shared . macTimer ,\, tmp \} )}%
\@x{\@s{24.59} \.{\IN} \.{\land} d \.{>} 0}%
\@x{\@s{46.96} \.{\land} Shared \.{'} \.{=} [ Shared {\EXCEPT}}%
\@x{\@s{76.70} ! . chipTimer \.{=} @ \.{+} d ,\,}%
\@x{\@s{76.70} ! . macTimer \.{=} {\IF} noRese}%
\@x{\@s{153.26} \.{\THEN} @ }%
 \@x{\@s{153.26} \.{\ELSE} {\IF} @ \.{=} Infinity \.{\THEN} Infinity\@s{4.1}
 \.{\ELSE} @ \.{-} d ]}%
 \@x{\@s{46.96} \.{\land} TaskState \.{'} \.{=} [ i \.{\in} Task \.{\mapsto} [
 TaskState [ i ] {\EXCEPT}}%
 \@x{\@s{76.70} ! . msg \.{=} {\IF} TaskState [ i ] . execTimer \.{-} d \.{=}
 0\@s{4.1} \.{\THEN} Tail ( @ ) \.{\ELSE} @ ,\,}%
\@x{\@s{76.70} ! . execTimer \.{=} {\IF} @ \.{-} d \.{=} 0}%
 \@x{\@s{153.26} \.{\THEN} {\IF} Len ( TaskState [ i ] . msg ) \.{>} 1
 \.{\THEN} pi \,\textsc{else}\, Infinity}%
 \@x{\@s{153.26} \.{\ELSE} {\IF} @ \.{=} Infinity \.{\THEN} @ \.{\ELSE} @
 \.{-} d ] ]}%
 \@x{\@s{46.96} \.{\land} {\UNCHANGED} {\langle} ProcState ,\, History
 {\rangle}}%
\end{tlatex}
\tlacaption{A ação $NextTick$ \label{fig:NextTick}}
\end{tlafig} 

Assim como foi visto nas apresentações do anel crítico e não-crítico, as cinco ações
principais de emissão e recepção de mensagens só podem acontecer se o temporizador
\txtla{ macTimer} for nulo. Nas ações de emissão, esta condição é uma conseqüência
do guarda \txtla{Shared . medium \.{=} \{ \}}, pois se o meio tiver vazio, isto
significa que a última mensagem presente no meio foi recebida e que nenhuma nova
mensagem foi enviada ainda. Observa-se que a última ação principal \txtla{NextChip},
apresentada na figura \ref{fig:NextChip}, também tem o guarda \txtla{Shared . medium
  \.{=} \{ \}}.

Conseqüentemente, se o campo $macTimer$ for não nulo, todas as ações de emissão e
recepção são desabilitadas. Neste caso, a ação \txtla{NextTick} deve ser habilitada,
a não ser que uma situação de bloqueio tenha sido atingida. Resumidamente, se nenhum
temporizador é nulo, então o tempo deve progredir.  Para definir o incremento do
tempo $d$, o menor valor dos temporizadores é utilizado, pois este valor anula pelo
menos um temporizador. É importante observar aqui, que, qualquer valor menor de $d$
não anularia nenhum temporizador e que conseqüentemente, o incremento do tempo por
este valor não habilitaria nenhuma nova ação. Portanto, um novo passo
\txtla{NextTick} teria que acontecer, até que algum temporizador chegasse ao valor
``$0$''. Desta constatação surgiu a idéia de buscar o valor do menor dos temporizadores,
cujo é o maior incremento possível num passo só.

Para representar a possibilidade que nenhuma mensagem seja enviada num \ing{slot}
\RS{} de um \ing{chip}, a construção ``\txtla{\.{\LET} \ldots\; \textsc{in}}'' é
utilizada para definir o predicado $noRese$. Os dois primeiros guardas deste
predicado determinem o início de \RS{} e o terceiro garante que nenhuma tarefa tenha
uma reserva para este \ing{slot}. Em seguida, uma constante temporária $tmp$ é
definida para armazenar o menor valor entre os temporizadores \txtla{execTimer} e o
tempo sobrando para terminar o \ing{chip}. Este último valor, \txtla{deltaChip \.{-}
  Shared . chipTimer}, que só pode ser mínimo se o temporizador $macTimer$ for
desativado, representa o tempo durante o qual o meio permanece vazio, antes do
\ing{chip} terminar.  Finalmente, a constante $d$ é definida. Se $noRese$ for
verdadeiro, o conjunto de busca do menor valor contem $tmp$ e $delta$ e não contem
$macTimer$ que é nulo. Senão, o conjunto de busca contem $tmp$ e $macTimer$.

Depois de ter determina o valor do incremento do tempo $d$, o único guarda desta
ação (\txtla{ d \.{>} 0 }) garante que, se algum temporizador for nulo, a ação
associada deve acontecer antes que o tempo seja incrementado. Em seguida, todos os
temporizadores da especificação são atualizados. Dois casos são distinguidos na
atualização de $macTimer$. Se $noRese$ é verdadeiro, $macTimer$ não é alterado e
senão,  $macTimer$ (se não for infinito) é decrementado de $d$.  Em fim, se o valor de $d$
corresponde ao fim de processamento de uma mensagem crítica por uma tarefa $T[i]$,
esta mensagem deve ser retirada da lista \txtla{TaskState[i].msg} e o temporizador
associado deve ser, ou redefinido para o valor $pi$ se tiver mais alguma mensagem
para ser processada, ou desabilitado senão. Se o valor de $d$ não é associado ao fim
do processamento de uma mensagem, $execTimer$ (se não for infinito) é decrementado
de $d$.

\act{NextChip} Esta ação, apresentada na figura \ref{fig:NextChip}, organiza a transição
de um \ing{chip} para o próximo, assim como o fluxo circular do tempo.

\begin{tlafig}
\begin{tla}
NextChip ==
      /\ Shared.medium = {}
      /\ Shared.chipTimer = deltaChip
      /\ Shared' = [ Shared EXCEPT !.macTimer = 0,
                                   !.chipTimer = 0,
                                   !.chipCount = (@  % nTask) + 1 ]
      /\ CASE Shared.chipCount' # 1 ->
            /\ ProcState' = [ j \in Proc |-> [ ProcState[j] EXCEPT 
                    !.token = IF ProcState[j].count = 0 THEN  (@ % nProc ) + 1 ELSE @,
                    !.count = 0 ]]
            /\ UNCHANGED History
         []  Shared.chipCount' = 1 ->
            /\ ProcState' = [ j \in Proc |-> [ ProcState[j] EXCEPT 
                    !.token = IF ProcState[j].count = 0 THEN  (@ % nProc ) + 1 ELSE @,
                    !.count = 0,
                    !.list = list(j) ] ]
            /\ History' = [ elem |-> 0, rese |-> 0 ]
      /\ UNCHANGED TaskState
\end{tla}
\begin{tlatex}
\@x{ NextChip \.{\defeq}}%
\@x{\@s{24.59} \.{\land}\@s{2.21} Shared . medium \.{=} \{ \}}%
\@x{\@s{24.59} \.{\land}\@s{2.21} Shared . chipTimer \.{=} deltaChip}%
 \@x{\@s{24.59} \.{\land}\@s{2.21} Shared \.{'} \.{=} [ Shared {\EXCEPT} ! .
 macTimer \.{=} 0 ,\,}%
\@x{\@s{185.80} ! . chipTimer \.{=} 0 ,\,}%
 \@x{\@s{185.80} ! . chipCount\@s{0.89} \.{=} ( @\@s{4.1} \.{\%} nTask ) \.{+}
 1 ]}%
 \@x{\@s{24.59} \.{\land}\@s{2.21} {\CASE} Shared . chipCount \.{'} \.{\neq}
 1 \.{\rightarrow}}%
 \@x{\@s{60.44} \.{\land} ProcState \.{'} \.{=} [ j \.{\in} Proc
 \.{\mapsto} [ ProcState [ j ] {\EXCEPT}}%
 \@x{\@s{94.27} ! . token\@s{0.54} \.{=} {\IF} ProcState [ j ] . count \.{=} 0
 \.{\THEN}\@s{4.1} ( @ \.{\%} nProc ) \.{+} 1 \.{\ELSE} @ ,\,}%
\@x{\@s{94.27} ! . count \.{=} 0 ] ]}%
\@x{\@s{60.44} \.{\land} {\UNCHANGED} History}%
 \@x{\@s{40.14} {\Box}\@s{4.1} Shared . chipCount \.{'} \.{=} 1
 \.{\rightarrow}}%
 \@x{\@s{60.44} \.{\land} ProcState \.{'} \.{=} [ j \.{\in} Proc \.{\mapsto} [
 ProcState [ j ] {\EXCEPT}}%
 \@x{\@s{94.27} ! . token\@s{0.54} \.{=} {\IF} ProcState [ j ] . count \.{=} 0
 \.{\THEN}\@s{4.1} ( @ \.{\%} nProc ) \.{+} 1 \.{\ELSE} @ ,\,}%
\@x{\@s{94.27} ! . count \.{=} 0 ,\,}%
\@x{\@s{94.27} ! . list \.{=} list ( j ) ] ]}%
 \@x{\@s{60.44} \.{\land} History \.{'} \.{=} [ elem \.{\mapsto} 0 ,\, rese
 \.{\mapsto} 0 ]}%
\@x{\@s{24.59} \.{\land}\@s{2.21} {\UNCHANGED} TaskState}%
\end{tlatex}
\tlacaption{A ação $NextChip$ \label{fig:NextChip}}
\end{tlafig} 

Os dois guardas desta ação garantem que o meio estiver vazio (\txtla{Shared . medium
  \.{=} \{ \}}) e que o \ing{chip} terminou (\txtla{Shared . chipTimer \.{=}
  deltaChip}). Neste caso, um novo \ing{chip} deve começar, o que é representado
pelas atualizações dos campos \txtla{macTimer}, \txtla{chipTimer} e \txtla{chipCount}.

\begin{enumerate}
\item O valor ``$0$'' é assinado ao temporizador \txtla{macTimer} para habilitá-lo
  novamente.
\item O valor ``$0$'' é assinado ao temporizador \txtla{chipTimer}, pois um
  novo \ing{chip} está iniciando.
\item O contador \txtla{chipCount} é incrementado, módulo \txtla{nTask}.
\end{enumerate}

Observar que a ação de redefinição do temporizador \txtla{chipTimer} para ``$0$'',
juntamente com a utilização do módulo no incremento de $chipCount$, é responsável
pela circularidade temporal da especificação.

Em seguida, dois casos são distinguidos para atualizar os campos da variável
\txtla{ProcState}.  Se \txtla{chipCount} for diferente de $1$ no próximo estado, não
há mudança de ciclo e o campo $list$ utilizado para armazenar as listas de mensagens
de cada processo não é modificado. Caso contrário, um novo ciclo começa e o campo
$list$ é redefinido para o valor arbitrário $list(j)$, já utilizado na definição de
$Init$ (ver figura \ref{fig:listFunc}). Neste caso, os dois contadores $elem$
e $rese$ da variável $History$ são também redefinidos para ``$0$''.

Finalmente, em ambos os casos, a atualização dos campos \txtla{token} e
\txtla{count} da variável \txtla{ ProcState [ i ] } reflete a mudança de \ing{chip}:

\begin{enumerate}
\item Se nenhuma mensagem não-crítica foi recebida durante \SW{} deste \ing{chip}
  \linebreak \txtla{ProcState [ i ] . count \.{=} 0}, o processo em posse do bastão
  está falho, e, portanto, o contador \txtla{token} é incrementado.
\item O contador de mensagens não-críticas recebidas durante a última janela \SW{} é
  redefinido para ``$0$''.
\end{enumerate}

\section{Verificação automática} %Model checking}
\label{sec:verifAuto}

Para poder verificar alguns modelos finitos do sistema com o verificador de modelo
TLC~\cite{Yu99}, um arquivo de configuração é utilizado para atribuir um valor à
todas as constantes do conjunto \txtla{\CONSTANTS} da especificação. Assim como foi
visto na seção \ref{sec:consVar}, um conjunto de valores utilizado para verificar
\doris foi, por exemplo: $nTask = 8, nProc = 7, deltaChip = 300, delta = 6, pi =
111, maxTxTime = 122$. Os tempos de execução para tal modelos foram bastante
razoáveis, porém nenhum estudo comparativo foi realizado com outras ferramentas.
Por exemplo, para um modelo com 14 tarefas e 17 processo, e usando os cenários de
falhas e de comunicação não-crítica apresentados na seção \ref{sec:dorisSpec}, TLC
verificou a especificação de \doris e da suas propriedades temporais em menos de 45
segundos num processador Intel Core Duo 2 Ghz usando a máquina virtual java com uma
pilha de 512M.

Após a detecção de erros de sintaxe, TLC busca possíveis situações de bloqueio
(\ing{deadlock}). Em seguida, TLC verifica que a especificação implique as fórmulas 
temporais que estão listados no arquivo de configuração. Sempre que ele detecta a 
violação de uma propriedade, TLC produz um comportamento, que é um
contra-exemplo para esta propriedade, gerando uma seqüência de estados com os
valores de todas as variáveis para cada estado. A análise desta trace é uma
ferramenta valiosa para identificar a causa do erro e corrigir o protocolo (ou a
sua especificação). O que se segue é a descrição de alguns fórmula utilizada para
verificar algumas propriedades relevantes de \doris.

A invariância do tipo das variáveis é a mais simples propriedade a ser verificado numa 
especificação em TLA+. Esta propriedade garante que uma variável permanece no
domínio do seu tipo durante um comportamento que satisfaça a especificação. Especificar a
invariância do tipo de cada variável assegura a detecção de erros óbvios. Aqui está um
exemplo que afirma o tipo de invariância variável $ HardMsg $:

\act{TypeInvariance} Esta propriedade, apresentada na figura
\ref{fig:TypeInvariance}, permite verificar a invariância de tipo das variáveis, ou
seja, que uma variável permanece no domínio do seu tipo durante um comportamento que
satisfaz a especificação. 

\begin{tlafig}
\begin{tla}
HardMsg == Seq( [ id: Task, type: {"hard"}, res: SUBSET( {-1} \cup Task ) ] )

MediumMsg == { m: m \in [ id: Proc, type: {"soft"} ] \cup
                        [ id: Task, type: {"hard"}, res: SUBSET( {-1} \cup Task ) ] }

TypeInvariance ==
      /\ Shared.chipCount \in Task
      /\ Shared.chipTimer \in 0..deltaChip
      /\ Shared.macTimer \in 0..maxTxTime \cup {Infinity}
      /\ \A m \in Shared.medium : m \in MediumMsg
      /\ ProcState \in [ Proc -> [ token : Proc, count : 0..50,
              list : {<< >>} \cup Seq( [ txTime : 0..maxTxTime ] ) ] ]
      /\ TaskState \in [ Task -> [ msg : {<< >>} \cup HardMsg, res : [ Task -> {-1} \cup Task  ], 
                                   execTimer : 0..pi \cup {Infinity}, cons :Task ] ]
\end{tla}
\begin{tlatex}
 \@x{ HardMsg \.{\defeq} Seq ( [ id \.{:} Task ,\, type \.{:} \{\@w{hard} \}
 ,\, res \.{:} {\SUBSET} ( \{ \.{-} 1 \} \.{\cup} Task ) ] )}%
\par\vspace{8.0pt}%
 \@x{ MediumMsg \.{\defeq} \{ m \.{:} m \.{\in} [ id \.{:} Proc ,\,
 type\@s{1.18} \.{:} \{\@w{soft} \} ] \.{\cup}}%
 \@x{\@s{137.77} [ id \.{:} Task ,\, type \.{:} \{\@w{hard} \} ,\, res \.{:}
 {\SUBSET} ( \{ \.{-} 1 \} \.{\cup} Task ) ] \}}%
\par\vspace{8.0pt}%
\@x{ TypeInvariance \.{\defeq}}%
\@x{\@s{24.59} \.{\land} Shared . chipCount\@s{0.89} \.{\in} Task}%
\@x{\@s{24.59} \.{\land} Shared . chipTimer \.{\in} 0 \.{\dotdot} deltaChip}%
 \@x{\@s{24.59} \.{\land} Shared . macTimer \.{\in} 0 \.{\dotdot} maxTxTime
 \.{\cup} \{ Infinity \}}%
 \@x{\@s{24.59} \.{\land} \A\, m \.{\in} Shared . medium \.{:} m \.{\in}
 MediumMsg}%
 \@x{\@s{24.59} \.{\land} ProcState \.{\in} [ Proc \.{\rightarrow} [ token
 \.{:} Proc ,\, count \.{:} 0 \.{\dotdot} 50 ,\,}%
 \@x{\@s{58.43} list \.{:} \{ {\langle} {\rangle} \} \.{\cup} Seq ( [ txTime
 \.{:} 0 \.{\dotdot} maxTxTime ] ) ] ]}%
 \@x{\@s{24.59} \.{\land} TaskState \.{\in} [ Task \.{\rightarrow} [ msg \.{:}
 \{ {\langle} {\rangle} \} \.{\cup} HardMsg ,\, res \.{:} [ Task
 \.{\rightarrow} \{ \.{-} 1 \} \.{\cup} Task\@s{4.1} ] ,\,}%
 \@x{\@s{154.30} execTimer \.{:} 0 \.{\dotdot} pi \.{\cup} \{ Infinity \} ,\,
 cons \.{:} Task ] ]}%
\end{tlatex}
\tlacaption{A propriedade $TypeInvariant$ \label{fig:TypeInvariance}}
\end{tlafig} 

Para construir os domínios de tipo das variáveis, a definição deste invariante
utiliza duas construções, ainda não vistas de TLA+. A primeira é o uso do símbolo
``$\,:\,$'' para definir conjuntos. Por exemplo, \txtla{[ id \.{:} Task ]} é o
conjunto de tuplas da forma $[ id \.{\mapsto} i ]$ com $i \in Task$, ou seja, \txtla{[ id
  \.{:} Task ] == \{ [ id \.{\mapsto} i ] : i \.{\in} Task \} }, expressão na qual o símbolo ``$\,:\,$''
tem agora o significado ``tal que'' usual em matemática. A segunda é o uso do símbolo
$\rightarrow$ para definir conjuntos de mapeamentos. Por exemplo, \txtla{[ Task
  \rightarrow Task ]} é o conjunto das permutações do conjunto $Task$ para se mesmo.

Uma vez especificado os conjuntos de variação para cada variável, o invariante
$TypeInvariance$ verifica que, em cada estado, cada variável pertence a este
conjunto.  Estas fórmulas, apesar de ser longas e complexas, não representam
propriedades alguma do sistema. Portanto, não serão descritas em mais detalhes
aqui. No entanto, a verificação deste invariante é recomendada, pois permite a
detecção dos erros mais óbvios da especificação.

 \act{CollisionAvoidance} Esta fórmula temporal permite verificar que em nenhum
comportamento, emissões de mensagens podem acontecer simultaneamente. Ou seja, se 
uma ação de emissão é habilitada num estado, então nenhuma outra ação de emissão 
é habilitada no mesmo estado.

\begin{tlafig} 
\begin{tla}
Send(q) == \/ /\ q \in TaskSet 
              /\ ( ENABLED SendElem(q) \/ ENABLED SendRese(q) )
           \/ /\ q \in ProcSet
              /\ ENABLED SendSoft(q)

CollisionAvoidance ==
      \A p, q \in TaskSet \cup ProcSet: [] ( ENABLED ( Send(p) /\ Send(q) ) => ( p = q ) ) 
\end{tla}
\begin{tlatex}
\@x{ Send ( q ) \.{\defeq} \.{\lor} \.{\land} q \.{\in} TaskSet}%
 \@x{\@s{77.23} \.{\land} ( {\ENABLED} SendElem ( q ) \.{\lor} {\ENABLED}
 SendRese ( q ) )}%
\@x{\@s{63.90} \.{\lor} \.{\land} q \.{\in} ProcSet}%
\@x{\@s{77.23} \.{\land} {\ENABLED} SendSoft ( q )}%
\par\vspace{8.0pt}%
\@x{ CollisionAvoidance \.{\defeq}}%
 \@x{\@s{24.59} \A\, p ,\, q \.{\in} TaskSet \.{\cup} ProcSet \.{:} {\Box} (
 {\ENABLED} ( Send ( p ) \.{\land} Send ( q ) ) \.{\implies} ( p \.{=} q ) )}%
\end{tlatex}
\tlacaption{A propriedade $CollisionAvoidance$ \label{fig:CollisionAvoidance}}
\end{tlafig} 

Vale a pena mencionar que, a fim de produzir traces dos comportamento verificados
para cada propriedade, a verificação pelo verificador de modelos TLC sempre deve ser
realizadas duas vezes para cada propriedade. Primeiro, verifica-se a propriedade e,
em seguida, a sua contraposição. Desta forma, pode-se verificar que TLC detecta a
violação da propriedade, ou da sua contra-posição, numa das duas execuções, e apenas
numa. A análise do comportamento produzido como contra-exemplo permite assim
conferir que a propriedade especificada expressa realmente o que era desejado verificar.

Por exemplo, $NoCollisionAvoidance$ é a contraposição do predicado
$CollisionAvoidance$ que ilustra o uso de tal metodologia. Os dois traces produzidos
por TLC, numa execução com apenas uma tarefa e um processo, são comentados no
apêndice \ref{ap:traces}.

\vspace{0.3cm}  \setstretch{1}
\begin{tla}
NoCollisionAvoidance ==
      \E p, q \in TaskSet \cup ProcSet: <> ( ( p # q ) /\ ENABLED ( Send(p) /\ Send(q) ) )
\end{tla}
\begin{tlatex}
\@x{ NoCollisionAvoidance \.{\defeq}}%
 \@x{\@s{24.59} \E\, p ,\, q \.{\in} TaskSet \.{\cup} ProcSet \.{:} {\Diamond}
 ( ( p \.{\neq} q ) \.{\land} {\ENABLED} ( Send ( p ) \.{\land} Send ( q ) )
 )}%
\end{tlatex}
\par \vspace{0.2cm}  \setstretch{1.4}


\act{HardRingCorrectnesss} Nesta fórmula, algumas propriedades do anel crítico são
verificadas.

\begin{tlafig}
\begin{tla}
HardRingCorrectness ==
      /\ \A t \in TaskSet : [] ( Len( TaskState[taskId(t)].msg ) \leq 3 )
                            /\ []<> ENABLED SendElem(t)
      /\ [] ( ENABLED NextChip => History.elem = Shared.chipCount )
\end{tla}
\begin{tlatex}
\@x{ HardRingCorrectness \.{\defeq}}%
 \@x{\@s{24.59} \.{\land} \A\, t \.{\in} TaskSet \.{:} {\Box} ( Len
 ( TaskState [ taskId ( t ) ] . msg ) \.{\leq} 3 )}%
 \@x{\@s{24.59} \.{\land} {\Box} ( {\ENABLED} NextChip \.{\implies} History .
 elem \.{=} Shared . chipCount )}%
\end{tlatex}
\tlacaption{A propriedade $HardRingCorrectness$ \label{fig:HardRingCorrectness}}
\end{tlafig} 

Em primeiro lugar, verificou-se que o tamanho da lista de mensagens para ser
processados permanece abaixo de um limiar (aqui 3), e que portanto, não há
possibilidade de esgotamento da memória tampão da placa de rede.  Em seguida, a
segunda linha verifique que quando $NextChip$ acontece, a ação $ElemSlot$ sempre foi
executado exatamente $nTask$ vezes. Vale a pena observar que, para especificar esta
propriedade, foi necessário definir um observador, chamado $History$, cujo campo
$elemSlot$ é utilizado para contabilizar as mensagens elementares enviadas em cada
ciclo. Este contador, redefinido para ``$0$'' no início de cada ciclo, é
incrementado quando $ElemSlot$ é verdadeira. Assim, no final de cada ciclo,
$History.elemSlot $ deve ser igual a $nTask$ se cada tarefas têm enviado sua
mensagem elementar. Em outras palavras, a ação $ElemSlot$ é regularmente
habilitada. O fato de que esta acção é regularmente realizada é assegurada pelo
guarda $ i = ChipCount$, presente na fórmula da ação (ver figura \ref{fig:SendElem}).

Lembrar que falhas de omissão foram especificadas na ação de recepção de mensagens
críticos (ver figura \ref{fig:HardRec}).  Isto implica que falhas de envio de
mensagens e falhas de paradas também foram modeladas. Por exemplo, uma falha de
omissão na emissão de uma mensagem pode ser visto como um conjunto de falhas de
omissões na recepção, em todos as estações, e uma falha de parada de uma estação
corresponde a uma falha permanente de omissão de emissão. Portanto, não foi necessário
verificar cenários específicos de falhas de emissão, nem de falhas de paradas de
tarefas.


\act{ReservationSafety} Esta propriedade garante que se uma tarefa $j$ tem uma reserva
para um \ing{slot} \RS, todas as outras tarefas, ou estão ciente desta reserva, ou 

This property asserts that when task $j$ has a reservation
for some \RS, all other tasks are aware either of this reservation or that they have
not reserved such a slot.

\begin{tla}
ReservationSafety == [] ( \A chip \in Task:
  \E j \in Task: TaskState[j].res[chip] # -1 /\ ENABLED SendRese(T[j]) => 
  \A i \in Task\{j}: TaskState[i].res[chip] \in { TaskState[j].res[chip], -1 } )
\end{tla}
\begin{tlatex}
\@x{ ReservationSafety \.{\defeq} {\Box} ( \A\, chip \.{\in} Task \.{:}}%
 \@x{\@s{8.2} \E\, j \.{\in} Task \.{:} TaskState [ j ] . res [ chip ]
 \.{\neq} \.{-} 1 \.{\land} {\ENABLED} SendRese ( T [ j ] ) \.{\implies}}%
 \@x{\@s{8.2} \A\, i\@s{0.51} \.{\in} Task \.{\,\backslash\,} \{ j \} \.{:}
 TaskState [ i ] . res [ chip ] \.{\in} \{ TaskState [ j ] . res [ chip ] ,\,
 \.{-} 1 \} )}%
\end{tlatex}


This formula implies that two task cannot own a reservation for the same slot. Along
with the enabling predicate $Reser[i][ChipCount] = i$ of the $ReseSlot$ action, the
specification also implies that task $i$ can only send a reservation message in a
\RS that it has previously reserved.


\act{SoftRingFairness} This property asserts that all processes will eventually
receive the token (first line), and that its list of message will eventually be
exhausted.

\begin{tla}
SoftRingFairness ==  /\ \A i \in Proc : []<> ( i = ProcState[i].token )
                     /\ []<> ( \A i \in Proc \ Failed : Len(ProcState[i].list) = 0 )
\end{tla}
\begin{tlatex}
 \@x{ SoftRingFairness \.{\defeq}\@s{4.1} \.{\land} \A\, i \.{\in} Proc \.{:}
 {\Box} {\Diamond} ( i \.{=} ProcState [ i ] . token )}%
 \@x{\@s{114.41} \.{\land} {\Box} {\Diamond} ( \A\, i \.{\in} Proc
 \.{\,\backslash\,} Failed \.{:} Len ( ProcState [ i ] . list ) \.{=} 0 )}%
\end{tlatex}

Should the list of messages of all processes in a cycle exceed the available
bandwidth capacity for the soft communication, TLC indicates out the violation of
the second line of the formula, as expected.

As can be seen, we were able to verify relevant properties of the \doris
protocol. In summary, model-checking has ensured that: (i) the protocol provides
communication isolation, avoiding collisions; (ii) each task always sends an
elementary message per cycle and no task's buffer overflow occurs; (iii) the
reservation mechanism is safe and correct; (iv) soft communication fairness holds;
and (v) the desired fault tolerance is guaranteed.
% Other verification can be carried out such as the existence of fault scenarios or
% other ,

% We invite the interested reader to refer to \cite{DoRiS07} for the complete set of
% these temporal formulas.

% -------------------------------------------------------------------------
\section{Conclusions}
\label{sec:dorisConc}

A TLA+ specification of \doris{}, an Ethernet based protocol, have been shown in
this paper. \doris{} is designed for modern real-time systems, which require
predictability, fault tolerance and flexibility.  The specification and its
properties were checked for several different scenarios.  For this purpose, the TLA+
language was found to have a powerful expressiveness at a satisfactory level of
abstraction. Moreover, as we have specified and checked complex temporal properties
using TLA+, we believe that it is appropriate for helping one in designing real-time
communication protocols.

From a software engineering perspective, the approach used to define \doris{} has
shown how one can benefit from formal methods.  Indeed, using the TLA+ language and
its tools, we have carried out an interactive design methodology, where
specification and model-checking were performed during the definition of the
protocol functions.  We are currently starting the implementation of
\doris{}. Although still in an early stage, implementing the protocol is being
greatly favored by the specification presented here, indicating the strength of the
adopted methodology.

% The description and a TLA+ specification of \doris{}, an Ethernet based protocol,
% have been presented. The TLA+ language was found to have a powerful expressiveness
% at a satisfactory level of abstraction. From a software engineering perspective,
% this work has shown how one can benefit from formal methods to design
% communication protocols. % We are currently implementing
% Although still in an early stage, the implementation of \doris{} is being greatly
% favored by its TLA+ specification, indicating the strength of the adopted
% methodology.

\begin{comment}
         


\section{Uma ilustração gráfica}

\parspace
A Figura~\ref{fig:dorisScenar}, inspirada da ilustração usada em ~\cite{Pritty95}, é
uma representação da circulação do bastão circulante e das mensagens emitidas pelas
diferentes estações num barramento \doris{}. O eixo $x$ representa o tempo e o eixo
$y$ a localização espacial das estações.  As escalas temporais da Figura estão
distorcidas.  Em particular, a inclinação correspondendo a velocidade de propagação
na rede deveria ser menor de pelo menos um fator 4. As cores mais escuras
correspondem às mensagens de tamanho maior, e portanto a intervalos de tempos
maiores.

Este exemplo apresenta um chip de \doris{} com o seguinte cenário:
\par - $T_1$ emite uma mensagem elementar;
\par - $T_7$ emite uma mensagem crítica sob reserva;
\par - Na janela $\SW$, o bastão circulante começa pelo processo $P_1$ que não tem nada
para transmitir;
\par - $P_2$ tem uma mensagem de 512 bytes para transmitir;
\par - $P_3$ e $P_4$ não tem nada para transmitir, portanto dois intervalos de
tempos $d_r$ passam antes do bastão circulante chegar a $P_5$;
\par - $P_5$ tem uma mensagem de 1024 bytes para transmitir;
\par - $P_6$ não tem nada para transmitir;
\par - $P_7$ tem uma mensagem de 512 bytes para transmitir, mas o tempo restante na
janela $\SW$ não é suficiente, portanto $P_7$ emite uma mensagem STOP antes do fim
do \emph{slot} não-crítico.

\begin{figure}[!ht]
  \index{figuras!dorisScenar}%
  % \setlength{\abovecaptionskip}{14pt}
  \centering
  % \includegraphics[scale=0.8]{xfig/dorisScenar}
  \input{fig/dorisScenar.pstex_t}
  \caption{Um exemplo de chip \label{fig:dorisScenar}}
\end{figure}


\section{Composição dos aneis}

\subsection{Modelo}

Para gerar dinamicamente a composição dos dois anéis $\RTS$ e $\SOS$, é preciso
utilizar mecanismos específicos baseados no modelo de falhas adotado
\cite{Lamport84,Cristian95a}.

Neste trabalho, assume-se que os números máximos de tarefas e processos são
conhecidos antes de inicializar o protocolo \doris{} num segmento.  Denota-se
respectivamente $N^{max}_S$ e $N^{max}_H$ estes números.  Considera-se também que as
tarefas e os processos admissíveis nos aneis tem um identificador absoluto único.
Este identificador, denotado $id$, é geralmente diferente do indice da tarefa ou
processo no conjunto $\RTS$ e $\SOS$.

Em relação ao modelo de falha, assume-se que mensagens podem ser corrompidas ou não
emitidas por uma estação (omissão), mas que a função de sensoriamento do meio pelas
estações não falha, isto é, o sensoriamento é confiável. Isto implica que se uma
mensagem é transmitida no meio físico, todas as estações, inclusive a estação
emissora daquela mensagem, percebem a transmissão desta mensagem, mesmo que elas não
consigam a processar corretamente.

Podemos expressar este modelo através das seguintes propriedades:

\begin{itemize}
\item Uma tarefa ou um processo sempre detecta a sua própria falha
  (``self-awareness''),
\item Uma tarefa sempre detecta corretamente a falha de uma outra tarefa.
\end{itemize}

Esta segunda propriedade decorre da periodicidade das mensagens elementares.  Já que
a falha eventual de uma tarefa causa a ausência da mensagem elementar desta tarefa
no seu devido chip, todas as outras tarefas detectam a ausência de mensagem (estado
do meio ``idle'') e inferem a falha da tarefa correspondente.

No caso dos processos, a ausência de uma mensagem pode ser devida a uma falha ou a
ausência de mensagem para ser transmitido por aquele processo. Portanto, outros
processos não podem deduzir nada da ausência, mesmo continuamente repetida, de
mensagens de um certo processo.

Esta propriedade do protocolo \doris{} carateriza a independência entre os dois
anéis, isto é: uma tarefa de $\RTS$ só conhece a composição do anel $\RTS$, mas não
conhece a composição do anel $\SOS$. Da mesma forma, os processos de $\SOS$ não
conhecem a composição de $\RTS$.


\subsection{Mecanismo}

O mecanismo de admissão de tarefas nos aneis $\RTS$ e $\SOS$ utiliza um \emph{round}
de admissão. A sucessão de seqüências de rotação entre dois \emph{round} de admissão
é chamada de ciclo de communicação.  Num ciclo de comunicação, o conjunto de tarefas
membros de

Durante um \emph{round} de admissão, cada tarefa admissível disponha de um slot,
determinado de maneira única atravês do seu identificador absoluto, para transmitir
sua intençao de pertencer ao próximo grupo de comunicação. Se uma tarefa $T_{id}$
emite uma mensagem durante o seu slot de admissão, a propriedade de sensoriamento
confiável implica que todas as tarefas percebem esta mensagem, inclusive a própria
tarefa $T_{id}$. Portanto, todas as tarefas concordam para incluir $T_{id}$ no
próximo grupo de comunicação constituindo $\RTS$.  Se um slot permanece vazio
durante o \emph{round} de admissão, isto signica que a tarefa correspondente não
pertencerá ao próximo grupo de comunicação.  Este mecanismo aproveita ao máximo da
sincronização temporal das estações, interpretando a omissão de uma mensagem num
determinado slot como a ausência da estação correspondente para o próximo ciclo de
communicação.

Para não alterar as propriedades

O seqüenciamento dos slots de admissões baseia-se no sincronismo da


No entanto, uma tarefa que deixa de emitir duas mensagens elementares em seguida é
removida do anel pelas outras tarefas.  Pela propriedade de sensoriamento confiável,
se uma mensagem não é transmitida no meio, por exemplo porque uma falha de omissão
occoreu, a estação que falhou percebe que o seu slot elementar de emissão ficou
vazio, portanto ela ``percebe'' a suas proprias falhas e pode se remover do anel de
forma consistente com as demais estações.


\section{Observações finais}

Uma observação deve ser colocada a respeito do nosso modelo determinístico. Usando
temporizadores, o protocolo de circulação do bastão circulante virtual poderia permitir
que uma tarefa de $\RTS$ se omitisse quando ela não tiver nada para transmitir e que
o bastão circulante passasse logo para a próxima estação, sem espera nenhuma. No entanto,
esta melhoria em termos de eficiência (\emph{throughput}) da comunicação,
introduziria uma variabilidade no tamanho dos chips, sem melhorar o pior caso para
as tarefas com requisitos temporais críticos. Além disso, a detecção de falhas seria
dificultada. Por esta razão, o protocolo \doris{} não implementa esta opção. Ou
seja, para garantir a periodicidade exata dos \emph{slots} de comunicação, o tamanho
$\DDC = \DHW + \DSW$ dos chips é suposto constante. O determinismo introduzido desta
forma facilita a detecção eficiente das falhas de processos; dado que cada chip de
\doris{} contém uma mensagem elementar, a periodicidade do nosso modelo permite
determinar exatamente quando uma mensagem elementar deve ser observada. Portanto, se
no instante previsto, o meio está livre, isto significa que uma falha de omissão ou
de parada ocorreu.  A conseqüência do determinismo assim introduzido é um
\textit{overhead} máximo de $2 \, \delta$ por chip de \doris{}, isto é
aproximadamente 4,6\% da banda.

O protocolo \doris{} precisa que haja pelo menos uma estação crítica atíva no anel
$\RTS$ para funcionar.

Em relação a tolerância a falhas dos canais de comunicação, a redundância do
barramento físico deverá ser considerada ~\cite{Kopetz05,Avizienis04}.


\end{comment}