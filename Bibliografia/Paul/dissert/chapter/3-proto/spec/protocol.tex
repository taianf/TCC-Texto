\chapter{\doris: Especificação e verificação}
\label{cap:doris}

\section{Introdução}
\label{sec:intro}

Neste capítulo,  um novo protocolo de comunicação de tempo real, baseado em  Ethernet
compartilhado, é apresentado através das sua especificação formal na linguagem TLA+
\cite{Lamport02a}.

O protocolo \doris, cujo significado em inglês é \emph{An Ethernet
  \underline{Do}uble \underline{Ri}ng \underline{S}ervice for Real -Time Systems},
teve como fontes de inspiração principais os protocolos VTPE \cite{Carreiro03} e
TEMPRA \cite{Pritty95}, apresentados no capítulo \ref{cap:motivacao}.  \doriss foi
concebido para dar suporte a sistemas híbridos nos quais dispositivos industriais
como sensores, atuadores e controladores compartilham a mesma rede de comunicação
com aplicações ou serviços não-críticos. Lembrar que a velocidade de processamento e
as características da comunicação das aplicações de tempo real críticas e das
aplicações com requisitos temporais não-críticos são bastante diferentes. De fato, a
maioria dos dispositivos de pratileira disponíveis tem capacidade de processamento
pequena em relação à largura da banda Ethernet.  Por exemplo, vimos na seção
\ref{sec:sisHibrid}, que Carreiro et al \cite{Carreiro03} utilizaram
micro-controladores que podem gastar até $111 \, \mu s$ para processar uma mensagem
de 64B. Já que o tempo de transmissão de tal mensagem numa rede 100Mbps é $\delta =
5,76 \, \mu s$, isso permite somente cerca de $5,2\%$ de utilização do barramento
para a comunicação com requisitos temporais críticos. Por outro lado, aplicações
não-críticas têm geralmente capacidades de processamento maiores e podem, portanto,
utilizar taxas de transmissão mais elevadas.  Considerando estas características dos
sistemas híbridos, este trabalho propõe \doris, um protocolo novo que combina as
abordagens de bastão circulante e \emph{Time Division Multiple Access} (TDMA) para:
\begin{enumerate}
\item prover previsibilidade num segmento Ethernet compartilhado;
\item oferecer garantias temporais às tarefas de tempo real;
\item disponibilizar a largura de banda não aproveitada pela comunicação
crítica para a comunicação não-crítica. 
\end{enumerate}

A concepção e implementação de um novo protocolo tal que \doriss envolve tomadas de
decisão cautelosa. Neste processo, a especificação formal do protocolo e sua
verificação automática permitem adquirir confiança no projeto elaborado. De fato,
especificar formalmente um sistema e verificar a sua correção de maneira automática
aumenta significativamente a compreensão do seus comportamentos e pode ajudar a
detectar erros ou defeitos de concepção numa fase inicial do desenvolvimento do
\ing{software} \cite{Auslander96, Clarke99}. Tal abordagem, apesar de não ser tão
freqüente na comunidade de pesquisa de rede, já foi utilizado em vários domínios de
aplicação \cite{Barboza06, Johnson04, Hanssen06}.

Na últimas três décadas, várias linguagens formais e ferramentas de verificação foram
desenvolvidas baseadas em lógica temporal \cite{Pnueli79,  Larsen97, Henzinger91}. Por 
exemplo, Esterel \cite{Berry92} é uma linguagem síncrona bastante adequada para especificar 
componentes de \ing{hardware} e para expressar propriedades complexas de circuitos ou 
sistemas síncronos mais amplos.
% However, it is mainly devoted to programming control-dominated software or
% hardware reactive systems.
A linguagem de Especificação e Descrição (SDL) e o padrão Estelle foram recentemente
estendidos para permitir a especificação de Sistemas de Tempo Real \cite{Fischer96,
  Sinnott04}. No entanto, SDL e Estelle são dedicados a descrição formal e a geração
automática de código na fase inicial do projeto e ambas não permitem a verificação
automática do modelo. Várias outras ferramentas são baseadas em automata temporais
tal que Kronos \cite{Daws96} and HyTech \cite{Alur96}.  Promela é agora dotada de
uma extensão de tempo real que fornece uma semântica para a especificação e a
verificação de propriedades temporais \cite{Tripakis96}.  Uma outra ferramenta
bastante utilizada para especificar e verificar sistemas de tempo real é UPPALL
\cite{Larsen97}. Por exemplo, num trabalho recente \cite{Hanssen06}, o protocolo
RTnet, de tempo real baseado em Ethernet, foi especificado e suas propriedades
temporais foram verificadas com UPPAAL.

Uma outra alternativa possível para especificar Sistemas de Tempo Real
\cite{Abadi94,Lamport05} é a linguagem de especificação formal TLA+ (\ing{Temporal
  Logic of Actions}) \cite{Lamport02a}, junto com o seu verificador de modelo
associado TLC (\ing{Temporal Logic Checker}) \cite{Yu99}.  Baseada na teoria dos
conjuntos de Zermelo-Fraenkel e na lógica temporal ~\cite{Pnueli79}, a linguagem
TLA+ foi especialmente concebida para expressar propriedades temporais de sistemas
concorrentes e distribuídos ~\cite{Johnson04}.  A escolha de TLA+ para especificar e
verificar \doriss se deu pelas razões principais seguintes. 
\begin{enumerate}
\item TLA+ tem uma estrutura modular permitindo um processo de escrita por incrementos
  sucessivos, de acordo com o grau de abstração ou de detalhe desejado;
\item Uma especificação em TLA+ é bastante parecida com código de programas, e
  portanto, oferece uma base sólida para a implementação de \doris.
\item O verificadores de modelo TLC permite verificar automaticamente a especificação, 
  assim como as propriedades temporais associadas.
\item Tantos os documentos de definição da linguagem TLA+ como a ferramenta TLC e
  vários exemplos são disponíveis livremente na Internet \cite{TLA}.
\end{enumerate}

Após introduzir alguns termos e considerações sobre o sistema considerado, a seção
\ref{sec:dorisProt} apresentará uma visão geral do protocolo \doris. Em seguida, as
hipóteses de modelagem e uma breve introdução a linguagem TLA+ darão o início da
seção \ref{sec:dorisSpec}, que se prosseguirá com a descrição detalhada da
especificação formal de \doriss. Finalmente, a seção \ref{sec:propTemp} será
dedicada a discussão das propriedades temporais verificadas. A seção
\ref{sec:dorisConc} concluíra este capítulo.


\section{\doris: o protocolo}
\label{sec:dorisProt}

O protocolo \doriss atua como um filtro lógico, localizado entre as camadas de rede
e física da pilha Ethernet, que elimina as colisões inerentes à camada de controle
de acesso ao meio do protocolo CSMA/CD \cite{CSMA/CD01}.  \doriss é concebido para
dar suporte à sistemas híbridos, nos quais sensores industriais, atuadores e
controladores compartilham a rede de comunicação com as demais aplicações com
requisitos temporais não-críticos. Dispositivos industriais (micro-controladores,
sensores, etc.) são chamados de ``estações lentas'', pois a velocidade de
processamento de tais dispositivo é relativamente baixas em comparação a dos
micro-computadores, chamados de ``estações rápidos''.

\subsection{Sistema, modelo e terminologia}
\label{sec:dorisModel}

O conjunto de estações (lentas e rápidas) interligadas num barramento Ethernet
compartilhado constituem um segmento \doris. Embora vários segmentos \doriss possam
ser inter-conectados por \ing{switches} ou roteadores, a especificação e verificação
de \doris se restringe a um segmento isolado. Em tal segmento, cada estação executa
um servidor \doris, que é responsável pela execução das funcionalidades de \doris.
Uma estação rápida pode hospedar tanto tarefas críticas como também processos com
requisitos temporais não-críticos. Para fins de sobriedade das notações, as
primeiras serão simplesmente chamados de tarefas e os segundos de processos.  Os
dois conjuntos de tarefas e de processos, denotados respectivamente \txtla{TaskSet}
e \txtla{ProcSet}, definem os dois anéis lógicos de um segmento \doris, nos quais um
único bastão circulante circula.

Mensagens enviadas pelas estações lentas são curtas, usualmente periódicas, e têm
requisitos de tempo real críticos.  Assume-se que tais mensagem, chamadas de
``mensagens críticas'', têm um tamanho constante de 64B e que, conseqüentemente, são
transmitidas no barramento no tempo de transmissão $\delta$. Denota-se $\pi$ o tempo
de processamento, no pior caso, da estação mais lenta do segmento \doris.  Assume-se
que $\delta \ll \pi$ e que a recepção e o processamento das mensagens são duas
operações independentes que podem ser realizada simultaneamente.  A primeira
suposição reflete a existência de estações lentas no segmento, enquanto a segunda
corresponde a realidade dos dispositivos de hardware modernos dotadas de memórias
tampões e de capacidade de DMA (\ing{Direct Memory Access}). A segunda suposição
implica, notadamente, que duas ou mais mensagens críticas podem ser enviadas em
seguida. Observa-se que se tiver somente estações lentas presentes no segmento
\doris, a taxa máxima de utilização do barramento é de $\frac{\delta}{\pi +
  \delta}$.  No entanto, se tiver também estações rápidas, a fração da banda não
utilizada pode ser aproveitada pelos processos. É desta constatação que surgiu a
proposta de \doris.

Assim como os protocolos VTPE e TEMPRA (cf seção \ref{sec:TempraVTPE}), \doris{}
utiliza o modelo de comunicação \ing{publish-subscribe} \cite{Dolejs04}, de acordo
com o qual, quando uma aplicação quer enviar uma mensagem, ela utiliza o endereço
Ethernet de comunicação um-para-todos padrão (\cod{FF:FF:FF:FF:FF:FF}).
% Porém, várias aplicações podem ser hospedadas numa mesma estação. Para identificar
% as mensagens de cada aplicação, usa-se o \ing{type field} do quadro Ethernet
% \ref{fig:ethernetFrame}.
Quando um servidor \doris recebe uma mensagem, ele determina, de acordo com a
identidade do seu emissor, se tiver alguma aplicação interessada naquela
mensagem. Caso positivo, ele entrega a mensagem. Senão, ele a descarta.  A
princípio, as tarefas não precisam completar o processamento de todas as mensagens
críticas. No entanto, para simplificar o modelo, assume-se aqui que todas as
mensagens críticas são inteiramente processadas por todas as tarefas.

Em relação ao modelo temporal, assume-se um sistema distribuído síncrono. Isto significa
que as operações efetuadas pelas estações podem ser sincronizado uma com a outra. 
Esta suposição se baseia no esquema de divisão temporal de \doris, que como será vista, 
tem pontos de sincronização regulares e previsíveis, que ocorre dentro de uma janela
de tempo curta comparada com o desvio dos relógios locais. Isto implica que
os relógios locais das estações são sincronizados.

Por fim, assume-se que as estações podem falhar por \ing{crash}, ou seja, parar
qualquer tipo de atividade \cite{Schlichting83}, e voltar a funcionar normalmente
depois de um tempo arbitrário. Mensagens enviadas podem eventualmente ser perdidas,
porém, estações rápidas devem imperativamente perceber a interrupção associada a
recepção de uma mensagem, mesmo que o conteúdo da mensagem seja perdido. Como será
visto, este requisitos é necessário para controlar a circulação do bastão circulante
entre os processos.  De acordo com as necessidades das aplicações críticas, esta
restrição não se aplica às estações lentas, pois têm capacidades de processamento
menores.


\subsection{O esquema de Controle de Acesso ao Meio}
\label{sec:dorisMAC}

A comunicação num barramento \doriss é temporalmente dividida em uma alternância de
fases (\ing{rounds}) de comunicação (\emph{C-Rd}) e fases (\ing{rounds}) de
configuração dos membros (\emph{M-Rd}), assim como ilustrado na figura
\ref{fig:dorisStruct}. Durante a fase de configuração, o algoritmo de controle da
composição do segmento \doriss é responsável por estabelecer uma visão única da
composição do grupo de participantes do segmento \doris, compartilhada por todos os
membros deste segmento. O problema do estabelecimento de tal visão, conhecido também
como o problema do consenso, é assuntos de vários trabalhos \cite{Cristian88,
  Chandra96, Lamport98}.  No contexto desta dissertação, considera-se que os grupos
de tarefas \cmtla{TaskSet} e processos \cmtla{ProcSet} são definidos em tempo de
projeto e especifica-se somente a fase de comunicação do protocolo
\doriss. Denota-se $nTask$ e $nProc$ os cardinais destes dois conjuntos.

\begin{figure}[tb]
  \centering
  \input{fig/dorisStruct.pstex_t}
  \caption{O esquema de Divisão Temporal de \doris}
  \label{fig:dorisStruct}
\end{figure}

Usando TDMA, cada fase de comunicação (\emph{C-Rd}) é definida como um número
arbitrário, porém fixo, de ciclos periódicos, os quais são subdivididos em
exatamente $nTask$ \ing{chips} (ver figura \ref{fig:dorisStruct}). Um mapeamento dos
naturais sobre o conjunto dos \ing{chips} associa um inteiro positivo módulo $nTask$
a um \ing{chip}. Este contador é denotado $chipCount$. Cada chip é, por sua vez,
dividido em duas janelas, críticas e não-críticas, denotadas \HW e \SW, e
associadas, respectivamente, as comunicações de tempo real críticas e
não-críticas. As tarefas só transmitem mensagens durante as janelas \HW, enquanto
os processos apenas utilizam \SW para transmitir as suas. Os tamanhos destas duas
janelas são respectivamente denotados por \DHW e \DSW e o tamanho de um chip é
definido por $\DDC = \DHW + \DSW$. Para permitir um certa flexibilidade e a
definição de políticas de escalonamento das mensagens, a janela \HW é também
subdividida em dois \ing{slots}: o \ing{slot} elementar (\ES) e o \ing{slot} de
reserva (\RS).  As mensagens transmitidas nos \ing{slots} \ES e \RS são mensagens
críticas, chamadas respectivamente de mensagem elementar e de reserva. Uma vez por
ciclo, cada tarefa envia uma mensagem elementar dentro de \ES enquanto \RS é
utilizada para oferecer um mecanismo de reserva. De forma a tolerar falhas por
\ing{crash} e prover confiabilidade do sistema inteiro, tarefas não falidas são
obrigadas a enviar uma única mensagem elementar por ciclo.

Observa-se que, com o objetivo de facilitar a apresentação e a especificação de
\doris, assume-se que cada tarefa pode enviar uma única mensagem elementar por
ciclo. No entanto, esta suposição poderia ser levada, de acordo com o algoritmo
utilizado na fase de configuração, alocando um número arbitrário de \ing{chip} por
ciclo a cada servidor.  Caberia então a cada servidor alocar seus \ing{chips} às tarefas
sob sua responsabilidade. 

O mecanismo de reserva funciona da seguinte maneira. Cada mensagem elementar enviada
por uma tarefa $i$ carrega uma lista de inteiros (módulo $nTask$) que especifica os
identificadores dos \ing{slots} que $i$ pretende usar para enviar mensagens
adicionais. Esta lista é um subconjunto do conjunto dos $nTask$ \ing{chips} seguindo
o \ing{chip} no qual $i$ envia sua mensagem. A tarefa $i$ só pode reservar um
\ing{slot} que ainda não foi reservado por uma outra tarefa. Para este efeito, cada
servidor mantém uma vetor de reservas, denotada $res$, na qual ele armazena as
reservas especificadas em cada mensagem elementar recebida. A consistência do vetor
$res$ pode eventualmente ser comprometida por falhas de omissão de mensagens
elementares. Efetivamente, quando um servidor não recebe uma mensagem elementar, ele
deixa de atualizar $res$ e alguma tarefa pode tentar reservar algum
\ing{slot} previamente reservado. Para evitar tal cenário que poderia levar a uma
colisão, uma tarefa $T_i$ só pode reservar um \ing{slot}, se o vetor $res$ do
seu servidor estiver em estado consistente, isto é, se o servidor de $T_i$ tiver
recebido as $nTask$ mensagens elementares precedendo o \ing{chip} de emissão de
$T_i$. Desta forma, a alocação dinâmica de \ing{slots} de reserva é tolerante à
falhas de omissão. Este mecanismo de reserva é uma inovação do protocolo \doriss que
permite a implementação de alguma política de escalonamento. Efetivamente, uma
tarefa dispõe de um \ing{slot} elementar por ciclo e pode usar até $nTask$ outros
\ing{slots}. No entanto, a discussão de tal política foge do escopo desta
dissertação.

O controle de acesso ao meio de \doriss é organizada por um bastão circulante 
virtual, que circula nos anéis críticos e não-críticos (ver seção \ref{sec:dorisModel}).
O bastão circulante é dito virtual porque sua transmissão é associada à regras temporais
e lógicas baseadas na observação da comunicação acontecendo. A isolação dos dois 
anéis de \doriss é garantida pelo uso do mecanismo de TDMA. Em relação ao anel
não-crítico, o bastão virtual circula durante a janela \SW a cada vez que uma interrupção é
gerada pela placa de rede. Quando um processo não tem nenhuma mensagem à transmitir,
o servidor envia uma mensagem de tamanho mínimo para passar o bastão circulante ao
próximo processo do anel não-crítico.
 
Observa-se que numa fase inicial de concepção do protocolo \doris, pensou-se em
utilizar a capacidade de sensoriamento do meio para organizar a transmissão do
bastão utilizando o mecanismo TPR do protocolo Tempra \ref{sec:TempraVTPE}. No
entanto, em frente a dificuldade de conseguir placas de rede que permitam o acesso ao
estado do meio (\ing{idle} ou ocupado), esta possibilidade foi descartada. 


\section{A especificação formal de \doris }
\label{sec:dorisSpec}

A metodologia descritiva para apresentar a especificação de \doriss segue uma
abordagem indo de cima para baixo. Antes de entrar na descrição dos detalhes da
especificação, a seção \ref{sec:modelHipot} descreve o conjunto das hipóteses de
modelagem adotadas para especificar o protocolo. Em seguida, a seção
\ref{sec:basicTLA} introduz alguns conceitos básicos de TLA+. As demais seções
apresentam as principais fórmulas que compõe a especificação formal de \doris. No
âmbito de focalizar a descrição da especificação no protocolo \doris e na
verificação das suas propriedades, algumas fórmulas foram omitidas. No entanto, a
especificação completa está sendo anexada no final desta dissertação no apêndice
\ref{app:especificacao}.

\subsection{Hipóteses de modelagem}
\label{sec:modelHipot}

Características importantes do sistema devem ser incluídas na especificação de modo
que se possa verificar propriedades interessantes. No entanto, é preciso ter cuidado
para não especificar muitos detalhes devido ao problema da explosão de estados
durante a verificação automática do modelo. As suposições feitas nesta seção tem por
finalidade contornar este problema sem comprometer a descrição o protocolo e sua
verificação.

Em primeiro lugar, como o nosso principal objetivo aqui é fornecer uma descrição
formal do protocolo \doris, a fim de verificar a sua correção, suponha-se que cada
estação hospeda apenas uma tarefa ou processo. Desta forma, evita-se a necessidade
de especificar os servidores \doris.

Em segundo lugar, representa-se o tempo por uma variável inteira. Embora tal
representação discreta do tempo possa comprometer a precisão do modelo no caso de
sistemas assíncronos em geral \cite{Clarke99}, ela é aceitável para protocolos síncronos
baseados em troca de mensagens \cite{Lamport05}.

Em terceiro lugar, considera-se que, sempre que uma ação especificada for habilitadas,
ela acontece sem demora ou é desabilitada imediatamente. Isto significa
que os temporizadores são especificados sem desvios.

Finalmente, considera-se que todas as estações compartilham um relógio comum global,
pois assume-se um modelo síncrono para evitar a especificação de detalhes de
sincronização. Observa-se que na prática todos as estações podem sincronizar os seus
relógios locais com precisão, pois as mensagens elementares são obrigatórias e
periódicas.  Detalhes de tal procedimento serão abordados na fase de implementação
descrita no capítulo \ref{cap:implementacao}.

É importante notar que as considerações sobre o desvio nulo dos relógios e sobre a
sincronia do sistema permite a definição de temporizadores global na especificação,
o que reduz consideravelmente os problemas de explosão de estados.

\subsection{Conceitos de TLA+}
\label{sec:basicTLA}

A Lógica Temporal de Ações (TLA) e sua linguagem formal associada (TLA +) combina a
Lógica Temporal de TLA \cite{Lamport94a} com a expressividade da lógica dos
predicados e a teoria dos conjuntos de Zermelo-Fraenkel. Dotado do verificador de
modelo TLC \cite{Yu99}, TLA+ permite a especificação e a verificação tanto de
protocolos de \ing{hardware} quanto de sistemas distribuídos. Esta seção apresenta
algumas sintaxes básicas de TLA +. Quando necessário, informações complementares
sobre TLA + serão dada ao longo da descrição da especificação de \doris.  Leitores
interessados numa descrição ampla de TLA + podem se referir a publicação de Lamport
\cite{Lamport02a}.

Numa especificação em TLA+, uma computação de um sistema é representada por um
seqüência de estados, também chamada de comportamento. Para caracterizar os estados
do sistema, uma especificação define o conjunto de variáveis (\textsc{variables})
utilizado para descrever o sistema e o conjunto de constantes (\textsc{constants}),
que são utilizadas para definir os valores eventualmente atribuídos às variáveis.
Um \textbf{estado} do sistema é portanto definido pela atribuição de valores
constantes, às variáveis da especificação.

Um pare de estados consecutivos, suponha $i$ e $f$ em referência a inicial e final,
é chamada de \textbf{passo} e é denotado \txtla{i \.{\rightarrow} f}. O operador
linha ``\txtla{\,'\,}'' é utilizado para distinguir os valores de variáveis num
passo. Considerando um certo passo \txtla{P: i \.{\rightarrow} f} e uma variável
$v$, a ocorrência de $v$ sem linha ($v$) faz referência ao valor de $v$ em $i$,
enquanto a ocorrência de $v$ com linha ($v'$) faz referência ao valor de $v$ em $f$.

Uma \textbf{função de estado} é um expressão na qual aparecem somente variáveis sem
linhas. Tal função associa valores constantes aos estados de um comportamento.  As
funções de estado a valores booleanas são simplesmente chamados de \textbf{predicados} de
estado. 

Uma \textbf{função de transição} é uma expressão na qual aparecem variáveis sem
linhas e com linhas. Portanto, denotando $\mathcal{P}$ o conjunto dos passos de um
sistema, uma função de transição $F$ é um mapeamento de $\mathcal{P}$ sobre
$F(\mathcal{P})$. Por exemplo, seja um passo \txtla{P: i \.{\rightarrow} f} e $v$
uma variável, tal que $v = 0$ no estado $i$ e $v = 1$ no estado $f$, e seja $F$ a
função de transição definida por $F(P) = v' - v$, tem-se $F(P) = 1$.

Finalmente, uma \textbf{ação} é, por definição, uma função de transição a valores
booleana. Portanto, uma ação é um mapeamento de $\mathcal{P}$ sobre $\{ V, F \}$,
onde $V$ e $F$ correspondem aos valores de verdade e falso da lógica dos
predicados. Considerando o exemplo apresentado acima, a ação $\mathcal{A}$, definida
pela expressão \txtla{\mathcal{A} \defeq v' = v + 1}, na qual o símbolo TLA+ significa
 ``igual, por definição'', é verdadeira no passo $P$.
%Observa-se aqui que o significado do símbolo TLA+ ``\txtla{\defeq}'' é: ``igual, por definição''.  
Para um dado passo $P$, a relação de sucessão do estado
$i$ para o estado $f$, usualmente chamada de função de transição de estado no
formalismo das Máquinas de Estado Finitos, é definida pelo conjunto de ações
definidas sobre o passo $P$. Este conjunto também é uma ação, pois uma ação pode ser
composta de várias ações.

As fórmulas temporais de TLA+, como por exemplo, a relação de transição entre
estados, são asserções booleanas sobre comportamentos.  Diz-se que um comportamento
satisfaz uma fórmula $\mathcal{F}$ se $\mathcal{F}$ é uma asserção verdadeira deste
comportamento.  O operador da lógica temporal $\Box$ é utilizado para escrever as
fórmulas temporais. A semântica do operador $\Box$ é definida da seguinte maneira.
Para algum comportamento $\Sigma$, e alguma ação $\mathcal{A}$, a fórmula temporal
$\mathcal{F} = \Box [ \mathcal{A} ]_{vars}$ é verdadeira -- ou simplesmente ``$\, \Sigma$
satisfaz $\mathcal{F} \,$'' -- se e somente se, para qualquer passo  \txtla{P: i \.{\rightarrow} f} de
$\Sigma$ que altera o conjunto $vars$ de todas as variáveis, $A$ é verdadeira em
$P$.

\subsection{Constantes e variáveis}
\label{sec:consVar}

\begin{table}[t!b]
  \begin{center}
    \begin{tabular}{ | c |  p{12cm} | }
      \hline  \hline 
      \textbf{Constantes}
      & \textbf{Descrição}    \rule{0pt}{6.mm}  \\[1.4mm]
      \hline
      \txtla{nTask} \vbar     
      & Número de tarefas participando do segmento \doris. \vspc
      \hline
      \txtla{nProc} \vbar     
      & Número de processos participando do segmento \doris.  \vspc 
      \hline
      \txtla{deltaChip} \vbar     
      & Duração ($\Delta_C$) de um \ing{chip}.  \vspc 
      \hline
      \txtla{delta} \vbar     
      & Tempo de transmissão ($\delta$) de um quadro Ethernet de tamanho mínimo.  \vspc 
      \hline
      \txtla{pi} \vbar     
      & Tempo de processamento ($\pi$) de uma mensagem crítica pelo dispositivo
      mais lento.  \vspc 
      \hline
      \txtla{softMsgSize} \vbar     
      & Tempo de transmissão de um quadro Ethernet de tamanho máximo.  \vspc 
      \hline \hline
    \end{tabular}
    \caption{O conjunto \textsc{constants} da especificação de \doris}
    \label{tab:specCons}
  \end{center}
\end{table}

As constantes da especificação de \doriss são definidas na tabela
\ref{tab:specCons}. Um exemplo de valores utilizadas para verificar \doris é, por
exemplo: $nTask = 5, nProc = 7, deltaChip = 260, delta = 6, pi = 111, softMsgSize =
122$. Os valores de $nTask$ e $nProc$ são escolhidos arbitrariamente. Porém, valores
muito grandes provocam uma explosão do número de estados do sistema.  Os valores de
delta ($\delta$) e $softMsgSize$ correspondem aos tempos de transmissão em $\mu s$ de
mensagens de 72 bytes e 1524 bytes num barramento Ethernet de 100Mbps (ver seção
\ref{sec:sisHibrid}).  $pi$ ($\pi$) é o tempo utilizado por \cite{Carreiro03}. Finalmente,
$\Delta_C$ deve ser maior que $2 \pi$, para garantir que as duas mensagens críticas
enviadas num \ing{chip} sejam processadas antes do início do próximo \ing{chip}.

%\bigskip
\begin{table}[htb!]
  \begin{center}
    \begin{tabular}{ | p{20.5mm} | @{} p{120.5mm} @{} |}
      \hline  \hline 
      \textbf{Variável}
      &
      \begin{tabular}{  p{18mm} | p{94.mm} }
        \textbf{Campo}  & \textbf{Descrição} \rule{0pt}{6.mm}  \\[1.4mm]
      \end{tabular}\\

      \hline
      \parbox{20.5mm}{\txtla{Shared} (global)}
      &
      \begin{tabular}{  p{18mm} | p{94.mm} }
        \raisebox{-2mm}{\txtla{chipTimer}} 
        & \vbar é um temporizador crescente que varia de 0 a $\Delta_C$ 
        \newline (\txtla{deltaChip}).  \vspc \hline

        \txtla{chipCount}
        & \vbar é um contador que identifica os \ing{chips} módulo $nTask$. 
         \vspc \hline 
        
        \raisebox{-5mm}{\txtla{medium}}\vbar
        &  representa o estado do meio.  Na ausência de transmissão, \txtla{medium}  está vazia. 
        Senão, \txtla{medium} contem a mensagem sendo transmitida. \vspc \hline     

        \raisebox{-5mm}{\txtla{macTimer}}\vbar
        & é um temporizador decrescente que representa o tempo durante o qual o meio
        ficará ocupado \cmtla{medium \.{\neq} \{ \}} pela transmissão de uma mensagem. \vspc     
      \end{tabular}\\

      \hline
      \parbox{20.5mm}{\txtla{TaskState} (vetor local)}
      &
      \begin{tabular}{  p{18mm} | p{94.mm} }
        \raisebox{-5mm}{\txtla{msg}}\vbar
        & representa a lista de mensagens críticas armazenadas na memória tampão (DMA)
        após recepção na placa de rede. \vspc  \hline

        \raisebox{-2mm}{\txtla{res}}\vbar
        & é a lista de reservas existentes para os \txtla{nTask} próximos \ing{slots}. \vspc \hline

        \raisebox{-5mm}{\txtla{cons}}\vbar
        & é um contador que contabiliza o número de mensagens elementares recebidas
        desde a última emissão de uma mensagem elementar. \vspc
      \end{tabular}\\

      \hline
      \parbox{20.5mm}{\txtla{ProcState} (vetor local)}
      &
      \begin{tabular}{  p{18mm} | p{94.mm} }
        \raisebox{-2mm}{\txtla{token}}\vbar
        & é o contador associado ao bastão circulante utilizado nas janelas \SW.  \vspc  \hline

        \raisebox{-2mm}{\txtla{list}}\vbar
        & é a lista das mensagem não-críticas esperando para ser enviadas.  \vspc  \hline

        \raisebox{-2mm}{\txtla{count}}\vbar
        & é um contador que contabiliza o número de mensagens não-críticas recebidas
        durante uma janela \SW.  \vspc
      \end{tabular}\\

      \hline
      \parbox{20.5mm}{\txtla{History} (observador global)}
      &
      \begin{tabular}{  p{18mm} | p{94.mm} }
        \raisebox{-2mm}{\txtla{elemSlot}}\vbar
        & é um contador que contabiliza o número de mensagens elementares enviadas
        num ciclo. \vspc \hline
      
        \raisebox{-2mm}{\txtla{reseSlot}}\vbar
        & é um contador que contabiliza o número de mensagens de reservas enviadas
        num ciclo.  \vspc 
      \end{tabular}\\
      \hline \hline
    \end{tabular}
    \caption{O conjunto \textsc{variables} da especificação de \doris}
    \label{tab:specVars}
  \end{center}
\end{table}

%\clearpage

Outras constantes podem ser definidas no decorrer da especificação, utilizando o
símbolo ``\txtla{\defeq}'' (cujo significado é: ``igual, por definição'').  Por
exemplo, definem-se \txtla{ Task \.{\defeq} 1 \.{\dotdot} nTask} e \txtla{ Proc
  \.{\defeq} 1 \.{\dotdot} nProc}, os dois conjuntos de inteiros respectivamente
isomorfos a \txtla{TaskSet} e \txtla{ProcSet}.  Nestas definições, a definição do
símbolo ``\txtla{\,{..}}'' é: para dois inteiros $i$, $j$ tal que $i < j$, \txtla{ i
  \.{\dotdot} j \.{\defeq} \{ i ,\, i \.{+} 1 , \.{\ldots} ,\, j \}}. Outros
exemplos são as definições subseqüente dos conjuntos: \txtla{TaskSet \.{\defeq} \{ T
  [ i ] \.{:} i \.{\in} Task \}} e \txtla{ProcSet \.{\defeq} \{ P [ j ] \.{:} j
  \.{\in} Proc \}}.

Em relação as variáveis da especificação, apresentadas na tabela \ref{tab:specVars},
agrupou-se elas em quatro estruturas chamadas $Shared$, $TaskState$, $ProcState$ e
$History$ de acordo com as suas características. A variável $Shared$ é uma tupla com
quatro campos, utilizada para armazenar a visão distribuída compartilhada por
todos. As duas outras variáveis, $TaskState$ e $ProcState$, são vetores de dimensão
respectivas $nTask$ e $nProc$, que armazenam em tuplas de 3 campos, as informações
locais de cada tarefa e processo.  Finalmente, a variável $History$ é uma tupla com
2 campos, utilizada para especificar propriedades temporais. Esta variável é apenas
um observador e não interfere na especificação do protocolo. O detalhe da definição
dos diferentes campos destas quatro variáveis é apresentado na tabela
\ref{tab:specVars}.

\subsection{A fórmula principal de \doris}

\act{Spec} A fórmula \txtla{Spec}, fórmula principal da especificação de \doris{}, é definida por

\begin{mytla}
\begin{tla}
  Spec == Init /\ [] [ Next \/ Tick ]_vars /\ Liveness
\end{tla}
\begin{tlatex}
 \@x{\@s{100.} Spec \.{\defeq} Init \.{\land} {\Box} [ Next \.{\lor} Tick ]_{
 vars} \.{\land} Liveness}%
\end{tlatex}
\end{mytla}

\txtla{Init} é o conjunto dos estados iniciais, \txtla{{\Box} [ Next \.{\lor} Tick
  ]_{ vars}} é a relação de sucessão, aqui composta da disjunção das duas ações
\txtla{Next} ou \txtla{Tick}, e \txtla{Liveness} é uma condição de evolução do
sistema.  \txtla{Next} e \txtla{Tick} são os conjuntos de ações que podem ser
verdadeira num certo passo de um comportamento. Conseqüentemente, um comportamento
$\Sigma$ satisfaz \txtla{Spec} se e somente se o primeiro estado de $\Sigma$ é um
elemento de \txtla{Init} e se todos os passos de $\Sigma$ satisfazem \txtla{Next} ou
\txtla{Tick} e a condição \txtla{Liveness}.

Observa-se que em conseqüência da estrutura temporal de \doris, vista na seção
\ref{sec:dorisMAC}, a maioria das ações de \doris{} são regidas por condições
exclusivas. Portanto, o operador ``\txtla{\lor}'' é exclusivo em quase todas as suas
ocorrências.

\act{Init} A fórmula \txtla{Init}, apresentada na figura \ref{fig:Init}, descreve o
conjunto dos estados iniciais do sistema, ou seja, \txtla{Init} é a definição dos
conjuntos de valores inicias possíveis para cada variável da especificação. Aqui,
cada conjunto tem um elemento só, pois considera-se um estado inicial único do
sistema.

\begin{tlafig} 
\begin{notla}
Init ==  /\ Shared = [ chipTimer |-> 0, chipCount |-> 1, medium |-> {}, macTimer |-> 0 ]
         /\ TaskState = [ i \in Task |-> 
                 [ msg |-> << >>, res |-> [ j \in Task |-> -1 ], cons |-> nTask - i + 1 ] ] 
         /\ ProcState = [ j \in Proc |-> [ token |-> 1, list |-> list(j), count |-> 0 ] ]
         /\ History = [ elemSlot |-> 0, reseSlot |-> 0 ]
\end{notla}
\begin{tlatex}
 \@x{ Init \.{\defeq}\@s{4.1} \.{\land} Shared \.{=} [ chipTimer \.{\mapsto} 0
 ,\, chipCount \.{\mapsto} 1 ,\, medium \.{\mapsto} \{ \} ,\, macTimer
 \.{\mapsto} 0 ]}%
\@x{\@s{46.33} \.{\land} TaskState \.{=} [ i \.{\in} Task \.{\mapsto}}%
 \@x{\@s{80.16} [ msg \.{\mapsto} {\langle} {\rangle} ,\, res \.{\mapsto} [ j
 \.{\in} Task \.{\mapsto} \.{-} 1 ] ,\, cons \.{\mapsto} nTask \.{-} i \.{+}
 1 ] ]}%
 \@x{\@s{46.33} \.{\land} ProcState \.{=} [ j \.{\in} Proc \.{\mapsto} [
 token\@s{10.29} \.{\mapsto} 1 ,\, list \.{\mapsto} list ( j ) ,\, count
 \.{\mapsto} 0 ] ]}%
 \@x{\@s{46.33} \.{\land} History \.{=} [ elemSlot \.{\mapsto} 0 ,\, reseSlot
 \.{\mapsto} 0 ]}%
\end{tlatex}
\caption{A fórmula $Init$}
\label{fig:Init}
\end{tlafig} 

É importante esclarecer aqui duas particularidades de TLA+. Em primeiro lugar, em
TLA+, a indentação das formulas é utilizada, em combinação com as conjunções e os
operadores lógicos, para limitar o uso de parênteses.  Em segundo lugar, uma expressão
tal que, por exemplo,  \txtla{[ j \.{\in} Task \.{\mapsto} \.{-} 1 ]}, representa o vetor de dimensão
$nTask$ cujo as coordenadas são $-1$. Isto implica, neste caso, que, no estado
inicial: \begin{tlatex} \@xx{ \A\, i ,\, j \.{\in} Task \.{:}\@s{4.1} TaskState [ i
    ] . res [ j ] \.{=} \.{-} 1} \end{tlatex}. Lembrar da seção \ref{sec:dorisMAC}
que $res$ é o vetor que armazena as reservas recebidas por uma tarefa. O valor
arbitrário $-1$ é utilizado aqui, para indicar que não há reserva para o
\ing{slot} correspondente.

Voltando à descrição da fórmula \txtla{Init}, os valores definidos para os quatro
campos da variável global \txtla{Shared} indicam que o \ing{chip}~$1$
\cmtla{chipCount \.{\mapsto} 1} está iniciando \cmtla{chipTimer \.{\mapsto} 0}, que
o meio está vazio \cmtla{medium \.{\mapsto} \{ \}} e que \txtla{macTimer}
é nulo, pois nenhuma mensagem está sendo transmitida.

No caso das variáveis locais, \txtla{TaskState} e \txtla{ProcState},  as fórmulas têm o seguinte
significado:
\begin{itemize}
\item Cada tarefa $i$ do conjunto \txtla{Task} assume que a sua lista de mensagens
  críticas para ser processadas está vazia \cmtla{msg \.{\mapsto} {\langle}
    {\rangle}}, que a sua lista de reservas também está vazia, ou seja, todas os
  campos do vetor \txtla{res} valem $-1$ \cmtla{res \.{\mapsto} [ j \.{\in} Task
    \.{\mapsto} \.{-} 1 ]}, e que ela esta num estado consistente \cmtla{cons
    \.{\mapsto} nTask \.{-} i \.{+} 1 }. Lembrar que uma tarefa está num estado
  consistente se ela recebeu todas as mensagens elementares desde o último \ES no
  qual ela enviou uma mensagem (ver seção \ref{sec:dorisMAC}).
\item Cada processo $j$ do conjunto \txtla{Proc} assume que o processo $1$ está em
  posse do bastão circulante \cmtla{token \.{\mapsto} 1}, utiliza a função de estado
  \txtla{list}, previamente definida, para definir a lista da suas mensagens
  não-críticas, e assume que ele ainda não recebeu nenhuma mensagem não-crítica
  \cmtla{count \.{\mapsto} 0}. Notar que a lista de mensagem \txtla{list(j)} é escolhida
  arbitrariamente de acordo com o cenário de verificação desejado.
\end{itemize}

Finalmente, os dois contadores de mensagens elementares e de reservas da variável de
observação \txtla{History} são inicializados a $0$ \cmtla{elemSlot \.{\mapsto} 0 ,\, reseSlot
 \.{\mapsto} 0}. 

\act{Next} Esta ação, apresentada na figura \ref{fig:Next}, descreve as
funcionalidades do protocolo que acontecem instantaneamente, ou seja, as ações que
não decrementam os temporizadores, pois suas durações são muito curtas,
comparativamente com os tempos de transmissões das mensagens.  Isto é o caso aqui,
das operações de emissão e recepção de mensagens.  Lembrar que, para as tarefas,
receber não significa processar, mas somente colocar na memória tampão da placa de
rede.

\begin{tlafig} 
\begin{notla} 
Next  ==  \/ \E q \in TaskSet \cup ProcSet : SendElem(q) \/ SendRese(q) \/ SendSoft(q)
          \/ \E msg \in Shared.medium : RecvHard(msg) \/ RecvSoft(msg)
\end{notla}
\begin{tlatex}
 \@x{ Next\@s{4.1} \.{\defeq}\@s{4.1} \.{\lor} \E\, q \.{\in} TaskSet \.{\cup}
 ProcSet \.{:} SendSoft ( q ) \.{\lor} SendElem ( q ) \.{\lor} SendRese ( q
 )}%
 \@x{\@s{55.22} \.{\lor} \E\, msg \.{\in} Shared . medium \.{:} RecvHard ( msg
 ) \.{\lor} RecvSoft ( msg )}%
\end{tlatex}
\caption{A ação $Next$}
\label{fig:Next}
\end{tlafig} 

Como pode ser observado, \txtla{Next} é uma disjunção de cinco ações, correspondendo
à emissão e recepção de mensagens. A primeira linha especifica à emissão de uma
mensagem, quer seja por uma tarefa ou um processo.  As três ações \txtla{SendElem},
\txtla{SendRese} e \txtla{SendSoft} correspondem às janelas \HW -- subdividida em
\ES e \RS -- e \SW de \doriss.  A segunda linha especifica a recepção de uma
mensagem presente no meio, de acordo com o seu tipo.  \txtla{RecvHard} corresponde à
recepção de uma mensagem crítica, enquanto \txtla{RecvSoft} corresponde à recepção
de uma mensagem não-crítica.

Assim que será visto nas próximas seções, cada uma destas ações é regida por um conjunto
de predicados, também chamado de condições de realizações ou guarda (\ing{enabling
  condition}). Considera-se agora um estado $e$ alcançável da especificação, isto é,
tal que tenha uma seqüência de passos levando de \txtla{i \.{\in} Init} até
$e$. Suponha ainda que no estado $e$, pelo menos um dos guardas das cinco ações
sejam falsos. Neste caso, existem somente duas possibilidades: ou o sistema ficou
bloqueado (\ing{deadlock}), ou a ação \txtla{Tick} está habilitada.


\act{Tick} Esta ação, definida pela fórmula \txtla{Tick \.{\defeq} NextTick \.{\lor}
  NextChip} representa o fluxo do tempo. Para permitir a verificação de alguns
modelos finitos do sistema, apesar da natureza sem limite do tempo, utilizou-se uma
representação do tempo circular. Isto foi realizado dividindo a ação \txtla{Tick} na
disjunção de duas ações: \txtla{NextTick}, que incrementa o tempo por passos
discretos, e \txtla{NextChip}, que realiza a transição de um \ing{chip} para o
próximo, incrementando o valor do contador $chipCount$. Se fosse só a ação
\txtla{NextTick}, o temporizador \txtla{chipTimer} ia crescer
indefinidamente. Porém, a cada vez que ela acontece, a ação \txtla{NextChip}
redefine o temporizador \txtla{chipTimer} para o valor $0$ de tal forma
que este temporizador varia de $0$ a $\Delta_C$. Além disso, o contador
$chipCount$ é também redefinido para o seu valor inicial $1$, sempre que ele atínge
o valor $nTask$. Desta forma, a representação do tempo permite verificar
comportamentos do sistema durante um ciclo completo de \doris.

\act{Liveness} Esta restrição, definida pela fórmula \txtla{Liveness
  \.{\defeq} {\Box} {\Diamond} Tick}, (na qual \txtla{ {\Diamond} F
  \.{\defeq} {\neg} {\Box} {\neg} F}) garante que um comportamento que satisfaz
$Spec$ tenha estados em todos os \ing{chips} de um ciclo de \doris. De fato, devido
a representação circular do tempo, \txtla{Liveness} é satisfeita apenas por
comportamentos cíclicos, porém sem bloqueio, permitindo a verificação de modelos
finitos de \doris.

\begin{comment}
  \iniTLA
  \begin{notla}
    Liveness == []<> Tick
  \end{notla}
  \begin{tlatex}
    \@x{ Liveness \.{\defeq} {\Box} {\Diamond} Tick}%
  \end{tlatex}
  \finTLA
\end{comment}

\subsection{Guia de leitura}
\label{sec:guiaLeitura}

Nesta seção, agrupou-se elementos de descrição gerais da especificação, assim como
algumas definição dos operadores de TLA+ mais usados. 

\act{Ações principais}Assim que foi visto na seção anterior, a especificação de
\doris é constituída por 7 ações principais, as cinco que compõe a fórmula
\txtla{Next}, mais as duas que compõe a fórmula \txtla{Tick}.  O conjunto de fórmula
de cada uma destas ações principais é dividido em dois conjuntos lógicos
diferentes. O primeiro conjunto é constituído pelos guardas -- predicados de estados
que só envolvem constantes e variáveis sem linhas.  Ele representa as condições de
realização da ação.  Em seguida, o segundo conjunto é constituído pelas ações -- nas
quais aparecem constantes, variáveis sem linhas e com linhas -- que especificam as
operações de \doris.


\act{Tarefas e Processos}Para representar os conjuntos \txtla{TaskSet} e
\txtla{ProcSet}, definiu-se os vetores $T$ e $P$ das tarefas e dos processos:

\begin{mytla}
\begin{tla}
T == [ i \in Task |-> << "T", i >> ]   /\  P == [ j \in Proc |-> << "P", j >> ]
\end{tla}
\begin{tlatex}
 \@x{ T \.{\defeq} [ i \.{\in} Task \.{\mapsto} {\langle}\@w{T} ,\, i
 {\rangle} ]\@s{8.2} \.{\land}\@s{4.1} P \.{\defeq} [ j \.{\in} Proc
 \.{\mapsto} {\langle}\@w{P} ,\, j {\rangle} ]}%
\end{tlatex}
\end{mytla}

Utilizando estes dois vetores, as expressões para  \txtla{TaskSet} e
\txtla{ProcSet} são simplesmente:

\begin{mytla}
\begin{tla}
TaskSet == { T[i]: i \in Task }  /\  ProcSet == { P[j]: j \in Proc }
\end{tla}
\begin{tlatex}
 \@x{ TaskSet \.{\defeq} \{ T [ i ] \.{:} i \.{\in} Task \}\@s{4.1}
 \.{\land}\@s{4.1} ProcSet \.{\defeq} \{ P [ j ] \.{:} j \.{\in} Proc \}}%
\end{tlatex}
\end{mytla}

Dado um elemento \txtla{t \.{\in} TaskSet} ou \txtla{p \.{\in} ProcSet}, o seu
índice é encontrada pelas funções \txtla{taskId } e \txtla{procId} assim definidas:

\begin{mytla}
\begin{notla}
taskId(t) == CHOOSE i \in Task : t = T[i]
procId(p) == CHOOSE j \in Proc : p = P[j]
\end{notla}
\begin{tlatex}
\@x{ taskId ( t ) \.{\defeq} {\CHOOSE} i \.{\in} Task \.{:} t \.{=} T [ i ]}%
\@x{ procId ( p ) \.{\defeq} {\CHOOSE} j \.{\in} Proc \.{:} p \.{=} P [ j ]}%
\end{tlatex}
\end{mytla}

Observa-se que, numa expressão da forma, \txtla{\CHOOSE x \.{\in} C : F ( x )}, o operador
\txtla{\CHOOSE} escolha um elemento $x$ do conjunto $C$ tal que a proposição $F(x)$
seja verdadeira. No exemplo acima, esta escolha é única, pois existe um único índice
verificando a proposição especificada.

\act{\txtla{\LET} $\ldots\;$ \textsc{in}} A construção sintática ``\txtla{\.{\LET} \ldots\;
  \textsc{in}}'' é utilizada para definir constantes locais. Nesta construção, o escopo das
definições efetuadas na cláusula do $LET$ é o conjunto de fórmulas constituindo a
cláusula do $IN$.  Por exemplo, na seguinte expressão

\vspace{4mm}
\setstretch{0.}
\begin{tla}
\E t \in TaskSet : LET i == taskId(t)
                   IN F(i)
\end{tla}
\begin{tlatex}
\@x{ \E\, t \.{\in} TaskSet \.{:} \.{\LET} i \.{\defeq} taskId ( t )}%
\@x{\@s{80.17} \.{\IN} F ( i )}%
\end{tlatex}
\par\setstretch{1.4}

\noindent a constante $i$, definida como o índice da tarefa $t$, é conhecida apenas
na proposição $F(i)$.

\act{\txtla{\EXCEPT}, \txtla{\;\.{!}\;} e \txtla{\;\.{@}}} A palavra
\txtla{\EXCEPT}, juntamente com os símbolos \txtla{\;!\;} e \txtla{\;@}, é utilizada para
definir as ações que envolvem tuplas ou variáveis vetoriais. Por exemplo, a ação $A$ definida
por:

\vspace{4mm}
\setstretch{0.}
\begin{tla}
A == History' = [ History EXCEPT !.elemSlot = @ + 1 ]
\end{tla}
\begin{tlatex}
\@x{ A \.{\defeq} History \.{'} \.{=} [ History {\EXCEPT} ! . elemSlot  \.{=} @ \.{+} 1 ]}%
\end{tlatex} 
\par\setstretch{1.4}

\noindent é verdadeira num passo \txtla{i \rightarrow f} se a tupla \txtla{History}
for igual nos dois estados $i$ e $f$, com a exceção do campo \txtla{elemSlot}, cujo
valor no estado $f$ (\txtla{!.elemSlot}) deve ser igual ao seu valor no estado $i$
($@$) incrementado de 1. O símbolo ``$\;!\;$'' é uma abreviação para o sujeito
%nome da variável que figura a esquerda
da palavra \textsc{except}, e o símbolo ``$@$'', por sua vez, representa o valor, no
estado $i$, do campo à ser modificado pela subordinada do %na cláusula
\textsc{except}.  Portanto, uma sintaxe equivalente de $A$, porém menos concisa,
seria:

\vspace{4mm}
\setstretch{0.}
\begin{tla}
A == History' = [ History EXCEPT History.elemSlot' = History.elemSlot + 1 ]
\end{tla}
\begin{tlatex}
\@x{ A \.{\defeq} History \.{'} \.{=} [ History {\EXCEPT} History. elemSlot \.{'}
\.{=} History.elemSlot \.{+} 1 ]}%
\end{tlatex} 
\par\setstretch{1.4}

\act{Indentação} Deve ser ressaltado que, em TLA+, a indentação é
utilizada preferencialmente no lugar de parênteses. Desta forma, os operadores
\txtla{\.{\land}} e \txtla{\.{\lor}} são utilizados para escrever fórmulas lógicas
complexas sob a forma de listas indentadas.

\act{\txtla{\UNCHANGED}} Finalmente, para otimizar o algoritmo de verificação
automática e garantir que a especificação de alguma ação não seja esquecida, uma
especificação em TLA+ deve imperativamente especificar, para cada uma das ações
principais da relação de transição, as regras de evolução de todas as variáveis do
conjunto $vars$. Se uma variável $v$ não for modificado, a ação particular \txtla{ v
  \.{'} = v } é utilizada. Para efeito de concisão, a palavra \txtla{\UNCHANGED E} é
utilizada para definir o conjunto $E$ das variáveis não modificadas por uma
determinada ação. Por exemplo, \txtla{\quad {\UNCHANGED} {\langle} v {\rangle} \.{\defeq}
  v \.{'} \.{=} v}.


\subsection{O anel crítico}
\label{sec:anelCrit}

O anel crítico é especificado pelas três ações principais \txtla{SendElem}, \txtla{SendRese}
e \txtla{RecvHard}, cuja descrição é o objeto desta seção.

% -------------------------------- Action -------------------------------
\act{SendElem} Esta ação, apresentada na figura \ref{fig:SendElem}, descreve as
regras que regem a emissão de uma mensagem elementar.

\begin{tlafig} 
\begin{notla}
SendElem(t) ==
         /\ t \in TaskSet
         /\ LET i == Ind(t)
            IN /\ Shared = [ macTimer |-> 0, medium |-> {}, 
                             chipTimer |-> 0, chipCount |-> i ]
               /\ LET resSet == reservation(i) 
                  IN /\ Shared' = [ Shared EXCEPT 
                            !.macTimer = delta,
                            !.medium = { [ id |-> i, type |-> "hard",
                                           res |-> resSet, procTime |-> pi ] }]
                     /\ TaskState' = [ TaskState EXCEPT
                           ![i].res = [ j \in Task |-> IF j \in resSet THEN i ELSE @[j] ],
                           ![i].cons = 1 ] 
         /\ History' = [ History EXCEPT !.elemSlot = @ + 1 ]
         /\ UNCHANGED ProcState
\end{notla}
\begin{tlatex}
\@x{ SendElem ( t ) \.{\defeq}}%
\@x{\@s{56.01} \.{\land} t \.{\in} TaskSet}%
\@x{\@s{56.01} \.{\land} \.{\LET} i \.{\defeq} Ind ( t )}%
 \@x{\@s{69.34} \.{\IN} \.{\land} Shared \.{=} [ macTimer \.{\mapsto} 0 ,\,
 medium \.{\mapsto} \{ \} ,\,}%
\@x{\@s{159.10} chipTimer \.{\mapsto} 0 ,\, chipCount \.{\mapsto} i ]}%
\@x{\@s{91.71} \.{\land} \.{\LET} resSet \.{\defeq} reservation ( i )}%
\@x{\@s{105.04} \.{\IN} \.{\land} Shared \.{'} \.{=} [ Shared {\EXCEPT}}%
\@x{\@s{157.15} ! . macTimer \.{=} delta ,\,}%
 \@x{\@s{157.15} ! . medium \.{=} \{ [ id \.{\mapsto} i ,\, type
 \.{\mapsto}\@w{hard} ,\,}%
\@x{\@s{229.53} res \.{\mapsto} resSet ,\, procTime \.{\mapsto} pi ] \} ]}%
\@x{\@s{127.41} \.{\land} TaskState \.{'} \.{=} [ TaskState {\EXCEPT}}%
 \@x{\@s{153.05} ! [ i ] . res \.{=} [ j \.{\in} Task \.{\mapsto} {\IF} j
 \.{\in} resSet \.{\THEN} i \.{\ELSE} @ [ j ] ] ,\,}%
\@x{\@s{153.05} ! [ i ] . cons \.{=} 1 ]}%
 \@x{\@s{56.01} \.{\land} History \.{'} \.{=} [ History {\EXCEPT} ! . elemSlot
 \.{=} @ \.{+} 1 ]}%
\@x{\@s{56.01} \.{\land} {\UNCHANGED} ProcState}%
\end{tlatex}
\caption{A ação $SendElem$}
\label{fig:SendElem}
\end{tlafig} 

O primeiro guarda desta ação garante que só tarefas podem enviar mensagens
elementares. Em seguida, a construção sintática \txtla{\.{\LET} \ldots\;  \textsc{in}} define
o índice $i$ da tarefa para qual a ação é verdadeira. 
O mecanismo de rotação do bastão circulante utiliza o contador \txtla{chipCount},
definido módulo \txtla{nTask}, que identifica o \ing{chip} ocorrendo. Este contador
é periodicamente incrementada pela ação \txtla{NextChip}, quando o temporizador
\txtla{chipTimer} expira, no fim de cada \ing{chip}, assim que será visto na seção
\ref{sec:AcaoTick}. \txtla{macTimer} é um temporizador decrescente que representa o tempo
de transmissão de uma mensagem.  Ele é igual a $0$ quando o meio físico está vazio
(\ing{idle}). Senão, seu valor indica o tempo restante para completar uma transmissão
acontecendo. Estas variáveis são utilizadas para definir os três guardas

 
 $BusyMAC$ is a count-down timer which represents the message
transmission time. It equals $0$ when the MAC state is idle.  Otherwise, it equals
the remaining time to complete an on-going message transmission. These variables are
used to define the three enabling predicates (first line of the formula) which state
that task $i$ is allowed to send a message: (i) when the previous transmission has
finished ($BusyMAC = 0$); (ii) the chip is starting ($ChipTimer = 0$) and; (iii)
task $i$ has the token ($i = ChipCount$).  These conditions ensure that task $i$
only sends one elementary message per \doris{} cycle.

Note that in TLA+, indentation is significant in order to eliminate parenthesis.
Hence, the operators $\land$ and $\lor$ are used to construct meaningful
indented-list.  The $LET \ldots IN$ is another useful syntax construction used to
define local variables.  The $\textsc{unchanged}$ operator lists all the variables
(some will appear in the upcoming sections) whose values are not updated by the
action. Due to space limitations, we may represent this list by ``$\ldots$''.

As can be seen, the action $ElemSlot$ changes the values of $Reserv$, $Consistency$
and $BusyMAC$ (primed variables). The latter assumes the value of $\delta$, the time
it takes to transmit a hard message. %%%
$Consistency$ is a tuple of counters that keeps track of the elementary messages
received per task.  Whenever an elementary message is received by task $i$,
$Consistency[i]$ is incremented by $1$ and when task $i$ sends its elementary
message, $Consistency[i]$ is reset to $1$. Thus, if $Consistency[i] = nTask$, no
omission %%%
failure has occurred since the time $i$ sent its previous elementary message.  Note
that the TLA+ expression $[ Consistency \; \textsc{except} \; ![i] = 1 ]$ means that
the record $Consistency$ remains unchanged except for the entry $i$ which is set to
$1$.



A política de reserva das tarefas é definida pela fun
\txtla{SendElem} utiliza uma outra ação, \txtla{reservation}

 is composed of another action, $sendHardMsg$, and the
state function $reservation$. The former describes the sending of a message and the
latter deals with the definition of reservation lists.

% Here, , the reservation list of task $i$, is defined by the state function
% $reservation$.
The \emph{reservation} function is used to generate $resSet$, the reservation list
of task $i$, which indicates the slots task $i$ will be interested in transmitting
additional messages.  Its definition depends on the needs of tasks for
extra-bandwidth. For simplicity, we assumed here that all tasks try to reserve the
maximum number of reservation slots. Referring back to section %\ref{sec:MAC},
a task
can do so if it is in a consistent state (has received all previous $nTask$
elementary messages) and the slots are still not reserved. If task $i$ is
inconsistent, it is still allowed to carry out the reservation of \RS of chip $i$ in
the next cycle as no other task could have reserved such a slot before.  The
reservation function is not shown here since it is related to the application layer.

\begin{mytla}
\begin{notla}
reservation(i) == IF TaskState[i].cons = nTask
                  THEN { j \in Task: TaskState[i].res[j] = -1 }
                  ELSE { ( ( (i - 1) + (nTask - 1) ) % nTask ) + 1 }
\end{notla}
\begin{tlatex}
\@x{ reservation ( i ) \.{\defeq} {\IF} TaskState [ i ] . cons \.{=} nTask}%
 \@x{\@s{93.69} \.{\THEN} \{ j \.{\in} Task \.{:} TaskState [ i ] . res [ j ]
 \.{=} \.{-} 1 \}}%
 \@x{\@s{93.69} \.{\ELSE} \{ ( ( ( i \.{-} 1 ) \.{+} ( nTask \.{-} 1 ) )
 \.{\%} nTask ) \.{+} 1 \}}%
\end{tlatex}
\end{mytla}

  The tuple $Reserv[i]$ stores the reservation vision of task $i$. In action
  $ElemSlot$, $Reserv[i][j]$ is set to $-1$ if no reservation is sent by $i$ for
  slot $j$, otherwise its value is set to $i$.  Here, the definition of $Reserv'$
  makes use of the exception clause to state that $Reserv$ is only updated regarding
  entry $i$, which takes the value of $resSet$ provided by the function
  $reservation$.  In an exception clause, the $@$ symbol stands for the original
  value of the variable, which here is $Reserv[i][j]$. The symbol $\mapsto$ is used
  to assign values to the entries of a record. Here, all entries $j \in Task$ of
  $Reserv'[i]$ are defined.

  % -------------------------------- Action -------------------------------
  The sending of an elementary message by task $i$ during \ES $\,$ is represented by
  the action $sendHardMsg(i, resSet, pi)$, which takes the task identifier as
  arguments, the defined reservation list and the constant value $pi = \pi$ (the
  processing time needed by a task to receive a message).

  \begin{notla}
    sendHardMsg(i, resSet, pi) == HardMsg' = [j \in Task |-> IF j # i THEN Append(
    HardMsg[j], [src |-> i, res |-> resSet, procTime |-> delay] ) ELSE HardMsg[j] ]
  \end{notla}

  \emph{HardMsg} is an $nTask$-tuple representing a buffer where sent hard messages
  are stored. These messages stay in the buffer until they are completely
  received. Hence, $HardMsg[j]$ contains the messages to be received by task $j$.
  When task $i$ sends a hard message, all entries of the $HardMsg$ variable are
  updated except the entry $i$.  $HardMsg$ has some fields: $src$, the message
  sender identifier; \emph{res}, used to implement the reservation mechanism; and
  \emph{procTime}, which is a count-down timer used to represent the time needed by
  the slowest task to process the message.

  % \newpage -------------------------------- Action ------------------------------
  \act{ReseSlot} This action describes the sending of a reservation message.

  \begin{tla}
    ReseSlot(i) == /\ ( SendRese(i) \/ NoRese(i) ) /\ BusyMAC' = delta /\ UNCHANGED
    ...
  \end{tla}

  A task may or may not send a reservation message as specified by the actions
  $SendRese(i)$ and $NoRese(i)$, respectively.  In both cases, $BusyMAC$ is set to
  $\delta$ to represent the reservation slot time.  When some task has a reservation
  for this chip slot, $SendRese$ is true. Otherwise, $NoRese$ holds.

  \begin{tla}
    SendRese(i) == /\ BusyMAC = 0 /\ ChipTimer = delta /\ Reserv[i][ChipCount] = i
    /\ Reserv' = [ j \in Task |-> [ Reserv[j] EXCEPT ![ChipCount] =-1 ] ] /\
    sendHardMsg(i, {-1}, pi)
  \end{tla}
  \begin{tlatex}
    \@x{ SendRese ( i ) \.{\defeq}}%
    \@x{\@s{8.2} \.{\land} BusyMAC \.{=} 0\@s{4.1} \.{\land} ChipTimer \.{=} delta}%
    \@x{\@s{8.2} \.{\land} Reserv [ i ] [ ChipCount ] \.{=} i}%
    \@x{\@s{8.2} \.{\land} Reserv \.{'} \.{=} [ j \.{\in} Task \.{\mapsto}}%
    \@x{\@s{31.61} [ Reserv [ j ] {\EXCEPT} ! [ ChipCount ] \.{=} \.{-} 1 ] ]}%
    \@x{\@s{8.2} \.{\land} sendHardMsg ( i ,\, \{ \.{-} 1 \} ,\, pi )}%
  \end{tlatex}
  \vspace{0.1cm}
  \begin{tla}
    NoRese(i) == /\ BusyMAC = 0 /\ ChipTimer = delta /\ \A j \in Task :
    Reserv[j][ChipCount] # j /\ UNCHANGED << HardMsg, Reserv >>
  \end{tla}
  \begin{tlatex}
    \@x{ NoRese ( i ) \.{\defeq}}%
    \@x{\@s{8.2} \.{\land} BusyMAC \.{=} 0\@s{4.1} \.{\land} ChipTimer \.{=} delta}%
    \@x{\@s{8.2} \.{\land} \A\, j \.{\in} Task \.{:} Reserv [ j ] [ ChipCount ]
      \.{\neq} j}%
    \@x{\@s{8.2} \.{\land} {\UNCHANGED} {\langle} HardMsg ,\, Reserv {\rangle}}%
  \end{tlatex}

  The two first predicates in the first line of both $SendRese$ and $NoRese$ ensure
  that \RS has begun.
  % Also, both predicates are common to the $SendRese$ and $NoRese$ actions, they
  % had to appear explicitly in both formula to allow for the verification of
  % properties of the protocol, as will be seen in section \ref{sec:verif}.  Note
  % that by the specification below the message is sent only when $ChipTimer =
  % delta$ ($=\delta$), i.e. at the beginning of \RS,
  In action $SendRese$, a task $i$ can send a message in a given slot only if it has
  reserved such slot ($Reserv[i][ChipCount] = i$).  Once used, the sender
  reservation list is updated by setting the corresponding entry to -1. Since a
  reservation message cannot be used to make other reservations, such a message
  carries a flag value as reservation list, here defined by $ResMsg$, distinguishing
  itself from an elementary message.  The $NoRese$ action only accounts for the
  consumption of the reservation slot when no task has any reservation. Therefore,
  no message is sent and the variables $HardMsg$ and $Reserv$ remain unchanged.

  % Then, the MAC state is updated accordingly and $TprTimer$ is reset.  This reset
  % operation signals both the end of the current hard window and the beginning of
  % the next \SW by enabling the virtual token rotation in the soft ring. The
  % meaning of $TprTimer$ will be explained in the next section.  Finally, i

  % -------------------------------- Action -------------------------------
  \act{HardRecv} This action describes the reception of a hard message.

  \begin{tla}
    HardRecv(i) == /\ Len(HardMsg[i]) > 0 /\ Head(HardMsg[i]).procTime = 0 /\ IF
    omissionFailure(i, ChipCount) THEN UNCHANGED << Consistency, Reserv >> ELSE
    updateReserv(i) /\ HardMsg' = [ HardMsg EXCEPT ![i] = Tail(HardMsg[i]) ] /\
    UNCHANGED ...
  \end{tla}

  When there is some pending hard message in the buffer ($Len(HardMsg[i]) > 0$) and
  task $i$ has finished processing a previous message ($Head(HardMsg[i]).procTime =
  0$), then the $HardMsg[i]$ variable is updated accordingly.  Recall that
  $procTime$ is initially set to the time needed by slow nodes to process a
  message. When it reaches zero, the node is ready to process another message.

  Also not shown here, the $omissionFailure$ state function was used to verify some
  simple fault scenarios.  When it is true, a reception omission has occurred and
  the variables $Consistency$ and $Reserv$ remain unchanged.
  % The simple fault scenario shown here as an example specifies that an omission
  % failure happens at task 3 in every chip number 2.
  As $Consistency$ is a counter incremented whenever an elementary message is
  received, the reception omission of a hard message implies that $Consistency$ is
  not incremented and task $i$ turns to be inconsistent. Its reservation capacity is
  then limited as described in the $ElemSlot$ action.
  % Although the omission failure scenario used here is simple, more elaborated
  % scenarios were taken into account when checking the protocol.
%
%
  % In this section we prefer to keep this rather simple formulation.  Other fault
  % scenarios ???  -------------------------------- Action
  % -------------------------------
  Otherwise, when $omissionFailure$ is false, the action \emph{updateReserv} updates
  the reservation list upon receiving a message.

  % \newpage
  \begin{tla}
    updateReserv(i) == LET msg == Head(HardMsg[i]) IN IF msg.res = ResMsg THEN /\
    Reserv' = [ Reserv EXCEPT ![i][msg.src] = -1 ] /\ UNCHANGED << Consistency >>
    ELSE /\ Consistency' = [ Consistency EXCEPT ![i] = @ + 1 ] /\ Reserv' = [ Reserv
    EXCEPT ![i] = [j \in Task |-> IF j \in msg.res THEN msg.src ELSE @[j] ] ]
  \end{tla}

  A message received by task $i$ can either be an elementary or a reservation
  message. In the latter case ($msg.res = ResMsg$), the reservation list regarding
  the message sender is reset to -1, accounting for the use of the \RS by the sender
  ($msg.src$). Note that the $Consistency$ variable does not change since
  consistency is related to the reception of elementary messages only.  Conversely,
  when receiving an elementary message, $Consistency$ is incremented and the
  reservation list is updated according to the list carried by the received message.

\label{sec:AcaoTick}

\label{sec:propTemp} 
\label{sec:dorisConc} 

\begin{comment}
         
\subsection{Os \emph{slots} elementares $\ES$}

As tarefas são logicamente organizadas em um anel no qual um único bastão circulante
implícito circula. O bastão circulante é usado para fornecer o direitos de acesso ao meio
de acordo com regras temporais e lógicas.

Para expressar as condições de rotação do bastão circulante no anel crítico $\RTS$,
utiliza-se a função $Id$ definida por: $Id: \mathbb{N}^* \rightarrow \{1, \ldots ,
N_H\}$ que associa a cada chip $\DS_k$ o identificador $Id(k) = (k-1) \, mod(N_H) +
1$.

A circulação regular do bastão circulante é garantido pelo seguinte mecanismo. No fim de
cada $\DS_k$, cada tarefa $i$ do barramento \doris{} incrementa (periodicamente) de
1 seu contador local $K_{T_i}$.  Portanto, o protocolo garante o seguinte
\textbf{invariante}:

\[
\forall \, \DS_k \, (k \in \mathbb{N}^*),\; \forall \, T_i,\; K_{T_i} = Id(k)
\]

Seja $i = Id(k)$, diz-se que $T_i$ adquire o bastão circulante em $\ES_k$ se o seu
contador local $K_{T_i}$ for igual a $i$ e se o seu temporizador $t_{T_i}$ for igual
a $0$ no instante que $\ES_k$ inicia. Por exemplo, considerando $N_H = 4$, $T_3$
adquire o bastão circulante durante $\ES_3$, $\ES_7$, $\ES_{11}$ e assim adiante. O
predicado seguinte formaliza estas condições:

\iniTabSpc
\begin{tabular}{ l l l}
  $ElemHolder(i)$ & $\triangleq$ & $ (t_{T_i} = 0) \;
  \wedge \; (K_{T_i} = i)$
\end{tabular}
\fimTabSpc

Sempre que $ElemHolder(i)$ se torna verdadeiro, $T_i$ emite uma mensagem elementar
no modo um-para-todos.  Esta operação é denotada $sendElemMsg(i)$ e sua execução
pela tarefa $i$ consiste em transmitir seu contador local $K_{T_i}$, sua lista de
reserva $R_i$ (ver na próxima seção) e seus dados ($Data$) se existir
algum. Denota-se $m(E)[info]$ uma mensagem transmitida por um elemento de $E$ e
carregando a informação $info$. Assim, temos:

\iniTabSpc
\begin{tabular}{ l l l }
  $sendElemMsg(i)$ &  $\triangleq$
  & Transmitir $m(\RTS)[K_{T_i}, R_i, Data]$\\
\end{tabular}
\fimTabSpc

Para facilitar a implementação de detectores de falhas e garantir regularidade na
comunicação, obriga-se as tarefas a emitir mensagens elementares em todos os chips
de \doris.

Observa-se que cada $\DS_k$ contém uma mensagem elementar.  Portanto, as tarefas
podem se sincronizar usando a interrupção do EOF de cada mensagem elementar
um-para-todos. Na ausência de falha, cada tarefa pode sincronizar o seu temporizador
uma vez por chip de tamanho $\DDC$.

Se uma mensagem elementar sofre uma falha de omissão, a progressão dos contadores
locais não é comprometida, já que ela depende exclusivamente dos temporizadores
locais.  No entanto, a ocorrência de $n$ falhas consecutivas provoca o aumento dos
desvios dos temporizadores.  Para garantir a confiabilidade do protocolo, o desvio
máximo dos temporizadores deve ser limitado de accordo com o número $n$ de falhas
que o modelo assume tolerar. Estamos ainda estudando estes aspectos do protocolo, e
protanto, estes não serão apresentado neste trabalho.

\subsection{Os \emph{slots} de reserva $\RS$}
\label{sec:reservation}

O mecanismo de reserva disponibiliza uma largura da banda extra para as tarefas,
introduzindo um novo tipo de mensagens transmitidas nos \emph{slots} de reserva.
Para poder ter acesso a estes \emph{slots}, cada tarefa $T_i$ manda uma lista de
reserva quando executa a operação $sendElemMsg(i)$, como foi descrito na seção
anterior.  Esta lista é um subconjunto, possivelmente vazio, de $\{1, 2, \ldots,
N_H\} - \{i\}$ que indica os \emph{slots} da seqüência $RS_k$ que $T_i$ utilizará
para transmitir dados suplementares.  Por exemplo, para $N_H = 4$, a lista de
reserva $\{3,1\}$ mandada por $T_2$ no \emph{slot} $\ES_6$ significa que $T_2$
requer $\RS_7$ e $\RS_9$ em $RS_6$. Se $T_i$ manda uma lista vazia, isto significa
que $T_i$ não efetua nenhuma reserva.

Quando uma tarefa $T_i$ recebe uma lista de reserva emitida no \emph{slot} $\ES_k$,
ela atualiza um vetor booleano de dimensão $N_H$, denotado $\Gamma_i$. Se a entrada
de $\Gamma_i[j=Id(k')]$ é verdade, $\RS_{k'}$ é reservado. Caso contrário,
$\RS_{k'}$ está livre. O valor de $\Gamma_i[j]$ vale para todos os chips da
seqüência $RS_k$ correspondente. Isto significa que $\Gamma_i[j]$ é zerado no fim de
$\DS_{k+N_H-1}$.

Observa-se que a seguinte propriedade é sempre verdadeira: {\em Pelo menos um slot
  de reserva está garantido para cada tarefa $T_i$ numa seqüência $RS_k$ ($k =
  1,2,\ldots$)}.  De fato, $T_i$ ($i = Id(k)$) é a primeira tarefa que pode requerer
uma reserva para o \emph{slot} $\RS_{k+N_H-1}$.

Para que uma tarefa $T_i$ possa transmitir uma mensagem num \emph{slot} que ela
reservou anteriormente, $T_i$ deve ter certeza que a sua reserva deste \emph{slot}
foi realizada com sucesso e que aquele \emph{slot} não está reservado por uma outra
tarefa.  Por exemplo, uma falha por omissão de mensagens elementares poderia deixar
$\Gamma_i$ inconsistente. O protocolo atende a este requisito utilizando uma
condição lógica para efetuar reservas. Para que $T_i$ possa emitir uma lista de
reserva não vazia no \emph{slot} $\ES_k$ , $T_i$ deve estar em estado consistente,
isto é, $T_i$ deve ter recebido todas as mensagens elementares da seqüência de
rotação anterior.  Esta condição é formalizada pelo seguinte predicado para $k >
N_H$:

\iniTabSpc
\begin{tabular}{ l l p{8cm} }
  $Consistency(i, k)$
  & $\triangleq$
  & $T_i$ \textit{recebeu todas as mensagens 
    \newline elementares mandadas em} $RS_{k - N_H}$\\
\end{tabular}
\fimTabSpc

Para $k \leqslant N_H$, $T_i$ é consistente se $T_i$ recebeu todas as mensagens
elementares desde $DS_1$.

Seja $\DES=\delta + IFG$ o tamanho de $\ES$. Uma tarefa $T_i$ adquire o bastão circulante
em $\RS_k$ se ela tem uma reserva para $\RS_k$ e se o seu temporizador $t_{T_i}$ é
igual a $\DES$.  Formalmente,

\iniTabSpc
\begin{tabular}{ l l p{8cm} }
  $ReseHolder(i,k)$ & $\defeq$ & $(t_{T_i} = \DES)$
  $\;\; \wedge \quad (\Gamma_i[K_{T_i} = Id(k)] = true)$\\
\end{tabular}
\fimTabSpc

Como pode ser notado, a dimensão máxima da lista de reserva é $N_H-1$. Portanto,
esta lista pode ser implementada pelo meio de um vetor de bits. Um alternativa
(implícita) mais eficiente consiste em reduzir esta lista ao número de \emph{slots}
de reserva requisitado. Neste caso, uma requisição de $n > 0$ mandada pela tarefa
$T_i$ em $\DS_k$ significa que os próximos $n$ \emph{slots} livres dentro de $RS_k$
devem ser reservados para $T_i$.  Esta implementação precisaria usar $\lceil \log_2
(N_H-1) \rceil$ bits para representar a lista implícita ao invés de $N_H-1$ bits.
No entanto, deve-ser considerado um meio termo entre o tamanho da lista de reserva e
o número máximo de \emph{slots} que cada tarefa pode reservar.  Consideramos aqui o
tamanho da lista como um detalhe de implementação e por isso, não colocamos nenhuma
restrição no seu valor.

Outras propriedades interessantes podem ser observadas.
% \singlespacing
\begin{itemize}
\item Como foi visto, as reservas são efetuadas com confiabilidade, mesmo se falhas
  eventuais de omissão de mensagens forem consideradas.
\item Existem três tipos implícitos de mensagens: as que usam apenas os \emph{slots}
  elementares; as que usam o \emph{slot} de reserva garantido e aquelas que usam os
  \emph{slots} de reserva, eventualmente deixados livres pelas outras tarefas.
  Estes tipos de mensagens agregam flexibilidade ao protocolo em comparação a
  abordagem TDMA.
\item O tempo de rotação do bastão circulante é constante e é igual a $N_t \, \DDC$, o
  que garante regularidade na comunicação para as tarefas.
\end{itemize}
% \onehalfspacing

\section{O anel não-crítico}

Da mesma maneira que no anel crítico, os processos usam os seus temporizadores
locais para controlar a passagem do bastão circulante no anel não-crítico. As mensagens
elementares emitidas pelas tarefas, por ter períodos e tamanhos constantes, servem
de referencial temporal para os processos.  Em breve, o EOF de cada mensagem
elementar serve de pulso que permite deduzir quando o \emph{slot} não-crítico
começa.  Já que o tempo entre o EOF de uma mensagem elementar $m(\ES_k)$ e o início
de uma janela não-crítica (\emph{soft}) $\SW$ é constante, a observação deste EOF
permite determinar o instante de início de $\SW$ dentro de $\DS_k$.  Inspirado no
protocolo VTPE \cite{Carreiro03}, esta idéia de pulso descentralizado constitui uma
melhoria do mecanismo \emph{Timed Packet Release} (TPR) de \cite{Pritty95}
(cf. \ref{sec:protocolos}), já que nenhuma estação ou processo assume o papel
central de emitir periodicamente o \emph{slot pulse}.

Diferentemente do anel crítico, os processos não são obrigados a emitir mensagens
periodicamente. O bastão circulante circula de acordo com o mecanismo de sensoriamento do
meio proporcionado por Ethernet.  Definimos $d_r$ um parâmetro temporal do protocolo
utilizado para definir o mecanismo TPR. As estações monitoram o meio de forma
contínua.  A partir do instante de início de cada janela $\SW$, para cada intervalo
de tempo $d_r$ que o meio permanece livre, o processo $P_i$ incrementa o seu
contador local $K_{P_i}$ de 1.  Se o meio estiver ocupado,isto significa que algum
processo está transmitindo. Neste caso, cada processo espera pelo EOF associado à
transmissão e apenas depois incrementa o seu contador, voltando a monitorar o meio
em seguida.  O valor do parâmetro $d_r$ escolhido é $1 \, \mu s$ (numa rede
100Mbps).  Este valor garante uma detecção sem ambigüidade do início da transmissão
de um quadro por uma outra estação do barramento \doris{} \cite{Pritty95}.

Sintetizando, um processo $P_i$ adquire o acesso ao meio quando o seguinte predicado
acontece:

\iniTabSpc
\begin{tabular}{ l l p{9cm} }
  $SoftHolder(i)$ & $\defeq$ & ($\DHW \leqslant t_{P_i} < \DHW + \DSW) \; 
  \wedge \;$ meio livre $\; \wedge \;(K_{P_i} = i)$\\
\end{tabular}
\fimTabSpc

Enquanto o bastão circulante circula, o tempo restante na janela $\SW_k$
diminui. Portanto, um processo $P_i$ pode receber o bastão circulante quando o tempo
ainda disponível em $\SW_k$ não é suficiente para transmitir sua mensagem. Como este
cenário poderia se repetir um número arbitrário de vezes, $P_i$ poderia se ver
indefinidamente impedido de transmitir sua mensagem.  Para resolver este problema,
definimos uma mensagem ``STOP'' como uma mensagem não-crítica especial de 64B que
para o mecanismo de circulação do bastão circulante nesta janela $\SW_k$.  Quando
$SoftHolder(i)$ é verdadeiro e que $P_i$ não tem tempo para transmitir a sua
mensagem inteira antes do fim de $\SW_k$, $P_i$ emite uma mensagem STOP. Esta
mensagem permite distinguir um processo que não tem tempo suficiente para transmitir
sua mensagem de um que não tem mensagem para transmitir.

Quando $P_i$ manda uma mensagem STOP durante $\SW_k$, ele garante que ele será o
primeiro a receber o bastão circulante na próxima janela $\SW_{k+1}$. Para garantir que
qualquer processo que queira mandar uma mensagem STOP possa enviá-la, introduz-se a
seguinte restrição.  Uma janela $\SW_k$ termina quando o tempo restante nela é igual
a $\delta$. Desta forma, um processo que recebe o bastão circulante sempre tem tempo
suficiente para mandar uma mensagem STOP.

Considerando cenário de falhas, um processo $P_i$ pode sofrer \emph{crash} e depois
voltar a funcionar.  Neste caso, seu contador local $K_{P_i}$ pode estar
desatualizado quando $P_i$ retorna para um estado ativo novamente.  Dois cenários
devem ser tratados.

% \singlespacing
\begin{itemize}
\item Quando uma janela $\SW_k$ está vazia, considera-se que o processo com o menor
  identificador recebe o bastão circulante primeiro na próxima janela $\SW_{k+1}$. Isto é
  feito pela reinicialização dos contadores $K_{P_i}$ a 1 por todos os processos.
\item Se $P_i$ observa a transmissão de uma mensagem não-crítica, ele identifica a
  estação emissor desta mensagem usando o endereço de origem e o \emph{type
    field}. Ele então deduz a posição do bastão circulante usando o valor do instante de
  início do chip $\DS_k$ e o instante de início da transmissão da mensagem obtido a
  partir do seu \emph{Start-Of-Frame}.
\end{itemize}
% \onehalfspacing

Como pode ser observado, o protocolo é confiável em ambos cenários.

No pior caso, se tiver só um processo que queira transmitir, ele pode sofrer um
atraso máximo de $N_H \, d_r$.  Se todos os processos querem transmitir mensagens de
tamanho máximo, o último a receber o bastão circulante espera no maior tempo de rotação
do bastão circulante de \mbox{$(N_H - 1) \, \DDC$}.

Em relação a divisão da largura de banda entre os diferentes tipos de comunicação,
os tamanhos das janelas devem ser escolhidos de forma adequada. Já que duas
mensagens críticas podem ser transmitidas dentro de cada $\DS_k$, cada estação lenta
precisa de $2 \pi$ para processá-las. Portanto, já que existem memórias internas nas
interfaces de rede, a relação $\DSW \geqslant 2 \pi - \DHW$ deve ser verificada.  A
alocação da banda para mensagens críticas é maximizada quando se escolha $\DSW = 2
\pi - \DHW$. Portanto a taxa da banda utilizada para a comunicação crítica é $B_h =
2 \delta / \DDC$.  Pois $\DDC = \DHW + \DSW$, isto implica que $B_h = \delta / \pi$.
Considerando velocidades de processamentos do hardware similares às utilizadas por
\cite{Carreiro03}, podemos utilizar o valor $\pi = 111\mu s$. Deduz-se assim que
$B_h = 4.6\%$.

O resto da banda (95,4\%) é disponível para o anel não-crítico.

O protocolo \doris{} pode ser utilizando com redes baseadas em switch-Ethernet,
utilizando switchs (inverso de \emph{hub}) para implementar a rede física. Neste
caso, o parâmetro $d_r$ do mecanismo TPR precisa ser significativamente maior,
devido aos prazos de roteamento (da ordem de $10 \mu s$ \cite{Wang02}) nos switchs.
Em relação ao valor possível de $d_r = 1 \, \mu s$ em Ethernet compartilhada
(\emph{hub}), a utilização de switchs terá então por conseqüência uma queda
significativa da eficiência da rede.

\section{Uma ilustração gráfica}

\parspace
A Figura~\ref{fig:dorisScenar}, inspirada da ilustração usada em ~\cite{Pritty95}, é
uma representação da circulação do bastão circulante e das mensagens emitidas pelas
diferentes estações num barramento \doris{}. O eixo $x$ representa o tempo e o eixo
$y$ a localização espacial das estações.  As escalas temporais da Figura estão
distorcidas.  Em particular, a inclinação correspondendo a velocidade de propagação
na rede deveria ser menor de pelo menos um fator 4. As cores mais escuras
correspondem às mensagens de tamanho maior, e portanto a intervalos de tempos
maiores.

Este exemplo apresenta um chip de \doris{} com o seguinte cenário:
\par - $T_1$ emite uma mensagem elementar;
\par - $T_7$ emite uma mensagem crítica sob reserva;
\par - Na janela $\SW$, o bastão circulante começa pelo processo $P_1$ que não tem nada
para transmitir;
\par - $P_2$ tem uma mensagem de 512 bytes para transmitir;
\par - $P_3$ e $P_4$ não tem nada para transmitir, portanto dois intervalos de
tempos $d_r$ passam antes do bastão circulante chegar a $P_5$;
\par - $P_5$ tem uma mensagem de 1024 bytes para transmitir;
\par - $P_6$ não tem nada para transmitir;
\par - $P_7$ tem uma mensagem de 512 bytes para transmitir, mas o tempo restante na
janela $\SW$ não é suficiente, portanto $P_7$ emite uma mensagem STOP antes do fim
do \emph{slot} não-crítico.

\begin{figure}[!ht]
  \index{figuras!dorisScenar}%
  % \setlength{\abovecaptionskip}{14pt}
  \centering
  % \includegraphics[scale=0.8]{xfig/dorisScenar}
  \input{fig/dorisScenar.pstex_t}
  \caption{Um exemplo de chip \label{fig:dorisScenar}}
\end{figure}


\section{Composição dos aneis}

\subsection{Modelo}

Para gerar dinamicamente a composição dos dois anéis $\RTS$ e $\SOS$, é preciso
utilizar mecanismos específicos baseados no modelo de falhas adotado
\cite{Lamport84,Cristian95a}.

Neste trabalho, assume-se que os números máximos de tarefas e processos são
conhecidos antes de inicializar o protocolo \doris{} num segmento.  Denota-se
respectivamente $N^{max}_S$ e $N^{max}_H$ estes números.  Considera-se também que as
tarefas e os processos admissíveis nos aneis tem um identificador absoluto único.
Este identificador, denotado $id$, é geralmente diferente do indice da tarefa ou
processo no conjunto $\RTS$ e $\SOS$.

Em relação ao modelo de falha, assume-se que mensagens podem ser corrompidas ou não
emitidas por uma estação (omissão), mas que a função de sensoriamento do meio pelas
estações não falha, isto é, o sensoriamento é confiável. Isto implica que se uma
mensagem é transmitida no meio físico, todas as estações, inclusive a estação
emissora daquela mensagem, percebem a transmissão desta mensagem, mesmo que elas não
consigam a processar corretamente.

Podemos expressar este modelo através das seguintes propriedades:

\begin{itemize}
\item Uma tarefa ou um processo sempre detecta a sua própria falha
  (``self-awareness''),
\item Uma tarefa sempre detecta corretamente a falha de uma outra tarefa.
\end{itemize}

Esta segunda propriedade decorre da periodicidade das mensagens elementares.  Já que
a falha eventual de uma tarefa causa a ausência da mensagem elementar desta tarefa
no seu devido chip, todas as outras tarefas detectam a ausência de mensagem (estado
do meio ``idle'') e inferem a falha da tarefa correspondente.

No caso dos processos, a ausência de uma mensagem pode ser devida a uma falha ou a
ausência de mensagem para ser transmitido por aquele processo. Portanto, outros
processos não podem deduzir nada da ausência, mesmo continuamente repetida, de
mensagens de um certo processo.

Esta propriedade do protocolo \doris{} carateriza a independência entre os dois
anéis, isto é: uma tarefa de $\RTS$ só conhece a composição do anel $\RTS$, mas não
conhece a composição do anel $\SOS$. Da mesma forma, os processos de $\SOS$ não
conhecem a composição de $\RTS$.


\subsection{Mecanismo}

O mecanismo de admissão de tarefas nos aneis $\RTS$ e $\SOS$ utiliza um \emph{round}
de admissão. A sucessão de seqüências de rotação entre dois \emph{round} de admissão
é chamada de ciclo de communicação.  Num ciclo de comunicação, o conjunto de tarefas
membros de

Durante um \emph{round} de admissão, cada tarefa admissível disponha de um slot,
determinado de maneira única atravês do seu identificador absoluto, para transmitir
sua intençao de pertencer ao próximo grupo de comunicação. Se uma tarefa $T_{id}$
emite uma mensagem durante o seu slot de admissão, a propriedade de sensoriamento
confiável implica que todas as tarefas percebem esta mensagem, inclusive a própria
tarefa $T_{id}$. Portanto, todas as tarefas concordam para incluir $T_{id}$ no
próximo grupo de comunicação constituindo $\RTS$.  Se um slot permanece vazio
durante o \emph{round} de admissão, isto signica que a tarefa correspondente não
pertencerá ao próximo grupo de comunicação.  Este mecanismo aproveita ao máximo da
sincronização temporal das estações, interpretando a omissão de uma mensagem num
determinado slot como a ausência da estação correspondente para o próximo ciclo de
communicação.

Para não alterar as propriedades

O seqüenciamento dos slots de admissões baseia-se no sincronismo da


No entanto, uma tarefa que deixa de emitir duas mensagens elementares em seguida é
removida do anel pelas outras tarefas.  Pela propriedade de sensoriamento confiável,
se uma mensagem não é transmitida no meio, por exemplo porque uma falha de omissão
occoreu, a estação que falhou percebe que o seu slot elementar de emissão ficou
vazio, portanto ela ``percebe'' a suas proprias falhas e pode se remover do anel de
forma consistente com as demais estações.


\section{Observações finais}

Uma observação deve ser colocada a respeito do nosso modelo determinístico. Usando
temporizadores, o protocolo de circulação do bastão circulante virtual poderia permitir
que uma tarefa de $\RTS$ se omitisse quando ela não tiver nada para transmitir e que
o bastão circulante passasse logo para a próxima estação, sem espera nenhuma. No entanto,
esta melhoria em termos de eficiência (\emph{throughput}) da comunicação,
introduziria uma variabilidade no tamanho dos chips, sem melhorar o pior caso para
as tarefas com requisitos temporais críticos. Além disso, a detecção de falhas seria
dificultada. Por esta razão, o protocolo \doris{} não implementa esta opção. Ou
seja, para garantir a periodicidade exata dos \emph{slots} de comunicação, o tamanho
$\DDC = \DHW + \DSW$ dos chips é suposto constante. O determinismo introduzido desta
forma facilita a detecção eficiente das falhas de processos; dado que cada chip de
\doris{} contém uma mensagem elementar, a periodicidade do nosso modelo permite
determinar exatamente quando uma mensagem elementar deve ser observada. Portanto, se
no instante previsto, o meio está livre, isto significa que uma falha de omissão ou
de parada ocorreu.  A conseqüência do determinismo assim introduzido é um
\textit{overhead} máximo de $2 \, \delta$ por chip de \doris{}, isto é
aproximadamente 4,6\% da banda.

O protocolo \doris{} precisa que haja pelo menos uma estação crítica atíva no anel
$\RTS$ para funcionar.

Em relação a tolerância a falhas dos canais de comunicação, a redundância do
barramento físico deverá ser considerada ~\cite{Kopetz05,Avizienis04}.


\end{comment}