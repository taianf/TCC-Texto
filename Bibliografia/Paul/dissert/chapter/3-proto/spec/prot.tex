\chapter{\doris: Especificação e verificação}
\label{cap:doris}

\section{Introdução}
\label{sec:intro}

Neste capítulo,  um novo protocolo de comunicação de tempo real, baseado em  Ethernet
compartilhado, é apresentado através das sua especificação formal na linguagem TLA+
\cite{Lamport02a}.

O protocolo \doris, cujo significado em inglês é \emph{An Ethernet
  \underline{Do}uble \underline{Ri}ng \underline{S}ervice for Real -Time Systems},
teve como fontes de inspiração principais os protocolos VTPE \cite{Carreiro03} e
TEMPRA \cite{Pritty95}, apresentados no capítulo \ref{cap:motivacao}.  \doriss foi
concebido para dar suporte a sistemas híbridos nos quais dispositivos industriais
como sensores, atuadores e controladores compartilham a mesma rede de comunicação
com aplicações ou serviços não-críticos. Lembrar que a velocidade de processamento e
as características da comunicação das aplicações de tempo real críticas e das
aplicações com requisitos temporais não-críticos são bastante diferentes. De fato, a
maioria dos dispositivos de pratileira disponíveis tem capacidade de processamento
pequena em relação à largura da banda Ethernet.  Por exemplo, vimos na seção
\ref{sec:sisHibrid}, que Carreiro et al \cite{Carreiro03} utilizaram
micro-controladores que podem gastar até $111 \, \mu s$ para processar uma mensagem
de 64B. Já que o tempo de transmissão de tal mensagem numa rede 100Mbps é $\delta =
5,76 \, \mu s$, isso permite somente cerca de $5,2\%$ de utilização do barramento
para a comunicação com requisitos temporais críticos. Por outro lado, aplicações
não-críticas têm geralmente capacidades de processamento maiores e podem, portanto,
utilizar taxas de transmissão mais elevadas.  Considerando estas características dos
sistemas híbridos, este trabalho propõe \doris, um protocolo novo que combina as
abordagens de bastão circulante e \emph{Time Division Multiple Access} (TDMA) para:
\begin{enumerate}
\item prover previsibilidade num segmento Ethernet compartilhado;
\item oferecer garantias temporais às tarefas de tempo real;
\item disponibilizar a largura de banda não aproveitada pela comunicação
crítica para a comunicação não-crítica. 
\end{enumerate}

A concepção e implementação de um novo protocolo tal que \doriss envolve tomadas de
decisão cautelosa. Neste processo, a especificação formal do protocolo e sua
verificação automática permitem adquirir confiança no projeto elaborado. De fato,
especificar formalmente um sistema e verificar a sua correção de maneira automática
aumenta significativamente a compreensão do seus comportamentos e pode ajudar a
detectar erros ou defeitos de concepção numa fase inicial do desenvolvimento do
\ing{software} \cite{Auslander96, Clarke99}. Tal abordagem, apesar de não ser tão
freqüente na comunidade de pesquisa de rede, já foi utilizado em vários domínios de
aplicação \cite{Barboza06, Johnson04, Hanssen06}.

Na últimas três décadas, várias linguagens formais e ferramentas de verificação foram
desenvolvidas baseadas em lógica temporal \cite{Pnueli79,  Larsen97, Henzinger91}. Por 
exemplo, Esterel \cite{Berry92} é uma linguagem síncrona bastante adequada para especificar 
componentes de \ing{hardware} e para expressar propriedades complexas de circuitos ou 
sistemas síncronos mais amplos.
% However, it is mainly devoted to programming control-dominated software or
% hardware reactive systems.
A linguagem de Especificação e Descrição (SDL) e o padrão Estelle foram recentemente
estendidos para permitir a especificação de Sistemas de Tempo Real \cite{Fischer96,
  Sinnott04}. No entanto, SDL e Estelle são dedicados a descrição formal e a geração
automática de código na fase inicial do projeto e ambas não permitem a verificação
automática do modelo. Várias outras ferramentas são baseadas em automata temporais
tal que Kronos \cite{Daws96} and HyTech \cite{Alur96}.  Promela é agora dotada de
uma extensão de tempo real que fornece uma semântica para a especificação e a
verificação de propriedades temporais \cite{Tripakis96}.  Uma outra ferramenta
bastante utilizada para especificar e verificar sistemas de tempo real é UPPALL
\cite{Larsen97}. Por exemplo, num trabalho recente \cite{Hanssen06}, o protocolo
RTnet, de tempo real baseado em Ethernet, foi especificado e suas propriedades
temporais foram verificadas com UPPAAL.

Uma outra alternativa possível para especificar Sistemas de Tempo Real
\cite{Abadi94,Lamport05} é a linguagem de especificação formal TLA+ (\ing{Temporal
  Logic of Actions}) \cite{Lamport02a}, junto com o seu verificador de modelo
associado TLC (\ing{Temporal Logic Checker}) \cite{Yu99}.  Baseada na teoria dos
conjuntos de Zermelo-Fraenkel e na lógica temporal ~\cite{Pnueli79}, a linguagem
TLA+ foi especialmente concebida para expressar propriedades temporais de sistemas
concorrentes e distribuídos ~\cite{Johnson04}.  A escolha de TLA+ para especificar e
verificar \doriss se deu pelas razões principais seguintes. 
\begin{enumerate}
\item TLA+ tem uma estrutura modular permitindo um processo de escrita por incrementos
  sucessivos, de acordo com o grau de abstração ou de detalhe desejado;
\item Uma especificação em TLA+ é bastante parecida com código de programas, e
  portanto, oferece uma base sólida para a implementação de \doris.
\item O verificadores de modelo TLC permite verificar automaticamente a especificação, 
  assim como as propriedades temporais associadas.
\item Tantos os documentos de definição da linguagem TLA+ como a ferramenta TLC e
  vários exemplos são disponíveis livremente na Internet \cite{TLA}.
\end{enumerate}

Após introduzir alguns termos e considerações sobre o sistema considerado, a seção
\ref{sec:dorisProt} apresentará uma visão geral do protocolo \doris. Em seguida, as
hipóteses de modelagem e uma breve introdução a linguagem TLA+ darão o início da
seção \ref{sec:dorisSpec}, que se prosseguirá com a descrição detalhada da
especificação formal de \doriss. Finalmente, a seção \ref{sec:dorisProp} será
dedicada a discussão das propriedades temporais verificadas. A seção
\ref{sec:dorisConc} concluíra este capítulo.


\section{\doris: o protocolo}
\label{sec:dorisProt}

O protocolo \doriss atua como um filtro lógico, localizado entre as camadas de rede
e física da pilha Ethernet, que elimina as colisões inerentes à camada de controle
de acesso ao meio do protocolo CSMA/CD \cite{CSMA/CD01}.  \doriss é concebido para
dar suporte à sistemas híbridos, nos quais sensores industriais, atuadores e
controladores compartilham a rede de comunicação com as demais aplicações com
requisitos temporais não-críticos. Dispositivos industriais (micro-controladores,
sensores, etc.) são chamados de ``estações lentas'', pois a velocidade de
processamento de tais dispositivo é relativamente baixas em comparação a dos
micro-computadores, chamados de ``estações rápidos''.

\subsection{Sistema, modelo e terminologia}
\label{sec:dorisModel}

O conjunto de estações (lentas e rápidas) interligadas num barramento Ethernet
compartilhado constituem um segmento \doris. Embora vários segmentos \doriss possam
ser inter-conectados por \ing{switches} ou roteadores, a especificação e verificação
de \doris se restringe a um segmento isolado. Em tal segmento, cada estação executa
um servidor \doris, que é responsável pela execução das funcionalidades de \doris.
Uma estação rápida pode hospedar tanto tarefas críticas como também processos com
requisitos temporais não-críticos. Para fins de sobriedade das notações, as
primeiras serão simplesmente chamados de tarefas e os segundos de processos.  Os
dois conjuntos de tarefas e de processos, denotados respectivamente \txtla{TaskSet}
e \txtla{ProcSet}, definem os dois anéis lógicos de um segmento \doris, nos quais um
único bastão circulante circula.

Mensagens enviadas pelas estações lentas são curtas, usualmente periódicas, e têm
requisitos de tempo real críticos.  Assume-se que tais mensagem, chamadas de
``mensagens críticas'', têm um tamanho constante de 64B e que, conseqüentemente, são
transmitidas no barramento no tempo de transmissão $\delta$. Denota-se $\pi$ o tempo
de processamento, no pior caso, da estação mais lenta do segmento \doris.  Assume-se
que $\delta \ll \pi$ e que a recepção e o processamento das mensagens são duas
operações independentes que podem ser realizada simultaneamente.  A primeira
suposição reflete a existência de estações lentas no segmento, enquanto a segunda
corresponde a realidade dos dispositivos de hardware modernos dotadas de memórias
tampões e de capacidade de DMA (\ing{Direct Memory Access}). A segunda suposição
implica, notadamente, que duas ou mais mensagens críticas podem ser enviadas em
seguida. Observa-se que se tiver somente estações lentas presentes no segmento
\doris, a taxa máxima de utilização do barramento é de $\frac{\delta}{\pi +
  \delta}$.  No entanto, se tiver também estações rápidas, a fração da banda não
utilizada pode ser aproveitada pelos processos. É desta constatação que surgiu a
proposta de \doris.

Assim como os protocolos VTPE e TEMPRA (cf seção \ref{sec:TempraVTPE}), \doris{}
utiliza o modelo de comunicação \ing{publish-subscribe} \cite{Dolejs04}, de acordo
com o qual, quando uma aplicação quer enviar uma mensagem, ela utiliza o endereço
Ethernet de comunicação um-para-todos padrão (\cod{FF:FF:FF:FF:FF:FF}).
% Porém, várias aplicações podem ser hospedadas numa mesma estação. Para identificar
% as mensagens de cada aplicação, usa-se o \ing{type field} do quadro Ethernet
% \ref{fig:ethernetFrame}.
Quando um servidor \doris recebe uma mensagem, ele determina, de acordo com a
identidade do seu emissor, se tiver alguma aplicação interessada naquela
mensagem. Caso positivo, ele entrega a mensagem. Senão, ele a descarta.  A
princípio, as tarefas não precisam completar o processamento de todas as mensagens
críticas. No entanto, para simplificar o modelo, assume-se aqui que todas as
mensagens críticas são inteiramente processadas por todas as tarefas.

Em relação ao modelo temporal, assume-se um sistema distribuído síncrono. Isto significa
que as operações efetuadas pelas estações podem ser sincronizado uma com a outra. 
Esta suposição se baseia no esquema de divisão temporal de \doris, que como será vista, 
tem pontos de sincronização regulares e previsíveis, que ocorre dentro de uma janela
de tempo curta comparada com o desvio dos relógios locais. Isto implica que
os relógios locais das estações são sincronizados.

Por fim, assume-se que as estações podem falhar por \ing{crash}, ou seja, parar
qualquer tipo de atividade \cite{Schlichting83}, e voltar a funcionar normalmente
depois de um tempo arbitrário. Mensagens enviadas podem eventualmente ser perdidas,
porém, estações rápidas devem imperativamente perceber a interrupção associada a
recepção de uma mensagem, mesmo que o conteúdo da mensagem seja perdido. Como será
visto, este requisitos é necessário para controlar a circulação do bastão circulante
entre os processos.  De acordo com as necessidades das aplicações críticas, esta
restrição não se aplica às estações lentas, pois têm capacidades de processamento
menores.


\subsection{O esquema de Controle de Acesso ao Meio}
\label{sec:dorisMAC}

A comunicação num barramento \doriss é temporalmente dividida em uma alternância de
fases (\ing{rounds}) de comunicação (\emph{C-Rd}) e fases (\ing{rounds}) de
configuração dos membros (\emph{M-Rd}), assim como ilustrado na figura
\ref{fig:dorisStruct}. Durante a fase de configuração, o algoritmo de controle da
composição do segmento \doriss é responsável por estabelecer uma visão única da
composição do grupo de participantes do segmento \doris, compartilhada por todos os
membros deste segmento. O problema do estabelecimento de tal visão, conhecido também
como o problema do consenso, é assuntos de vários trabalhos \cite{Cristian88,
  Chandra96, Lamport98}.  No contexto desta dissertação, considera-se que os grupos
de tarefas \cmtla{TaskSet} e processos \cmtla{ProcSet} são definidos em tempo de
projeto e especifica-se somente a fase de comunicação do protocolo
\doriss. Denota-se $nTask$ e $nProc$ os cardinais destes dois conjuntos.

\begin{figure}[tb]
  \centering
  \input{fig/dorisStruct.pstex_t}
  \caption{O esquema de Divisão Temporal de \doris}
  \label{fig:dorisStruct}
\end{figure}

Usando TDMA, cada fase de comunicação (\emph{C-Rd}) é definida como um número
arbitrário, porém fixo, de ciclos periódicos, os quais são subdivididos em
exatamente $nTask$ \ing{chips} (ver figura \ref{fig:dorisStruct}). Um mapeamento dos
naturais sobre o conjunto dos \ing{chips} associa um inteiro positivo módulo $nTask$
a um \ing{chip}. Este contador é denotado $chipCount$. Cada chip é, por sua vez,
dividido em duas janelas, críticas e não-críticas, denotadas \HW e \SW, e
associadas, respectivamente, as comunicações de tempo real críticas e
não-críticas. As tarefas só transmitem mensagens durante as janelas \HW, enquanto
os processos apenas utilizam \SW para transmitir as suas. Os tamanhos destas duas
janelas são respectivamente denotados por \DHW e \DSW e o tamanho de um chip é
definido por $\DDC = \DHW + \DSW$. Para permitir um certa flexibilidade e a
definição de políticas de escalonamento das mensagens, a janela \HW é também
subdividida em dois \ing{slots}: o \ing{slot} elementar (\ES) e o \ing{slot} de
reserva (\RS).  As mensagens transmitidas nos \ing{slots} \ES e \RS são mensagens
críticas, chamadas respectivamente de mensagem elementar e de reserva. Uma vez por
ciclo, cada tarefa envia uma mensagem elementar dentro de \ES enquanto \RS é
utilizada para oferecer um mecanismo de reserva. De forma a tolerar falhas por
\ing{crash} e prover confiabilidade do sistema inteiro, tarefas não falidas são
obrigadas a enviar uma única mensagem elementar por ciclo.

Observa-se que, com o objetivo de facilitar a apresentação e a especificação de
\doris, assume-se que cada tarefa pode enviar uma única mensagem elementar por
ciclo. No entanto, esta suposição poderia ser levada, de acordo com o algoritmo
utilizado na fase de configuração, alocando um número arbitrário de \ing{chip} por
ciclo a cada servidor.  Caberia então a cada servidor alocar seus \ing{chips} às tarefas
sob sua responsabilidade. 

O mecanismo de reserva funciona da seguinte maneira. Cada mensagem elementar enviada
por uma tarefa $i$ carrega uma lista de inteiros (módulo $nTask$) que especifica os
identificadores dos \ing{slots} que $i$ pretende usar para enviar mensagens
adicionais. Esta lista é um subconjunto do conjunto dos $nTask$ \ing{chips} seguindo
o \ing{chip} no qual $i$ envia sua mensagem. A tarefa $i$ só pode reservar um
\ing{slot} que ainda não foi reservado por uma outra tarefa. Para este efeito, cada
servidor mantém uma vetor de reservas, denotada $res$, na qual ele armazena as
reservas especificadas em cada mensagem elementar recebida. A consistência do vetor
$res$ pode eventualmente ser comprometida por falhas de omissão de mensagens
elementares. Efetivamente, quando um servidor não recebe uma mensagem elementar, ele
deixa de atualizar $res$ e alguma tarefa pode tentar reservar algum
\ing{slot} previamente reservado. Para evitar tal cenário que poderia levar a uma
colisão, uma tarefa $T_i$ só pode reservar um \ing{slot}, se o vetor $res$ do
seu servidor estiver em estado consistente, isto é, se o servidor de $T_i$ tiver
recebido as $nTask$ mensagens elementares precedendo o \ing{chip} de emissão de
$T_i$. Desta forma, a alocação dinâmica de \ing{slots} de reserva é tolerante à
falhas de omissão. Este mecanismo de reserva é uma inovação do protocolo \doriss que
permite a implementação de alguma política de escalonamento. Efetivamente, uma
tarefa dispõe de um \ing{slot} elementar por ciclo e pode usar até $nTask$ outros
\ing{slots}. No entanto, a discussão de tal política foge do escopo desta
dissertação.

O controle de acesso ao meio de \doriss é organizada por um bastão circulante 
virtual, que circula nos anéis críticos e não-críticos (ver seção \ref{sec:dorisModel}).
O bastão circulante é dito virtual porque sua transmissão é associada à regras temporais
e lógicas baseadas na observação da comunicação acontecendo. A isolação dos dois 
anéis de \doriss é garantida pelo uso do mecanismo de TDMA. Em relação ao anel
não-crítico, o bastão virtual circula durante a janela \SW a cada vez que uma interrupção é
gerada pela placa de rede. Quando um processo não tem nenhuma mensagem à transmitir,
o servidor envia uma mensagem de tamanho mínimo para passar o bastão circulante ao
próximo processo do anel não-crítico.
 
Observa-se que numa fase inicial de concepção do protocolo \doris, pensou-se em
utilizar a capacidade de sensoriamento do meio para organizar a transmissão do
bastão utilizando o mecanismo TPR do protocolo Tempra \ref{sec:TempraVTPE}. No
entanto, em frente a dificuldade de conseguir placas de rede que permitam o acesso ao
estado do meio (\ing{idle} ou ocupado), esta possibilidade foi descartada. 


\section{A especificação formal de \doris }
\label{sec:dorisSpec}

A metodologia descritiva para apresentar a especificação de \doriss segue uma
abordagem indo de cima para baixo. Antes de entrar na descrição dos detalhes da
especificação, a seção \label{sec:modelHipot} descreve o conjunto das hipóteses de
modelagem adotadas para especificar o protocolo. Em seguida, a seção
\ref{sec:basicTLA} introduz alguns conceitos básicos de TLA+. As demais seções
apresentam as principais fórmulas que compõe a especificação formal de \doris. No
âmbito de focalizar a descrição da especificação no protocolo \doris e na
verificação das suas propriedades, algumas fórmulas foram omitidas. No entanto, a
especificação completa está sendo anexada no final desta dissertação no apêndice
\ref{app:especificacao}.

\subsection{Hipóteses de modelagem}
\label{sec:modelHipot}

Características importantes do sistema devem ser incluídas na especificação de modo
que se possa verificar propriedades interessantes. No entanto, é preciso ter cuidado
para não especificar muitos detalhes devido ao problema da explosão de estados
durante a verificação automática do modelo. As suposições feitas nesta seção tem por
finalidade contornar este problema sem comprometer a descrição o protocolo e sua
verificação.

Em primeiro lugar, como o nosso principal objetivo aqui é fornecer uma descrição
formal do protocolo \doris, a fim de verificar a sua correção, suponha-se que cada
estação hospeda apenas uma tarefa ou processo. Desta forma, evita-se a necessidade
de especificar os servidores \doris.

Em segundo lugar, representa-se o tempo por uma variável inteira. Embora tal
representação discreta do tempo possa comprometer a precisão do modelo no caso de
sistemas assíncronos em geral \cite{Clarke99}, ela é aceitável para protocolos síncronos
baseados em troca de mensagens \cite{Lamport05}.

Em terceiro lugar, considera-se que, sempre que uma ação especificada for habilitadas,
ela acontece sem demora ou é desabilitada imediatamente. Isto significa
que os temporizadores são especificados sem desvios.

Finalmente, considera-se que todas as estações compartilham um relógio comum global,
pois assume-se um modelo síncrono para evitar a especificação de detalhes de
sincronização. Observa-se que na prática todos as estações podem sincronizar os seus
relógios locais com precisão, pois as mensagens elementares são obrigatórias e
periódicas.  Detalhes de tal procedimento serão abordados na fase de implementação
descrita no capítulo \ref{cap:implementacao}.

É importante notar que as considerações sobre o desvio nulo dos relógios e sobre a
sincronia do sistema permite a definição de temporizadores global na especificação,
o que reduz consideravelmente os problemas de explosão de estados.

\subsection{Conceitos de TLA+}
\label{sec:basicTLA}

A Lógica Temporal de Ações (TLA) e sua linguagem formal associada (TLA +) combina a
Lógica Temporal de TLA \cite{Lamport94a} com a expressividade da lógica dos
predicados e a teoria dos conjuntos de Zermelo-Fraenkel. Dotado do verificador de
modelo TLC \cite{Yu99}, TLA+ permite a especificação e a verificação tanto de
protocolos de \ing{hardware} quanto de sistemas distribuídos. Esta seção apresenta
algumas sintaxes básicas de TLA +. Quando necessário, informações complementares
sobre TLA + serão dada ao longo da descrição da especificação de \doris.  Leitores
interessados numa descrição ampla de TLA + podem se referir a publicação de Lamport
\cite{Lamport02a}.

Numa especificação em TLA+, uma computação de um sistema é representada por um
seqüência de estados, também chamada de comportamento. Para caracterizar os estados
do sistema, uma especificação define o conjunto de variáveis (\textsc{variables})
utilizado para descrever o sistema e o conjunto de constantes (\textsc{constants}),
que são utilizadas para definir os valores eventualmente atribuídos às variáveis.
Um \textbf{estado} do sistema é portanto definido pela atribuição de valores
constantes, às variáveis da especificação.

Um pare de estados consecutivos, suponha $i$ e $f$ em referência a inicial e final,
é chamada de \textbf{passo} e é denotado \txtla{i \.{\rightarrow} f}. O operador
linha ``\txtla{\,'\,}'' é utilizado para distinguir os valores de variáveis num
passo. Considerando um certo passo \txtla{P: i \.{\rightarrow} f} e uma variável
$v$, a ocorrência de $v$ sem linha ($v$) faz referência ao valor de $v$ em $i$,
enquanto a ocorrência de $v$ com linha ($v'$) faz referência ao valor de $v$ em $f$.

Uma \textbf{função de estado} é um expressão na qual aparecem somente variáveis sem
linhas. Tal função associa valores constantes aos estados de um comportamento.  As
funções de estado a valores booleanas são simplesmente chamados de \textbf{predicados} de
estado. 

Uma \textbf{função de transição} é uma expressão na qual aparecem variáveis sem
linhas e com linhas. Portanto, denotando $\mathcal{P}$ o conjunto dos passos de um
sistema, uma função de transição $F$ é um mapeamento de $\mathcal{P}$ sobre
$F(\mathcal{P})$. Por exemplo, seja um passo \txtla{P: i \.{\rightarrow} f} e $v$
uma variável, tal que $v = 0$ no estado $i$ e $v = 1$ no estado $f$, e seja $F$ a
função de transição definida por $F(P) = v' - v$, tem-se $F(P) = 1$.

Finalmente, uma \textbf{ação} é, por definição, uma função de transição a valores
booleana. Portanto, uma ação é um mapeamento de $\mathcal{P}$ sobre $\{ V, F \}$,
onde $V$ e $F$ correspondem aos valores de verdade e falso da lógica dos
predicados. Considerando o exemplo apresentado acima, a ação $\mathcal{A}$, definida
pela expressão \txtla{\mathcal{A} \defeq v' = v + 1}, na qual o símbolo TLA+ significa
 ``igual, por definição'', é verdadeira no passo $P$.
%Observa-se aqui que o significado do símbolo TLA+ ``\txtla{\defeq}'' é: ``igual, por definição''.  
Para um dado passo $P$, a relação de sucessão do estado
$i$ para o estado $f$, usualmente chamada de função de transição de estado no
formalismo das Máquinas de Estado Finitos, é definida pelo conjunto de ações
definidas sobre o passo $P$. Este conjunto também é uma ação, pois uma ação pode ser
composta de várias ações.

As fórmulas temporais de TLA+, como por exemplo, a relação de transição entre
estados, são asserções booleanas sobre comportamentos.  Diz-se que um comportamento
satisfaz uma fórmula $\mathcal{F}$ se $\mathcal{F}$ é uma asserção verdadeira deste
comportamento.  O operador da lógica temporal $\Box$ é utilizado para escrever as
fórmulas temporais. A semântica do operador $\Box$ é definida da seguinte maneira.
Para algum comportamento $\Sigma$, e alguma ação $\mathcal{A}$, a fórmula temporal
$\mathcal{F} = \Box [ \mathcal{A} ]_{vars}$ é verdadeira -- ou simplesmente ``$\, \Sigma$
satisfaz $\mathcal{F} \,$'' -- se e somente se, para qualquer passo  \txtla{P: i \.{\rightarrow} f} de
$\Sigma$ que altera o conjunto $vars$ de todas as variáveis, $A$ é verdadeira em
$P$.

\subsection{Constantes e variáveis}

\begin{table}[t!b]
  \begin{center}
    \begin{tabular}{ | c |  p{12cm} | }
      \hline  \hline 
      \textbf{Constantes}
      & \textbf{Descrição}    \rule{0pt}{6.mm}  \\[1.4mm]
      \hline
      \txtla{nTask} \vbar     
      & Número de tarefas participando do segmento \doris. \vspc
      \hline
      \txtla{nProc} \vbar     
      & Número de processos participando do segmento \doris.  \vspc 
      \hline
      \txtla{deltaChip} \vbar     
      & Duração ($\Delta_C$) de um \ing{chip}.  \vspc 
      \hline
      \txtla{delta} \vbar     
      & Tempo de transmissão ($\delta$) de um quadro Ethernet de tamanho mínimo.  \vspc 
      \hline
      \txtla{pi} \vbar     
      & Tempo de processamento ($\pi$) de uma mensagem crítica pelo dispositivo
      mais lento.  \vspc 
      \hline
      \txtla{softMsgSize} \vbar     
      & Tempo de transmissão de um quadro Ethernet de tamanho máximo.  \vspc 
      \hline \hline
    \end{tabular}
    \caption{O conjunto \textsc{constants} da especificação de \doris}
    \label{tab:specCons}
  \end{center}
\end{table}

As constantes da especificação de \doriss são definidas na tabela
\ref{tab:specCons}. Um exemplo de valores utilizadas para verificar \doris é, por
exemplo: $nTask = 5, nProc = 7, deltaChip = 260, delta = 6, pi = 111, softMsgSize =
122$. Os valores de $nTask$ e $nProc$ são escolhidos arbitrariamente. Porém, valores
muito grandes provocam uma explosão do número de estados do sistema.  Os valores de
delta ($\delta$) e $softMsgSize$ correspondem aos tempos de transmissão em $\mu s$ de
mensagens de 72 bytes e 1524 bytes num barramento Ethernet de 100Mbps (ver seção
\ref{sec:sisHibrid}).  $pi$ ($\pi$) é o tempo utilizado por \cite{Carreiro03}. Finalmente,
$\Delta_C$ deve ser maior que $2 \pi$, para garantir que as duas mensagens críticas
enviadas num \ing{chip} sejam processadas antes do início do próximo \ing{chip}.

%\bigskip
\begin{table}[htb!]
  \begin{center}
    \begin{tabular}{ | p{20.5mm} | @{} p{120.5mm} @{} |}
      \hline  \hline 
      \textbf{Variável}
      &
      \begin{tabular}{  p{18mm} | p{94.mm} }
        \textbf{Campo}  & \textbf{Descrição} \rule{0pt}{6.mm}  \\[1.4mm]
      \end{tabular}\\

      \hline
      \parbox{20.5mm}{\txtla{Shared} (global)}
      &
      \begin{tabular}{  p{18mm} | p{94.mm} }
        \raisebox{-2mm}{\txtla{chipTimer}} 
        & \vbar é um temporizador crescente que varia de 0 a $\Delta_C$ 
        \newline (\txtla{deltaChip}).  \vspc \hline

        \txtla{chipCount}
        & \vbar é um contador que identifica os \ing{chips} módulo $nTask$. 
         \vspc \hline 
        
        \raisebox{-5mm}{\txtla{medium}}\vbar
        &  representa o estado do meio.  Na ausência de transmissão, \txtla{medium}  está vazia. 
        Senão, \txtla{medium} contem a mensagem sendo transmitida. \vspc \hline     

        \raisebox{-5mm}{\txtla{macTimer}}\vbar
        & é um temporizador decrescente que representa o tempo durante o qual o meio
        ficará ocupado \cmtla{medium \.{\neq} \{ \}} pela transmissão de uma mensagem. \vspc     
      \end{tabular}\\

      \hline
      \parbox{20.5mm}{\txtla{TaskState} (vetor local)}
      &
      \begin{tabular}{  p{18mm} | p{94.mm} }
        \raisebox{-5mm}{\txtla{msg}}\vbar
        & representa a lista de mensagens críticas armazenadas na memória tampão (DMA)
        após recepção na placa de rede. \vspc  \hline

        \raisebox{-2mm}{\txtla{res}}\vbar
        & é a lista de reservas existentes para os \txtla{nTask} próximos \ing{slots}. \vspc \hline

        \raisebox{-5mm}{\txtla{cons}}\vbar
        & é um contador que contabiliza o número de mensagens elementares recebidas
        desde a última emissão de uma mensagem elementar. \vspc
      \end{tabular}\\

      \hline
      \parbox{20.5mm}{\txtla{ProcState} (vetor local)}
      &
      \begin{tabular}{  p{18mm} | p{94.mm} }
        \raisebox{-2mm}{\txtla{token}}\vbar
        & é o contador associado ao bastão circulante utilizado nas janelas \SW.  \vspc  \hline

        \raisebox{-2mm}{\txtla{list}}\vbar
        & é a lista das mensagem não-críticas esperando para ser enviadas.  \vspc  \hline

        \raisebox{-2mm}{\txtla{count}}\vbar
        & é um contador que contabiliza o número de mensagens não-críticas recebidas
        durante uma janela \SW.  \vspc
      \end{tabular}\\

      \hline
      \parbox{20.5mm}{\txtla{History} (observador global)}
      &
      \begin{tabular}{  p{18mm} | p{94.mm} }
        \raisebox{-2mm}{\txtla{elemSlot}}\vbar
        & é um contador que contabiliza o número de mensagens elementares enviadas
        num ciclo. \vspc \hline
      
        \raisebox{-2mm}{\txtla{reseSlot}}\vbar
        & é um contador que contabiliza o número de mensagens de reservas enviadas
        num ciclo.  \vspc 
      \end{tabular}\\
      \hline \hline
    \end{tabular}
    \caption{O conjunto \textsc{variables} da especificação de \doris}
    \label{tab:specVars}
  \end{center}
\end{table}

%\clearpage

Outras constantes podem ser definidas no decorrer da especificação, utilizando o
símbolo ``\txtla{\defeq}'' (cujo significado é: ``igual, por definição'').  Por
exemplo, definem-se \txtla{ Task \.{\defeq} 1 \.{\dotdot} nTask} e \txtla{ Proc
  \.{\defeq} 1 \.{\dotdot} nProc}, os dois conjuntos de inteiros respectivamente
isomorfos a \txtla{TaskSet} e \txtla{ProcSet}.  Nestas definições, a definição do
símbolo ``\txtla{\,{..}}'' é: para dois inteiros $i$, $j$ tal que $i < j$, \txtla{ i
  \.{\dotdot} j \.{\defeq} \{ i ,\, i \.{+} 1 , \.{\ldots} ,\, j \}}. Outros
exemplos são as definições subseqüente dos conjuntos: \txtla{TaskSet \.{\defeq} \{ T
  [ i ] \.{:} i \.{\in} Task \}} e \txtla{ProcSet \.{\defeq} \{ P [ j ] \.{:} j
  \.{\in} Proc \}}.

Em relação as variáveis da especificação, apresentadas na tabela \ref{tab:specVars},
agrupou-se elas em quatro estruturas chamadas $Shared$, $TaskState$, $ProcState$ e
$History$ de acordo com as suas características. A variável $Shared$ é uma tupla com
quatro campos, utilizada para armazenar a visão distribuída compartilhada por
todos. As duas outras variáveis, $TaskState$ e $ProcState$, são vetores de dimensão
respectivas $nTask$ e $nProc$, que armazenam em tuplas de 3 campos, as informações
locais de cada tarefa e processo.  Finalmente, a variável $History$ é uma tupla com
2 campos, utilizada para especificar propriedades temporais. Esta variável é apenas
um observador e não interfere na especificação do protocolo. O detalhe da definição
dos diferentes campos destas quatro variáveis é apresentado na tabela
\ref{tab:specVars}.

\subsection{A fórmula principal de \doris}

\act{Spec} A fórmula \txtla{Spec}, fórmula principal da especificação de \doris{}, é definida por

\begin{mytla}
\begin{tla}
  Spec == Init /\ [] [ Next \/ Tick ]_vars /\ Liveness
\end{tla}
\begin{tlatex}
 \@x{\@s{100.} Spec \.{\defeq} Init \.{\land} {\Box} [ Next \.{\lor} Tick ]_{
 vars} \.{\land} Liveness}%
\end{tlatex}
\end{mytla}

\txtla{Init} é o conjunto dos estados iniciais, \txtla{{\Box} [ Next \.{\lor} Tick
  ]_{ vars}} é a relação de sucessão, aqui composta da disjunção das duas ações
\txtla{Next} ou \txtla{Tick}, e \txtla{Liveness} é uma condição de evolução do
sistema.  \txtla{Next} e \txtla{Tick} são os conjuntos de ações que podem ser
verdadeira num certo passo de um comportamento. Conseqüentemente, um comportamento
$\Sigma$ satisfaz \txtla{Spec} se e somente se o primeiro estado de $\Sigma$ é um
elemento de \txtla{Init} e se todos os passos de $\Sigma$ satisfazem \txtla{Next} ou
\txtla{Tick} e a condição \txtla{Liveness}.

Observa-se que em conseqüência da estrutura temporal de \doris, vista na seção
\ref{sec:dorisMAC}, a maioria das ações de \doris{} são regidas por condições
exclusivas. Portanto, o operador ``\txtla{\lor}'' é exclusivo em quase todas as suas
ocorrências.

\act{Init} A fórmula \txtla{Init} descreve o conjunto dos estados iniciais do sistema, ou
seja, \txtla{Init} é a definição dos conjuntos de valores inicias possíveis para cada variável da
especificação. Aqui, cada conjunto tem um elemento só, pois considera-se um estado
inicial único do sistema.

\begin{mytla}
\begin{tla}
Init ==  /\ Shared = [ chipTimer |-> 0, chipCount |-> 1, medium |-> {}, macTimer |-> 0 ]
         /\ TaskState = [ i \in Task |-> 
                 [ msg |-> << >>, res |-> [ j \in Task |-> -1 ], cons |-> nTask - i + 1 ] ] 
         /\ ProcState = [ j \in Proc |-> [ token |-> 1, list |-> list(j), count |-> 0 ] ]
         /\ History = [ elemSlot |-> 0, reseSlot |-> 0 ]
\end{tla}
\begin{tlatex}
 \@x{ Init \.{\defeq}\@s{4.1} \.{\land} Shared \.{=} [ chipTimer \.{\mapsto} 0
 ,\, chipCount \.{\mapsto} 1 ,\, medium \.{\mapsto} \{ \} ,\, macTimer
 \.{\mapsto} 0 ]}%
\@x{\@s{46.33} \.{\land} TaskState \.{=} [ i \.{\in} Task \.{\mapsto}}%
 \@x{\@s{80.16} [ msg \.{\mapsto} {\langle} {\rangle} ,\, res \.{\mapsto} [ j
 \.{\in} Task \.{\mapsto} \.{-} 1 ] ,\, cons \.{\mapsto} nTask \.{-} i \.{+}
 1 ] ]}%
 \@x{\@s{46.33} \.{\land} ProcState \.{=} [ j \.{\in} Proc \.{\mapsto} [
 token\@s{10.29} \.{\mapsto} 1 ,\, list \.{\mapsto} list ( j ) ,\, count
 \.{\mapsto} 0 ] ]}%
 \@x{\@s{46.33} \.{\land} History \.{=} [ elemSlot \.{\mapsto} 0 ,\, reseSlot
 \.{\mapsto} 0 ]}%
\end{tlatex}
\end{mytla}

É importante esclarecer aqui duas particularidades de TLA+. Em primeiro lugar, em
TLA+, a indentação das formulas é utilizada, em combinação com as conjunções e os
operadores lógicos, para limitar o uso de parênteses.  Em segundo lugar, uma expressão
tal que, por exemplo,  \txtla{[ j \.{\in} Task \.{\mapsto} \.{-} 1 ]}, representa o vetor de dimensão
$nTask$ cujo as coordenadas são $-1$. Isto implica, neste caso, que, no estado
inicial: \begin{tlatex} \@xx{ \A\, i ,\, j \.{\in} Task \.{:}\@s{4.1} TaskState [ i
    ] . res [ j ] \.{=} \.{-} 1} \end{tlatex}. Lembrar da seção \ref{sec:dorisMAC}
que $res$ é o vetor que armazena as reservas recebidas por uma tarefa. O valor
arbitrário $-1$ é utilizado aqui, para indicar que não há reserva para o
\ing{slot} correspondente.

Voltando à descrição da fórmula \txtla{Init}, os valores definidos para os quatro
campos da variável global \txtla{Shared} indicam que o \ing{chip}~$1$
\cmtla{chipCount \.{\mapsto} 1} está iniciando \cmtla{chipTimer \.{\mapsto} 0}, que
o meio está vazio \cmtla{medium \.{\mapsto} \{ \}} e que \txtla{macTimer}
é nulo, pois nenhuma mensagem está sendo transmitida.

No caso das variáveis locais, \txtla{TaskState} e \txtla{ProcState},  as fórmulas têm o seguinte
significado:
\begin{itemize}
\item Cada tarefa $i$ do conjunto \txtla{Task} assume que a sua lista de mensagens
  críticas para ser processadas está vazia \cmtla{msg \.{\mapsto} {\langle}
    {\rangle}}, que a sua lista de reservas também está vazia, ou seja, todas os
  campos do vetor \txtla{res} valem $-1$ \cmtla{res \.{\mapsto} [ j \.{\in} Task
    \.{\mapsto} \.{-} 1 ]}, e que ela esta num estado consistente \cmtla{cons
    \.{\mapsto} nTask \.{-} i \.{+} 1 }. Lembrar que uma tarefa está num estado
  consistente se ela recebeu todas as mensagens elementares desde o último \ES no
  qual ela enviou uma mensagem (ver seção \ref{sec:dorisMAC}).
\item Cada processo $j$ do conjunto \txtla{Proc} assume que o processo $1$ está em
  posse do bastão circulante \cmtla{token \.{\mapsto} 1}, utiliza a função de estado
  \txtla{list}, previamente definida, para definir a lista da suas mensagens
  não-críticas, e assume que ele ainda não recebeu nenhuma mensagem não-crítica
  \cmtla{count \.{\mapsto} 0}. Notar que a lista de mensagem \txtla{list(j)} é escolhida
  arbitrariamente de acordo com o cenário de verificação desejado.
\end{itemize}

Finalmente, os dois contadores de mensagens elementares e de reservas da variável de
observação \txtla{History} são inicializados a $0$ \cmtla{elemSlot \.{\mapsto} 0 ,\, reseSlot
 \.{\mapsto} 0}. 

\act{Next} Esta ação descreve as funcionalidades do protocolo que acontecem
instantaneamente, ou seja, as ações que não decrementam os temporizadores, pois suas
durações são muito curtas, comparativamente com os tempos de transmissões das
mensagens.  Isto é o caso aqui, das operações de emissão e recepção de mensagens.
Lembrar que, para as tarefas, receber não significa processar, mas somente colocar
na memória tampão da placa de rede.

\begin{mytla} 
\begin{notla} 
Next  ==  \/ \E q \in TaskSet \cup ProcSet : SendElem(q) \/ SendRese(q) \/ SendSoft(q)
          \/ \E msg \in Shared.medium : RecvHard(msg) \/ RecvSoft(msg)
\end{notla}
\begin{tlatex}
 \@x{ Next\@s{4.1} \.{\defeq}\@s{4.1} \.{\lor} \E\, q \.{\in} TaskSet \.{\cup}
 ProcSet \.{:} SendSoft ( q ) \.{\lor} SendElem ( q ) \.{\lor} SendRese ( q
 )}%
 \@x{\@s{55.22} \.{\lor} \E\, msg \.{\in} Shared . medium \.{:} RecvHard ( msg
 ) \.{\lor} RecvSoft ( msg )}%
\end{tlatex}
\end{mytla} 

Como pode ser observado, \txtla{Next} é uma disjunção de cinco ações, correspondendo
à emissão e recepção de mensagens. A primeira linha especifica à emissão de uma
mensagem, quer seja por uma tarefa ou um processo.  As três ações \txtla{SendElem},
\txtla{SendRese} e \txtla{SendSoft} correspondem às janelas \HW -- subdividida em
\ES e \RS -- e \SW de \doriss.  A segunda linha especifica a recepção de uma
mensagem presente no meio, de acordo com o seu tipo.  \txtla{RecvHard} corresponde à
recepção de uma mensagem crítica, enquanto \txtla{RecvSoft} corresponde à recepção
de uma mensagem não-crítica.

Assim que será visto nas próximas seções, cada uma destas ações é regida por um conjunto
de predicados, também chamado de condições de realizações ou guarda (\ing{enabling
  condition}). Considera-se agora um estado $e$ alcançável da especificação, isto é,
tal que tenha uma seqüência de passos levando de \txtla{i \.{\in} Init} até
$e$. Suponha ainda que no estado $e$, pelo menos um dos guardas das cinco ações
sejam falsos. Neste caso, existem somente duas possibilidades: ou o sistema ficou
bloqueado (\ing{deadlock}), ou a ação \txtla{Tick} está habilitada.

\act{Tick} Esta ação, definida pela fórmula \txtla{Tick \.{\defeq} NextTick \.{\lor}
  NextChip} representa o fluxo do tempo. Para permitir a verificação de alguns
modelos finitos do sistema, apesar da natureza sem limite do tempo, utilizou-se uma
representação do tempo circular. Isto foi realizado dividindo a ação \txtla{Tick} na
disjunção de duas ações: \txtla{NextTick}, que incrementa o tempo por passos
discretos, e \txtla{NextChip}, que realiza a transição de um \ing{chip} para o
próximo. Se fosse só a ação \txtla{NextTick}, o temporizador \txtla{chipTimer} ia crescer
indefinidamente. Porém, a ação \txtla{NextChip} redefine o
temporizador \txtla{chipTimer} para o valor $0$ novamente de tal forma que este
temporizador só varia entre $0$ e $\Delta_C$. Além disso, o contador $chipCount$ é também
redefinido para o seu valor inicial $1$, sempre que ele atínge o valor $nTask$. Desta forma, esta
representação do tempo permite verificar comportamentos do sistema durante um ciclo
completo de \doris.

\act{Liveness} Esta restrição, definida pela fórmula \txtla{Liveness
  \.{\defeq} {\Box} {\Diamond} Tick}, (na qual \txtla{ {\Diamond} F
  \.{\defeq} {\neg} {\Box} {\neg} F}) garante que um comportamento que satisfaz
$Spec$ tenha estados em todos os \ing{chips} de um ciclo de \doris. De fato, devido
a representação circular do tempo, \txtla{Liveness} é satisfeita apenas por
comportamentos cíclicos, porém sem bloqueio, permitindo a verificação de modelos
finitos de \doris.

\subsection{Guia de leitura}

Agrupou-se, nesta seção, várias informações úteis para a compreensão da
especificação de \doris. Além dos elementos descritivos da especificação, alguns
operadores da linguagem TLA+ são também introduzidos.

Como foi visto na seção anterior, a especificação de \doris é constituída por 7
ações principais, as cinco que compõe a fórmula \txtla{Next} mais as duas que compõe
a fórmula \txtla{Tick}.

O conjunto de fórmula de cada ação principal de \doris é dividida em dois conjuntos
lógicos diferentes. O primeiro conjunto é constituído pelos guardas -- predicados de
estados que só envolvem constantes e variáveis sem linhas.  Ele representa as
condições de realização daquela ação.  Em seguida, o segundo conjunto é constituído
pelas ações -- nas quais aparecem constantes, variáveis sem linhas e com linhas --
que especificam as operações de \doris.

Lembrar que em TLA+, a indentação é utilizada preferencialmente no lugar de
parênteses. Desta forma, os operadores \txtla{\.{\land}} e \txtla{\.{\lor}} são
utilizados para escrever fórmulas lógicas complexas sob a forma de listas
indentadas.

Duas construções de TLA+ merecem ser descritas aqui, pois são utilizadas em todas
as ações.
\begin{itemize}
\item A construção sintática \txtla{\.{LET} \ldots \.{IN}} é utilizada para definir
  constantes locais. O escopo da constante definido no escopo do $LET$ são as fórmulas
 contidas no $IN$.
 \item A palavra \txtla{EXCEPT}