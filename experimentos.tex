\xchapter{Experimentos}{Coleta e análise de dados}

Nesta seção irei mostrar o resultado das medições de latência realizadas no Raspberry. Será comparado os valores entre diferentes versões do kernel, entre diferentes tipos de interrupção e entre diferentes cargas na CPU.

\section{Configuração do teste}

As medições foram agrupadas por tipo de kernel, tipo de interrupção e carga na CPU. Durante a construção deste trabalho foram encontrados problemas na adaptação do INTSight com o Xenomai, detalhados no capítulo 5. Portanto esta sessão irá abordar os resultados com o kernel padrão do Linux e os resultados com o Preempt-RT. Essas configurações resultam em um total de 18 grupos de teste. Cada grupo passou por uma bateria de medições. Em cada bateria de teste, foram executadas 50000 medições com um intervalo de 20ms entre elas. 

O INTSight gera 2 arquivos no format CSV para cada bateria de medições. Um dos arquivos chamado name contém o tipo de evento que disparou a coleta do tempo de sistema. Outro arquivo com o nome do tipo de contador utilizado, ktime\_mono\_fast em todos os teste deste trabalho, contém o valor do contador no instante que a coleta foi disparada. Em ambos os arquivos, cada medição ocupa uma linha do arquivo.

No repositório do INTSight é disponibilizado um script em R que faz o junção destes arquivos em um único utilzando as seguintes informação: position (posição do item dentro da medição), run (número da medição dentro da bateria), name (evento que disparou a medição), ktime\_mono\_fast (valor do contador de tempo). Para consolidar os resultados das 18 baterias, foi feito um script Python que encontra-se disponível no repositório https://github.com/taianf/kernel-tcc/tree/master/benchmarks. Este script também faz um tratamento dos dados úteis, pois o INTSight pode apresentar valores zerados quando ocorre algum erro durante uma medição.

\section{Visão geral}

A primeira letra representa o kernel testado: (R)aspberry padrão ou (P)reempt-RT.
A segunda letra é o tipo de interrupção testado: (S)oftirq, (T)asklet ou (W)orkqueue.
O terceiro caracter é a carga na cpu: 0 thread, 1 thread, (M)any threads (256).

Na tabela \ref{table:rpi} temos uma visão sumarizada do tempo de latência em nanossegundos de todos os testes realizados com o kernel padrão enquanto na tabela \ref{table:prt} temos uma visão dos testes no Preempt-RT.

\begin{table}[!htb]
\centering
\begin{center}
\begin{tabular}{|c|r|r|r|r|r|r|r|r|r|}
\toprule
Percentil &    RS0 &     RS1 &    RSM &    RT0 &    RT1 &    RTM &    RW0 &     RW1 &      RWM \\
\midrule
    min &    833 &    365 &    781 &    625 &    938 &    573 &   7604 &    5730 &     5156 \\
    25\% &   1041 &    937 &    937 &   1145 &   1145 &   1146 &   8021 &    8073 &     8750 \\
    50\% &   1042 &    938 &    938 &   1146 &   1146 &   1146 &   8124 &    8177 &     8854 \\
    75\% &   1094 &    990 &    990 &   1198 &   1198 &   1250 &   8229 &    8802 &     8958 \\
    90\% &   1146 &   1094 &   1042 &   1302 &   1302 &   1406 &   8489 &    9011 &     9218 \\
    95\% &   1198 &   1146 &   1146 &   1406 &   1927 &   2187 &  11511 &    9896 &     9791 \\
    99\% &   6041 &   5677 &   5937 &   6250 &   6251 &   6198 &  16666 &   18021 &    18282 \\
  99.9\% &   6927 &   6406 &   7187 &   7188 &   8073 &  10677 &  30520 &   27917 &    25052 \\
    max &  15156 &  20365 &  19375 &  34998 &  25834 &  45260 &  84635 &  983798 &  4153458 \\
\bottomrule
\end{tabular}
\end{center}
\caption{Principais dados das medidas do kernel padrão}
\label{table:rpi}
\end{table}

\begin{table}[!htb]
\centering
\begin{center}
\begin{tabular}{|c|r|r|r|r|r|r|r|r|r|}
\toprule
Percentil &    PS0 &    PS1 &    PSM &    PT0 &    PT1 &    PTM &    PW0 &     PW1 &    PWM \\
\midrule
  min &   1197 &   1146 &   1197 &   1614 &   1563 &   1614 &  11563 &  11562 &  11562 \\
  25\% &   1406 &   1406 &   1406 &   1823 &   1823 &   1823 &  12084 &  12031 &  12083 \\
  50\% &   1407 &   1407 &   1458 &   1875 &   1875 &   1875 &  12239 &  12135 &  12187 \\
  75\% &   1459 &   1458 &   1459 &   1927 &   1927 &   1875 &  12396 &  12291 &  12344 \\
  90\% &   1510 &   1510 &   1510 &   1980 &   1979 &   1927 &  12761 &  12605 &  12656 \\
  95\% &   1511 &   1511 &   1511 &   2032 &   2031 &   1979 &  13334 &  13229 &  13073 \\
  99\% &   1979 &   1823 &   1979 &   2447 &   3073 &   3125 &  21928 &  20313 &  19323 \\
99.9\% &   4896 &   4062 &   4844 &   5364 &   5781 &   5468 &  40677 &  46146 &  39843 \\
max &  18698 &  17656 &  17657 &  17343 &  16979 &  17865 &  80526 &  73854 &  86198 \\
\bottomrule
\end{tabular}
\end{center}
\caption{Principais dados das medidas do Preempt-RT}
\label{table:prt}
\end{table}

\section{Análise comparativa}

Aqui será mostrado como cada kernel se desempenhou com diferentes cargas de trabalho em cada um dos mecanismos de interrupção. Os gráficos das sessões a seguir mostram os valores da latência nos percentis de de 90\% até 99,9\%. O valor máximo foi omitido da visualização pois costumam ser picos muito distantes do valor do percentil de 99,9\%, dificultando a análise visual do comportamento dos kernels.


\subsection{Softirq}

Na figura \ref{grafico:softirq} podemos ver como ambos os kernels se comportam para o tipo de interrupção Softirq. O Preempt-RT tem uma latência mais alta nos casos médios que se mantém até aproximadamente os percentis entre 94,6\% e 97,4\%. Nessa faixa a latência do kernel padrão começa a subir enquanto o Preempt-RT se mantém estável até aproximadamente o percentil de 98,5\%. Para o pior caso de cada bateria de testes temos a tabela \ref{table:max-softirq}, onde veremos os principais pontos.

Nos casos com a CPU ociosa, o Preempt-RT apresentou um tempo pior que o kernel padrão para o pior caso, o que contraria as expectativas.

Com a CPU com 1 thread de carga, o Preempt-RT teve uma pequena redução no seu pior tempo, enquanto o kernel padrão teve um pior tempo muito mais alto em relação a CPU ociosa. Aqui podemos ver que o kernel de tempo real consegui cumprir a sua premissa de ter um pior caso dentro de um nível aceitável, enquanto o kernel padrão não tem nenhum compromisso com o pior caso.

Com a CPU super carregada, o kernel padrão tem uma queda substancial na latência máxima, com valores próximos ao nível da CPU ociosa. O Preempt-RT teve um valor máximo semelhante ao caso com apenas 1 thread de carga.

O Preempt-RT se mostra bem estável, independente do tipo de carga na CPU, para as interrupções do tipo Softirq. O kernel padrão tem comportamento parecido com a CPU ociosa ou com a CPU sobrecarregada, mas quando possui uma carga leve, os tempos tendem a ser mais altos.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.85\textwidth]{graficos/softirq.png}
    \caption{Latência com Softirq em nanossegundos}
    \label{grafico:softirq}
\end{figure}

\begin{table}[!htb]
    \centering
    \begin{center}
        \begin{tabular}{|r|r|r|r|r|r|}
            \toprule
                PS0 &    PS1 &    PSM &    RS0 &     RS1 &    RSM \\
            \midrule
                18698 &  17656 &  17657 & 15156 &  20365 &  19375 \\
            \bottomrule
        \end{tabular}
    \end{center}
    \caption{Latência máxima para o Softirq}
    \label{table:max-softirq}
\end{table}


\subsection{Tasklet}

Para o tipo de interrupção Tasklet, ambos os kernels se comportam de maneira semelhante ao Softirq, porém com um tempo um pouco maior, como podemos ver na figura \ref{grafico:tasklet}. O kernel padrão tem tempos de resposta melhor até aproximadamente 95\% quando possui carga na CPU ou até próximo dos 98\% quando a CPU está ociosa. Também na faixa de 98\% é quando o Preempt-RT começa a apresentar uma subida na latência. Na tabela \ref{table:max-tasklet} temos os valores de pior caso para os testes com o Tasklet.

Podemos ver que o Preempt-RT teve quase nenhuma influência pelo nível de carga imposto à CPU. No kernel padrão há uma pequena variação entre os valores a depender da carga imposta, mas ainda uma variação dentro de um faixa não muito larga.

Ao contrário do que acontece no Softirq, no Tasklet a latência máxima do Preempt-RT é bem menor do que no kernel padrão. O Preempt-RT tem um tempo de resposta máximo que é praticamente metade do tempo do kernel padrão.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.85\textwidth]{graficos/tasklet.png}
    \caption{Latência com Tasklet em nanossegundos}
    \label{grafico:tasklet}
\end{figure}

\begin{table}[!htb]
    \centering
    \begin{center}
        \begin{tabular}{|r|r|r|r|r|r|}
            \toprule
                PT0 &    PT1 &    PTM &    RT0 &     RT1 &    RTM \\
            \midrule
                17343 &  16979 &  17865 & 34998 &  25834 &  45260  \\
            \bottomrule
        \end{tabular}
    \end{center}
    \caption{Latência máxima para o Tasklet}
    \label{table:max-tasklet}
\end{table}


\subsection{Workqueue}

No tipo de interrupção Workqueue as diferenças são sutis se o tempo máximo não for levado em conta e a figura \ref{grafico:workqueue} mostra bem isso. Por outro lado, se formos análisar apenas o tempo máximo, a diferença entre os kernels é muito alta, como vemos na tabela \ref{table:max-workqueue}.

Ambos os kernels tem um desempenho similar quando não há carga na CPU, mas com 1 thread de carga, o kernel padrão apresenta um tempo máximo mais de 10 vezes maior se comparado à situação com a CPU ociosa. No Preempt-RT esse aumento é de 3 vezes, mas ficando com um tempo de resposta de praticamente 1/4 do tempo do kernel padrão.

Quando se considera uma CPU sobrecarregada, o tempo do Preempt-RT se assemelhou ao tempo da CPU ociosa. O kernel padrão teve um tempo de resposta quase 50 vezes maior se comparado ao cenário ocioso, mesma magnitude se comparado ao tempo do Preempt-RT.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.85\textwidth]{graficos/workqueue.png}
    \caption{Latência com Workqueue em nanossegundos}
    \label{grafico:workqueue}
\end{figure}

\begin{table}[!htb]
    \centering
    \begin{center}
        \begin{tabular}{|r|r|r|r|r|r|}
            \toprule
                PW0 &    PS1 &    PWM &    RW0 &     RW1 &    RWM \\
            \midrule
                80526 &  73854 &  86198 & 84635 &  983798 &  4153458 \\
            \bottomrule
        \end{tabular}
    \end{center}
    \caption{Latência máxima para o Workqueue}
    \label{table:max-workqueue}
\end{table}
